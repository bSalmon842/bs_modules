//
// This file was auto-generated using the following command:
//
// jai generate.jai
//



VULKAN_H_ :: 1;

VULKAN_CORE_H_ :: 1;

VK_VERSION_1_0 :: 1;

VK_USE_64_BIT_PTR_DEFINES :: 1;

VK_NULL_HANDLE :: cast(*void) 0;

VK_HEADER_VERSION :: 268;

VK_ATTACHMENT_UNUSED :: ~0;
VK_FALSE :: 0;
VK_LOD_CLAMP_NONE :: 1000.0;
VK_QUEUE_FAMILY_IGNORED :: ~0;
VK_REMAINING_ARRAY_LAYERS :: ~0;
VK_REMAINING_MIP_LEVELS :: ~0;
VK_SUBPASS_EXTERNAL :: ~0;
VK_TRUE :: 1;
VK_WHOLE_SIZE :: ~0;
VK_MAX_MEMORY_TYPES :: 32;
VK_MAX_PHYSICAL_DEVICE_NAME_SIZE :: 256;
VK_UUID_SIZE :: 16;
VK_MAX_EXTENSION_NAME_SIZE :: 256;
VK_MAX_DESCRIPTION_SIZE :: 256;
VK_MAX_MEMORY_HEAPS :: 16;

VK_VERSION_1_1 :: 1;

VK_MAX_DEVICE_GROUP_SIZE :: 32;
VK_LUID_SIZE :: 8;
VK_QUEUE_FAMILY_EXTERNAL :: ~1;

VK_VERSION_1_2 :: 1;

VK_MAX_DRIVER_NAME_SIZE :: 256;
VK_MAX_DRIVER_INFO_SIZE :: 256;

VK_VERSION_1_3 :: 1;

VK_KHR_surface :: 1;

VK_KHR_SURFACE_SPEC_VERSION :: 25;
VK_KHR_SURFACE_EXTENSION_NAME :: "VK_KHR_surface";

VK_KHR_swapchain :: 1;

VK_KHR_SWAPCHAIN_SPEC_VERSION :: 70;
VK_KHR_SWAPCHAIN_EXTENSION_NAME :: "VK_KHR_swapchain";

VK_KHR_display :: 1;

VK_KHR_DISPLAY_SPEC_VERSION :: 23;
VK_KHR_DISPLAY_EXTENSION_NAME :: "VK_KHR_display";

VK_KHR_display_swapchain :: 1;
VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION :: 10;
VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME :: "VK_KHR_display_swapchain";

VK_KHR_sampler_mirror_clamp_to_edge :: 1;
VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION :: 3;
VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME :: "VK_KHR_sampler_mirror_clamp_to_edge";

VK_KHR_video_queue :: 1;

VK_KHR_VIDEO_QUEUE_SPEC_VERSION :: 8;
VK_KHR_VIDEO_QUEUE_EXTENSION_NAME :: "VK_KHR_video_queue";

VK_KHR_video_decode_queue :: 1;
VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION :: 7;
VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME :: "VK_KHR_video_decode_queue";

VK_KHR_video_decode_h264 :: 1;

VULKAN_VIDEO_CODEC_H264STD_H_ :: 1;

vulkan_video_codec_h264std :: 1;

VULKAN_VIDEO_CODECS_COMMON_H_ :: 1;

vulkan_video_codecs_common :: 1;

STD_VIDEO_H264_CPB_CNT_LIST_SIZE :: 32;
STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS :: 6;
STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS :: 16;
STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS :: 6;
STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS :: 64;
STD_VIDEO_H264_MAX_NUM_LIST_REF :: 32;
STD_VIDEO_H264_MAX_CHROMA_PLANES :: 2;
STD_VIDEO_H264_NO_REFERENCE_PICTURE :: 0xFF;

VULKAN_VIDEO_CODEC_H264STD_DECODE_H_ :: 1;

vulkan_video_codec_h264std_decode :: 1;

VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME :: "VK_STD_vulkan_video_codec_h264_decode";
STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE :: 2;

VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION :: 8;
VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME :: "VK_KHR_video_decode_h264";

VK_KHR_dynamic_rendering :: 1;
VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION :: 1;
VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME :: "VK_KHR_dynamic_rendering";

VK_KHR_multiview :: 1;
VK_KHR_MULTIVIEW_SPEC_VERSION :: 1;
VK_KHR_MULTIVIEW_EXTENSION_NAME :: "VK_KHR_multiview";

VK_KHR_get_physical_device_properties2 :: 1;
VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION :: 2;
VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME :: "VK_KHR_get_physical_device_properties2";

VK_KHR_device_group :: 1;
VK_KHR_DEVICE_GROUP_SPEC_VERSION :: 4;
VK_KHR_DEVICE_GROUP_EXTENSION_NAME :: "VK_KHR_device_group";

VK_KHR_shader_draw_parameters :: 1;
VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION :: 1;
VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME :: "VK_KHR_shader_draw_parameters";

VK_KHR_maintenance1 :: 1;
VK_KHR_MAINTENANCE_1_SPEC_VERSION :: 2;
VK_KHR_MAINTENANCE_1_EXTENSION_NAME :: "VK_KHR_maintenance1";
VK_KHR_MAINTENANCE1_SPEC_VERSION :: VK_KHR_MAINTENANCE_1_SPEC_VERSION;
VK_KHR_MAINTENANCE1_EXTENSION_NAME :: VK_KHR_MAINTENANCE_1_EXTENSION_NAME;

VK_KHR_device_group_creation :: 1;
VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION :: 1;
VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME :: "VK_KHR_device_group_creation";
VK_MAX_DEVICE_GROUP_SIZE_KHR :: VK_MAX_DEVICE_GROUP_SIZE;

VK_KHR_external_memory_capabilities :: 1;
VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_memory_capabilities";
VK_LUID_SIZE_KHR :: VK_LUID_SIZE;

VK_KHR_external_memory :: 1;
VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME :: "VK_KHR_external_memory";
VK_QUEUE_FAMILY_EXTERNAL_KHR :: VK_QUEUE_FAMILY_EXTERNAL;

VK_KHR_external_memory_fd :: 1;
VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME :: "VK_KHR_external_memory_fd";

VK_KHR_external_semaphore_capabilities :: 1;
VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_semaphore_capabilities";

VK_KHR_external_semaphore :: 1;
VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME :: "VK_KHR_external_semaphore";

VK_KHR_external_semaphore_fd :: 1;
VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME :: "VK_KHR_external_semaphore_fd";

VK_KHR_push_descriptor :: 1;
VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION :: 2;
VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME :: "VK_KHR_push_descriptor";

VK_KHR_shader_float16_int8 :: 1;
VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION :: 1;
VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME :: "VK_KHR_shader_float16_int8";

VK_KHR_16bit_storage :: 1;
VK_KHR_16BIT_STORAGE_SPEC_VERSION :: 1;
VK_KHR_16BIT_STORAGE_EXTENSION_NAME :: "VK_KHR_16bit_storage";

VK_KHR_incremental_present :: 1;
VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION :: 2;
VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME :: "VK_KHR_incremental_present";

VK_KHR_descriptor_update_template :: 1;

VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION :: 1;
VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME :: "VK_KHR_descriptor_update_template";

VK_KHR_imageless_framebuffer :: 1;
VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION :: 1;
VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME :: "VK_KHR_imageless_framebuffer";

VK_KHR_create_renderpass2 :: 1;
VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION :: 1;
VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME :: "VK_KHR_create_renderpass2";

VK_KHR_shared_presentable_image :: 1;
VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION :: 1;
VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME :: "VK_KHR_shared_presentable_image";

VK_KHR_external_fence_capabilities :: 1;
VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_fence_capabilities";

VK_KHR_external_fence :: 1;
VK_KHR_EXTERNAL_FENCE_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME :: "VK_KHR_external_fence";

VK_KHR_external_fence_fd :: 1;
VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION :: 1;
VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME :: "VK_KHR_external_fence_fd";

VK_KHR_performance_query :: 1;
VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION :: 1;
VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME :: "VK_KHR_performance_query";

VK_KHR_maintenance2 :: 1;
VK_KHR_MAINTENANCE_2_SPEC_VERSION :: 1;
VK_KHR_MAINTENANCE_2_EXTENSION_NAME :: "VK_KHR_maintenance2";
VK_KHR_MAINTENANCE2_SPEC_VERSION :: VK_KHR_MAINTENANCE_2_SPEC_VERSION;
VK_KHR_MAINTENANCE2_EXTENSION_NAME :: VK_KHR_MAINTENANCE_2_EXTENSION_NAME;

VK_KHR_get_surface_capabilities2 :: 1;
VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION :: 1;
VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME :: "VK_KHR_get_surface_capabilities2";

VK_KHR_variable_pointers :: 1;
VK_KHR_VARIABLE_POINTERS_SPEC_VERSION :: 1;
VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME :: "VK_KHR_variable_pointers";

VK_KHR_get_display_properties2 :: 1;
VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION :: 1;
VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME :: "VK_KHR_get_display_properties2";

VK_KHR_dedicated_allocation :: 1;
VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION :: 3;
VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME :: "VK_KHR_dedicated_allocation";

VK_KHR_storage_buffer_storage_class :: 1;
VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION :: 1;
VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME :: "VK_KHR_storage_buffer_storage_class";

VK_KHR_relaxed_block_layout :: 1;
VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION :: 1;
VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME :: "VK_KHR_relaxed_block_layout";

VK_KHR_get_memory_requirements2 :: 1;
VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION :: 1;
VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME :: "VK_KHR_get_memory_requirements2";

VK_KHR_image_format_list :: 1;
VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION :: 1;
VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME :: "VK_KHR_image_format_list";

VK_KHR_sampler_ycbcr_conversion :: 1;

VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION :: 14;
VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME :: "VK_KHR_sampler_ycbcr_conversion";

VK_KHR_bind_memory2 :: 1;
VK_KHR_BIND_MEMORY_2_SPEC_VERSION :: 1;
VK_KHR_BIND_MEMORY_2_EXTENSION_NAME :: "VK_KHR_bind_memory2";

VK_KHR_maintenance3 :: 1;
VK_KHR_MAINTENANCE_3_SPEC_VERSION :: 1;
VK_KHR_MAINTENANCE_3_EXTENSION_NAME :: "VK_KHR_maintenance3";
VK_KHR_MAINTENANCE3_SPEC_VERSION :: VK_KHR_MAINTENANCE_3_SPEC_VERSION;
VK_KHR_MAINTENANCE3_EXTENSION_NAME :: VK_KHR_MAINTENANCE_3_EXTENSION_NAME;

VK_KHR_draw_indirect_count :: 1;
VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION :: 1;
VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME :: "VK_KHR_draw_indirect_count";

VK_KHR_shader_subgroup_extended_types :: 1;
VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION :: 1;
VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME :: "VK_KHR_shader_subgroup_extended_types";

VK_KHR_8bit_storage :: 1;
VK_KHR_8BIT_STORAGE_SPEC_VERSION :: 1;
VK_KHR_8BIT_STORAGE_EXTENSION_NAME :: "VK_KHR_8bit_storage";

VK_KHR_shader_atomic_int64 :: 1;
VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION :: 1;
VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME :: "VK_KHR_shader_atomic_int64";

VK_KHR_shader_clock :: 1;
VK_KHR_SHADER_CLOCK_SPEC_VERSION :: 1;
VK_KHR_SHADER_CLOCK_EXTENSION_NAME :: "VK_KHR_shader_clock";

VK_KHR_video_decode_h265 :: 1;

VULKAN_VIDEO_CODEC_H265STD_H_ :: 1;

vulkan_video_codec_h265std :: 1;

STD_VIDEO_H265_CPB_CNT_LIST_SIZE :: 32;
STD_VIDEO_H265_SUBLAYERS_LIST_SIZE :: 7;
STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS :: 6;
STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS :: 16;
STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS :: 6;
STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS :: 64;
STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS :: 6;
STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS :: 64;
STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS :: 2;
STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS :: 64;
STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE :: 6;
STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE :: 19;
STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE :: 21;
STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE :: 3;
STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE :: 128;
STD_VIDEO_H265_MAX_NUM_LIST_REF :: 15;
STD_VIDEO_H265_MAX_CHROMA_PLANES :: 2;
STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS :: 64;
STD_VIDEO_H265_MAX_DPB_SIZE :: 16;
STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS :: 32;
STD_VIDEO_H265_MAX_LONG_TERM_PICS :: 16;
STD_VIDEO_H265_MAX_DELTA_POC :: 48;
STD_VIDEO_H265_NO_REFERENCE_PICTURE :: 0xFF;

VULKAN_VIDEO_CODEC_H265STD_DECODE_H_ :: 1;

vulkan_video_codec_h265std_decode :: 1;

VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME :: "VK_STD_vulkan_video_codec_h265_decode";
STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE :: 8;

VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION :: 7;
VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME :: "VK_KHR_video_decode_h265";

VK_KHR_global_priority :: 1;
VK_MAX_GLOBAL_PRIORITY_SIZE_KHR :: 16;
VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION :: 1;
VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME :: "VK_KHR_global_priority";

VK_KHR_driver_properties :: 1;
VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION :: 1;
VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME :: "VK_KHR_driver_properties";
VK_MAX_DRIVER_NAME_SIZE_KHR :: VK_MAX_DRIVER_NAME_SIZE;
VK_MAX_DRIVER_INFO_SIZE_KHR :: VK_MAX_DRIVER_INFO_SIZE;

VK_KHR_shader_float_controls :: 1;
VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION :: 4;
VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME :: "VK_KHR_shader_float_controls";

VK_KHR_depth_stencil_resolve :: 1;
VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION :: 1;
VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME :: "VK_KHR_depth_stencil_resolve";

VK_KHR_swapchain_mutable_format :: 1;
VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION :: 1;
VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME :: "VK_KHR_swapchain_mutable_format";

VK_KHR_timeline_semaphore :: 1;
VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION :: 2;
VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME :: "VK_KHR_timeline_semaphore";

VK_KHR_vulkan_memory_model :: 1;
VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION :: 3;
VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME :: "VK_KHR_vulkan_memory_model";

VK_KHR_shader_terminate_invocation :: 1;
VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION :: 1;
VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME :: "VK_KHR_shader_terminate_invocation";

VK_KHR_fragment_shading_rate :: 1;
VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION :: 2;
VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME :: "VK_KHR_fragment_shading_rate";

VK_KHR_spirv_1_4 :: 1;
VK_KHR_SPIRV_1_4_SPEC_VERSION :: 1;
VK_KHR_SPIRV_1_4_EXTENSION_NAME :: "VK_KHR_spirv_1_4";

VK_KHR_surface_protected_capabilities :: 1;
VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION :: 1;
VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_surface_protected_capabilities";

VK_KHR_separate_depth_stencil_layouts :: 1;
VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION :: 1;
VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME :: "VK_KHR_separate_depth_stencil_layouts";

VK_KHR_present_wait :: 1;
VK_KHR_PRESENT_WAIT_SPEC_VERSION :: 1;
VK_KHR_PRESENT_WAIT_EXTENSION_NAME :: "VK_KHR_present_wait";

VK_KHR_uniform_buffer_standard_layout :: 1;
VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION :: 1;
VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME :: "VK_KHR_uniform_buffer_standard_layout";

VK_KHR_buffer_device_address :: 1;
VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION :: 1;
VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME :: "VK_KHR_buffer_device_address";

VK_KHR_deferred_host_operations :: 1;

VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION :: 4;
VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME :: "VK_KHR_deferred_host_operations";

VK_KHR_pipeline_executable_properties :: 1;
VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION :: 1;
VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME :: "VK_KHR_pipeline_executable_properties";

VK_KHR_map_memory2 :: 1;
VK_KHR_MAP_MEMORY_2_SPEC_VERSION :: 1;
VK_KHR_MAP_MEMORY_2_EXTENSION_NAME :: "VK_KHR_map_memory2";

VK_KHR_shader_integer_dot_product :: 1;
VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION :: 1;
VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME :: "VK_KHR_shader_integer_dot_product";

VK_KHR_pipeline_library :: 1;
VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION :: 1;
VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME :: "VK_KHR_pipeline_library";

VK_KHR_shader_non_semantic_info :: 1;
VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION :: 1;
VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME :: "VK_KHR_shader_non_semantic_info";

VK_KHR_present_id :: 1;
VK_KHR_PRESENT_ID_SPEC_VERSION :: 1;
VK_KHR_PRESENT_ID_EXTENSION_NAME :: "VK_KHR_present_id";

VK_KHR_synchronization2 :: 1;
VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION :: 1;
VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME :: "VK_KHR_synchronization2";

VK_KHR_fragment_shader_barycentric :: 1;
VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION :: 1;
VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME :: "VK_KHR_fragment_shader_barycentric";

VK_KHR_shader_subgroup_uniform_control_flow :: 1;
VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION :: 1;
VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME :: "VK_KHR_shader_subgroup_uniform_control_flow";

VK_KHR_zero_initialize_workgroup_memory :: 1;
VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION :: 1;
VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME :: "VK_KHR_zero_initialize_workgroup_memory";

VK_KHR_workgroup_memory_explicit_layout :: 1;
VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION :: 1;
VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME :: "VK_KHR_workgroup_memory_explicit_layout";

VK_KHR_copy_commands2 :: 1;
VK_KHR_COPY_COMMANDS_2_SPEC_VERSION :: 1;
VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME :: "VK_KHR_copy_commands2";

VK_KHR_format_feature_flags2 :: 1;
VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION :: 2;
VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME :: "VK_KHR_format_feature_flags2";

VK_KHR_ray_tracing_maintenance1 :: 1;
VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION :: 1;
VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME :: "VK_KHR_ray_tracing_maintenance1";

VK_KHR_portability_enumeration :: 1;
VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION :: 1;
VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME :: "VK_KHR_portability_enumeration";

VK_KHR_maintenance4 :: 1;
VK_KHR_MAINTENANCE_4_SPEC_VERSION :: 2;
VK_KHR_MAINTENANCE_4_EXTENSION_NAME :: "VK_KHR_maintenance4";

VK_KHR_maintenance5 :: 1;
VK_KHR_MAINTENANCE_5_SPEC_VERSION :: 1;
VK_KHR_MAINTENANCE_5_EXTENSION_NAME :: "VK_KHR_maintenance5";

VK_KHR_ray_tracing_position_fetch :: 1;
VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION :: 1;
VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME :: "VK_KHR_ray_tracing_position_fetch";

VK_KHR_cooperative_matrix :: 1;
VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION :: 2;
VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME :: "VK_KHR_cooperative_matrix";

VK_EXT_debug_report :: 1;

VK_EXT_DEBUG_REPORT_SPEC_VERSION :: 10;
VK_EXT_DEBUG_REPORT_EXTENSION_NAME :: "VK_EXT_debug_report";

VK_NV_glsl_shader :: 1;
VK_NV_GLSL_SHADER_SPEC_VERSION :: 1;
VK_NV_GLSL_SHADER_EXTENSION_NAME :: "VK_NV_glsl_shader";

VK_EXT_depth_range_unrestricted :: 1;
VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION :: 1;
VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME :: "VK_EXT_depth_range_unrestricted";

VK_IMG_filter_cubic :: 1;
VK_IMG_FILTER_CUBIC_SPEC_VERSION :: 1;
VK_IMG_FILTER_CUBIC_EXTENSION_NAME :: "VK_IMG_filter_cubic";

VK_AMD_rasterization_order :: 1;
VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION :: 1;
VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME :: "VK_AMD_rasterization_order";

VK_AMD_shader_trinary_minmax :: 1;
VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION :: 1;
VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME :: "VK_AMD_shader_trinary_minmax";

VK_AMD_shader_explicit_vertex_parameter :: 1;
VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION :: 1;
VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME :: "VK_AMD_shader_explicit_vertex_parameter";

VK_EXT_debug_marker :: 1;
VK_EXT_DEBUG_MARKER_SPEC_VERSION :: 4;
VK_EXT_DEBUG_MARKER_EXTENSION_NAME :: "VK_EXT_debug_marker";

VK_AMD_gcn_shader :: 1;
VK_AMD_GCN_SHADER_SPEC_VERSION :: 1;
VK_AMD_GCN_SHADER_EXTENSION_NAME :: "VK_AMD_gcn_shader";

VK_NV_dedicated_allocation :: 1;
VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION :: 1;
VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME :: "VK_NV_dedicated_allocation";

VK_EXT_transform_feedback :: 1;
VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION :: 1;
VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME :: "VK_EXT_transform_feedback";

VK_NVX_binary_import :: 1;

VK_NVX_BINARY_IMPORT_SPEC_VERSION :: 1;
VK_NVX_BINARY_IMPORT_EXTENSION_NAME :: "VK_NVX_binary_import";

VK_NVX_image_view_handle :: 1;
VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION :: 2;
VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME :: "VK_NVX_image_view_handle";

VK_AMD_draw_indirect_count :: 1;
VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION :: 2;
VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME :: "VK_AMD_draw_indirect_count";

VK_AMD_negative_viewport_height :: 1;
VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION :: 1;
VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME :: "VK_AMD_negative_viewport_height";

VK_AMD_gpu_shader_half_float :: 1;
VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION :: 2;
VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME :: "VK_AMD_gpu_shader_half_float";

VK_AMD_shader_ballot :: 1;
VK_AMD_SHADER_BALLOT_SPEC_VERSION :: 1;
VK_AMD_SHADER_BALLOT_EXTENSION_NAME :: "VK_AMD_shader_ballot";

VK_AMD_texture_gather_bias_lod :: 1;
VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION :: 1;
VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME :: "VK_AMD_texture_gather_bias_lod";

VK_AMD_shader_info :: 1;
VK_AMD_SHADER_INFO_SPEC_VERSION :: 1;
VK_AMD_SHADER_INFO_EXTENSION_NAME :: "VK_AMD_shader_info";

VK_AMD_shader_image_load_store_lod :: 1;
VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION :: 1;
VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME :: "VK_AMD_shader_image_load_store_lod";

VK_NV_corner_sampled_image :: 1;
VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION :: 2;
VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME :: "VK_NV_corner_sampled_image";

VK_IMG_format_pvrtc :: 1;
VK_IMG_FORMAT_PVRTC_SPEC_VERSION :: 1;
VK_IMG_FORMAT_PVRTC_EXTENSION_NAME :: "VK_IMG_format_pvrtc";

VK_NV_external_memory_capabilities :: 1;
VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION :: 1;
VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME :: "VK_NV_external_memory_capabilities";

VK_NV_external_memory :: 1;
VK_NV_EXTERNAL_MEMORY_SPEC_VERSION :: 1;
VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME :: "VK_NV_external_memory";

VK_EXT_validation_flags :: 1;
VK_EXT_VALIDATION_FLAGS_SPEC_VERSION :: 2;
VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME :: "VK_EXT_validation_flags";

VK_EXT_shader_subgroup_ballot :: 1;
VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION :: 1;
VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME :: "VK_EXT_shader_subgroup_ballot";

VK_EXT_shader_subgroup_vote :: 1;
VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION :: 1;
VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME :: "VK_EXT_shader_subgroup_vote";

VK_EXT_texture_compression_astc_hdr :: 1;
VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION :: 1;
VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME :: "VK_EXT_texture_compression_astc_hdr";

VK_EXT_astc_decode_mode :: 1;
VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION :: 1;
VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME :: "VK_EXT_astc_decode_mode";

VK_EXT_pipeline_robustness :: 1;
VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION :: 1;
VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME :: "VK_EXT_pipeline_robustness";

VK_EXT_conditional_rendering :: 1;
VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION :: 2;
VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME :: "VK_EXT_conditional_rendering";

VK_NV_clip_space_w_scaling :: 1;
VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION :: 1;
VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME :: "VK_NV_clip_space_w_scaling";

VK_EXT_direct_mode_display :: 1;
VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION :: 1;
VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME :: "VK_EXT_direct_mode_display";

VK_EXT_display_surface_counter :: 1;
VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION :: 1;
VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME :: "VK_EXT_display_surface_counter";

VK_EXT_display_control :: 1;
VK_EXT_DISPLAY_CONTROL_SPEC_VERSION :: 1;
VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME :: "VK_EXT_display_control";

VK_GOOGLE_display_timing :: 1;
VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION :: 1;
VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME :: "VK_GOOGLE_display_timing";

VK_NV_sample_mask_override_coverage :: 1;
VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION :: 1;
VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME :: "VK_NV_sample_mask_override_coverage";

VK_NV_geometry_shader_passthrough :: 1;
VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION :: 1;
VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME :: "VK_NV_geometry_shader_passthrough";

VK_NV_viewport_array2 :: 1;
VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION :: 1;
VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME :: "VK_NV_viewport_array2";
VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION :: VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION;
VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME :: VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME;

VK_NVX_multiview_per_view_attributes :: 1;
VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION :: 1;
VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME :: "VK_NVX_multiview_per_view_attributes";

VK_NV_viewport_swizzle :: 1;
VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION :: 1;
VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME :: "VK_NV_viewport_swizzle";

VK_EXT_discard_rectangles :: 1;
VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION :: 2;
VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME :: "VK_EXT_discard_rectangles";

VK_EXT_conservative_rasterization :: 1;
VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION :: 1;
VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME :: "VK_EXT_conservative_rasterization";

VK_EXT_depth_clip_enable :: 1;
VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION :: 1;
VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME :: "VK_EXT_depth_clip_enable";

VK_EXT_swapchain_colorspace :: 1;
VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION :: 4;
VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME :: "VK_EXT_swapchain_colorspace";

VK_EXT_hdr_metadata :: 1;
VK_EXT_HDR_METADATA_SPEC_VERSION :: 2;
VK_EXT_HDR_METADATA_EXTENSION_NAME :: "VK_EXT_hdr_metadata";

VK_EXT_external_memory_dma_buf :: 1;
VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION :: 1;
VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME :: "VK_EXT_external_memory_dma_buf";

VK_EXT_queue_family_foreign :: 1;
VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION :: 1;
VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME :: "VK_EXT_queue_family_foreign";
VK_QUEUE_FAMILY_FOREIGN_EXT :: ~2;

VK_EXT_debug_utils :: 1;

VK_EXT_DEBUG_UTILS_SPEC_VERSION :: 2;
VK_EXT_DEBUG_UTILS_EXTENSION_NAME :: "VK_EXT_debug_utils";

VK_EXT_sampler_filter_minmax :: 1;
VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION :: 2;
VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME :: "VK_EXT_sampler_filter_minmax";

VK_AMD_gpu_shader_int16 :: 1;
VK_AMD_GPU_SHADER_INT16_SPEC_VERSION :: 2;
VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME :: "VK_AMD_gpu_shader_int16";

VK_AMD_mixed_attachment_samples :: 1;
VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION :: 1;
VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME :: "VK_AMD_mixed_attachment_samples";

VK_AMD_shader_fragment_mask :: 1;
VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION :: 1;
VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME :: "VK_AMD_shader_fragment_mask";

VK_EXT_inline_uniform_block :: 1;
VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION :: 1;
VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME :: "VK_EXT_inline_uniform_block";

VK_EXT_shader_stencil_export :: 1;
VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION :: 1;
VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME :: "VK_EXT_shader_stencil_export";

VK_EXT_sample_locations :: 1;
VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION :: 1;
VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME :: "VK_EXT_sample_locations";

VK_EXT_blend_operation_advanced :: 1;
VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION :: 2;
VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME :: "VK_EXT_blend_operation_advanced";

VK_NV_fragment_coverage_to_color :: 1;
VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION :: 1;
VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME :: "VK_NV_fragment_coverage_to_color";

VK_NV_framebuffer_mixed_samples :: 1;
VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION :: 1;
VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME :: "VK_NV_framebuffer_mixed_samples";

VK_NV_fill_rectangle :: 1;
VK_NV_FILL_RECTANGLE_SPEC_VERSION :: 1;
VK_NV_FILL_RECTANGLE_EXTENSION_NAME :: "VK_NV_fill_rectangle";

VK_NV_shader_sm_builtins :: 1;
VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION :: 1;
VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME :: "VK_NV_shader_sm_builtins";

VK_EXT_post_depth_coverage :: 1;
VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION :: 1;
VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME :: "VK_EXT_post_depth_coverage";

VK_EXT_image_drm_format_modifier :: 1;
VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION :: 2;
VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME :: "VK_EXT_image_drm_format_modifier";

VK_EXT_validation_cache :: 1;

VK_EXT_VALIDATION_CACHE_SPEC_VERSION :: 1;
VK_EXT_VALIDATION_CACHE_EXTENSION_NAME :: "VK_EXT_validation_cache";

VK_EXT_descriptor_indexing :: 1;
VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION :: 2;
VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME :: "VK_EXT_descriptor_indexing";

VK_EXT_shader_viewport_index_layer :: 1;
VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION :: 1;
VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME :: "VK_EXT_shader_viewport_index_layer";

VK_NV_shading_rate_image :: 1;
VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION :: 3;
VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME :: "VK_NV_shading_rate_image";

VK_NV_ray_tracing :: 1;

VK_NV_RAY_TRACING_SPEC_VERSION :: 3;
VK_NV_RAY_TRACING_EXTENSION_NAME :: "VK_NV_ray_tracing";
VK_SHADER_UNUSED_KHR :: ~0;
VK_SHADER_UNUSED_NV :: VK_SHADER_UNUSED_KHR;

VK_NV_representative_fragment_test :: 1;
VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION :: 2;
VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME :: "VK_NV_representative_fragment_test";

VK_EXT_filter_cubic :: 1;
VK_EXT_FILTER_CUBIC_SPEC_VERSION :: 3;
VK_EXT_FILTER_CUBIC_EXTENSION_NAME :: "VK_EXT_filter_cubic";

VK_QCOM_render_pass_shader_resolve :: 1;
VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION :: 4;
VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME :: "VK_QCOM_render_pass_shader_resolve";

VK_EXT_global_priority :: 1;
VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION :: 2;
VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME :: "VK_EXT_global_priority";

VK_EXT_external_memory_host :: 1;
VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION :: 1;
VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME :: "VK_EXT_external_memory_host";

VK_AMD_buffer_marker :: 1;
VK_AMD_BUFFER_MARKER_SPEC_VERSION :: 1;
VK_AMD_BUFFER_MARKER_EXTENSION_NAME :: "VK_AMD_buffer_marker";

VK_AMD_pipeline_compiler_control :: 1;
VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION :: 1;
VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME :: "VK_AMD_pipeline_compiler_control";

VK_EXT_calibrated_timestamps :: 1;
VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION :: 2;
VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME :: "VK_EXT_calibrated_timestamps";

VK_AMD_shader_core_properties :: 1;
VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION :: 2;
VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME :: "VK_AMD_shader_core_properties";

VK_AMD_memory_overallocation_behavior :: 1;
VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION :: 1;
VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME :: "VK_AMD_memory_overallocation_behavior";

VK_EXT_vertex_attribute_divisor :: 1;
VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION :: 3;
VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME :: "VK_EXT_vertex_attribute_divisor";

VK_EXT_pipeline_creation_feedback :: 1;
VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION :: 1;
VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME :: "VK_EXT_pipeline_creation_feedback";

VK_NV_shader_subgroup_partitioned :: 1;
VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION :: 1;
VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME :: "VK_NV_shader_subgroup_partitioned";

VK_NV_compute_shader_derivatives :: 1;
VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION :: 1;
VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME :: "VK_NV_compute_shader_derivatives";

VK_NV_mesh_shader :: 1;
VK_NV_MESH_SHADER_SPEC_VERSION :: 1;
VK_NV_MESH_SHADER_EXTENSION_NAME :: "VK_NV_mesh_shader";

VK_NV_fragment_shader_barycentric :: 1;
VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION :: 1;
VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME :: "VK_NV_fragment_shader_barycentric";

VK_NV_shader_image_footprint :: 1;
VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION :: 2;
VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME :: "VK_NV_shader_image_footprint";

VK_NV_scissor_exclusive :: 1;
VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION :: 2;
VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME :: "VK_NV_scissor_exclusive";

VK_NV_device_diagnostic_checkpoints :: 1;
VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION :: 2;
VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME :: "VK_NV_device_diagnostic_checkpoints";

VK_INTEL_shader_integer_functions2 :: 1;
VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION :: 1;
VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME :: "VK_INTEL_shader_integer_functions2";

VK_INTEL_performance_query :: 1;

VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION :: 2;
VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME :: "VK_INTEL_performance_query";

VK_EXT_pci_bus_info :: 1;
VK_EXT_PCI_BUS_INFO_SPEC_VERSION :: 2;
VK_EXT_PCI_BUS_INFO_EXTENSION_NAME :: "VK_EXT_pci_bus_info";

VK_AMD_display_native_hdr :: 1;
VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION :: 1;
VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME :: "VK_AMD_display_native_hdr";

VK_EXT_fragment_density_map :: 1;
VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION :: 2;
VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME :: "VK_EXT_fragment_density_map";

VK_EXT_scalar_block_layout :: 1;
VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION :: 1;
VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME :: "VK_EXT_scalar_block_layout";

VK_GOOGLE_hlsl_functionality1 :: 1;
VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION :: 1;
VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME :: "VK_GOOGLE_hlsl_functionality1";
VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION :: VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION;
VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME :: VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME;

VK_GOOGLE_decorate_string :: 1;
VK_GOOGLE_DECORATE_STRING_SPEC_VERSION :: 1;
VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME :: "VK_GOOGLE_decorate_string";

VK_EXT_subgroup_size_control :: 1;
VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION :: 2;
VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME :: "VK_EXT_subgroup_size_control";

VK_AMD_shader_core_properties2 :: 1;
VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION :: 1;
VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME :: "VK_AMD_shader_core_properties2";

VK_AMD_device_coherent_memory :: 1;
VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION :: 1;
VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME :: "VK_AMD_device_coherent_memory";

VK_EXT_shader_image_atomic_int64 :: 1;
VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION :: 1;
VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME :: "VK_EXT_shader_image_atomic_int64";

VK_EXT_memory_budget :: 1;
VK_EXT_MEMORY_BUDGET_SPEC_VERSION :: 1;
VK_EXT_MEMORY_BUDGET_EXTENSION_NAME :: "VK_EXT_memory_budget";

VK_EXT_memory_priority :: 1;
VK_EXT_MEMORY_PRIORITY_SPEC_VERSION :: 1;
VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME :: "VK_EXT_memory_priority";

VK_NV_dedicated_allocation_image_aliasing :: 1;
VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION :: 1;
VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME :: "VK_NV_dedicated_allocation_image_aliasing";

VK_EXT_buffer_device_address :: 1;
VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION :: 2;
VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME :: "VK_EXT_buffer_device_address";

VK_EXT_tooling_info :: 1;
VK_EXT_TOOLING_INFO_SPEC_VERSION :: 1;
VK_EXT_TOOLING_INFO_EXTENSION_NAME :: "VK_EXT_tooling_info";

VK_EXT_separate_stencil_usage :: 1;
VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION :: 1;
VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME :: "VK_EXT_separate_stencil_usage";

VK_EXT_validation_features :: 1;
VK_EXT_VALIDATION_FEATURES_SPEC_VERSION :: 5;
VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME :: "VK_EXT_validation_features";

VK_NV_cooperative_matrix :: 1;
VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION :: 1;
VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME :: "VK_NV_cooperative_matrix";

VK_NV_coverage_reduction_mode :: 1;
VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION :: 1;
VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME :: "VK_NV_coverage_reduction_mode";

VK_EXT_fragment_shader_interlock :: 1;
VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION :: 1;
VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME :: "VK_EXT_fragment_shader_interlock";

VK_EXT_ycbcr_image_arrays :: 1;
VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION :: 1;
VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME :: "VK_EXT_ycbcr_image_arrays";

VK_EXT_provoking_vertex :: 1;
VK_EXT_PROVOKING_VERTEX_SPEC_VERSION :: 1;
VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME :: "VK_EXT_provoking_vertex";

VK_EXT_headless_surface :: 1;
VK_EXT_HEADLESS_SURFACE_SPEC_VERSION :: 1;
VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME :: "VK_EXT_headless_surface";

VK_EXT_line_rasterization :: 1;
VK_EXT_LINE_RASTERIZATION_SPEC_VERSION :: 1;
VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME :: "VK_EXT_line_rasterization";

VK_EXT_shader_atomic_float :: 1;
VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION :: 1;
VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME :: "VK_EXT_shader_atomic_float";

VK_EXT_host_query_reset :: 1;
VK_EXT_HOST_QUERY_RESET_SPEC_VERSION :: 1;
VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME :: "VK_EXT_host_query_reset";

VK_EXT_index_type_uint8 :: 1;
VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION :: 1;
VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME :: "VK_EXT_index_type_uint8";

VK_EXT_extended_dynamic_state :: 1;
VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION :: 1;
VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME :: "VK_EXT_extended_dynamic_state";

VK_EXT_host_image_copy :: 1;
VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION :: 1;
VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME :: "VK_EXT_host_image_copy";

VK_EXT_shader_atomic_float2 :: 1;
VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION :: 1;
VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME :: "VK_EXT_shader_atomic_float2";

VK_EXT_surface_maintenance1 :: 1;
VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION :: 1;
VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME :: "VK_EXT_surface_maintenance1";

VK_EXT_swapchain_maintenance1 :: 1;
VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION :: 1;
VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME :: "VK_EXT_swapchain_maintenance1";

VK_EXT_shader_demote_to_helper_invocation :: 1;
VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION :: 1;
VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME :: "VK_EXT_shader_demote_to_helper_invocation";

VK_NV_device_generated_commands :: 1;

VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION :: 3;
VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME :: "VK_NV_device_generated_commands";

VK_NV_inherited_viewport_scissor :: 1;
VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION :: 1;
VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME :: "VK_NV_inherited_viewport_scissor";

VK_EXT_texel_buffer_alignment :: 1;
VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION :: 1;
VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME :: "VK_EXT_texel_buffer_alignment";

VK_QCOM_render_pass_transform :: 1;
VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION :: 3;
VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME :: "VK_QCOM_render_pass_transform";

VK_EXT_depth_bias_control :: 1;
VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION :: 1;
VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME :: "VK_EXT_depth_bias_control";

VK_EXT_device_memory_report :: 1;
VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION :: 2;
VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME :: "VK_EXT_device_memory_report";

VK_EXT_acquire_drm_display :: 1;
VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION :: 1;
VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME :: "VK_EXT_acquire_drm_display";

VK_EXT_robustness2 :: 1;
VK_EXT_ROBUSTNESS_2_SPEC_VERSION :: 1;
VK_EXT_ROBUSTNESS_2_EXTENSION_NAME :: "VK_EXT_robustness2";

VK_EXT_custom_border_color :: 1;
VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION :: 12;
VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME :: "VK_EXT_custom_border_color";

VK_GOOGLE_user_type :: 1;
VK_GOOGLE_USER_TYPE_SPEC_VERSION :: 1;
VK_GOOGLE_USER_TYPE_EXTENSION_NAME :: "VK_GOOGLE_user_type";

VK_NV_present_barrier :: 1;
VK_NV_PRESENT_BARRIER_SPEC_VERSION :: 1;
VK_NV_PRESENT_BARRIER_EXTENSION_NAME :: "VK_NV_present_barrier";

VK_EXT_private_data :: 1;

VK_EXT_PRIVATE_DATA_SPEC_VERSION :: 1;
VK_EXT_PRIVATE_DATA_EXTENSION_NAME :: "VK_EXT_private_data";

VK_EXT_pipeline_creation_cache_control :: 1;
VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION :: 3;
VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME :: "VK_EXT_pipeline_creation_cache_control";

VK_NV_device_diagnostics_config :: 1;
VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION :: 2;
VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME :: "VK_NV_device_diagnostics_config";

VK_QCOM_render_pass_store_ops :: 1;
VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION :: 2;
VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME :: "VK_QCOM_render_pass_store_ops";

VK_NV_low_latency :: 1;
VK_NV_LOW_LATENCY_SPEC_VERSION :: 1;
VK_NV_LOW_LATENCY_EXTENSION_NAME :: "VK_NV_low_latency";

VK_EXT_descriptor_buffer :: 1;

VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION :: 1;
VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME :: "VK_EXT_descriptor_buffer";

VK_EXT_graphics_pipeline_library :: 1;
VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION :: 1;
VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME :: "VK_EXT_graphics_pipeline_library";

VK_AMD_shader_early_and_late_fragment_tests :: 1;
VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION :: 1;
VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME :: "VK_AMD_shader_early_and_late_fragment_tests";

VK_NV_fragment_shading_rate_enums :: 1;
VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION :: 1;
VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME :: "VK_NV_fragment_shading_rate_enums";

VK_NV_ray_tracing_motion_blur :: 1;
VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION :: 1;
VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME :: "VK_NV_ray_tracing_motion_blur";

VK_EXT_ycbcr_2plane_444_formats :: 1;
VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION :: 1;
VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME :: "VK_EXT_ycbcr_2plane_444_formats";

VK_EXT_fragment_density_map2 :: 1;
VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION :: 1;
VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME :: "VK_EXT_fragment_density_map2";

VK_QCOM_rotated_copy_commands :: 1;
VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION :: 1;
VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME :: "VK_QCOM_rotated_copy_commands";

VK_EXT_image_robustness :: 1;
VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION :: 1;
VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME :: "VK_EXT_image_robustness";

VK_EXT_image_compression_control :: 1;
VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION :: 1;
VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME :: "VK_EXT_image_compression_control";

VK_EXT_attachment_feedback_loop_layout :: 1;
VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION :: 2;
VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME :: "VK_EXT_attachment_feedback_loop_layout";

VK_EXT_4444_formats :: 1;
VK_EXT_4444_FORMATS_SPEC_VERSION :: 1;
VK_EXT_4444_FORMATS_EXTENSION_NAME :: "VK_EXT_4444_formats";

VK_EXT_device_fault :: 1;
VK_EXT_DEVICE_FAULT_SPEC_VERSION :: 2;
VK_EXT_DEVICE_FAULT_EXTENSION_NAME :: "VK_EXT_device_fault";

VK_ARM_rasterization_order_attachment_access :: 1;
VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION :: 1;
VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME :: "VK_ARM_rasterization_order_attachment_access";

VK_EXT_rgba10x6_formats :: 1;
VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION :: 1;
VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME :: "VK_EXT_rgba10x6_formats";

VK_VALVE_mutable_descriptor_type :: 1;
VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION :: 1;
VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME :: "VK_VALVE_mutable_descriptor_type";

VK_EXT_vertex_input_dynamic_state :: 1;
VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION :: 2;
VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME :: "VK_EXT_vertex_input_dynamic_state";

VK_EXT_physical_device_drm :: 1;
VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION :: 1;
VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME :: "VK_EXT_physical_device_drm";

VK_EXT_device_address_binding_report :: 1;
VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION :: 1;
VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME :: "VK_EXT_device_address_binding_report";

VK_EXT_depth_clip_control :: 1;
VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION :: 1;
VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME :: "VK_EXT_depth_clip_control";

VK_EXT_primitive_topology_list_restart :: 1;
VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION :: 1;
VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME :: "VK_EXT_primitive_topology_list_restart";

VK_HUAWEI_subpass_shading :: 1;
VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION :: 3;
VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME :: "VK_HUAWEI_subpass_shading";

VK_HUAWEI_invocation_mask :: 1;
VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION :: 1;
VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME :: "VK_HUAWEI_invocation_mask";

VK_NV_external_memory_rdma :: 1;

VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION :: 1;
VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME :: "VK_NV_external_memory_rdma";

VK_EXT_pipeline_properties :: 1;
VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION :: 1;
VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME :: "VK_EXT_pipeline_properties";

VK_EXT_frame_boundary :: 1;
VK_EXT_FRAME_BOUNDARY_SPEC_VERSION :: 1;
VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME :: "VK_EXT_frame_boundary";

VK_EXT_multisampled_render_to_single_sampled :: 1;
VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION :: 1;
VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME :: "VK_EXT_multisampled_render_to_single_sampled";

VK_EXT_extended_dynamic_state2 :: 1;
VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION :: 1;
VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME :: "VK_EXT_extended_dynamic_state2";

VK_EXT_color_write_enable :: 1;
VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION :: 1;
VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME :: "VK_EXT_color_write_enable";

VK_EXT_primitives_generated_query :: 1;
VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION :: 1;
VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME :: "VK_EXT_primitives_generated_query";

VK_EXT_global_priority_query :: 1;
VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION :: 1;
VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME :: "VK_EXT_global_priority_query";
VK_MAX_GLOBAL_PRIORITY_SIZE_EXT :: VK_MAX_GLOBAL_PRIORITY_SIZE_KHR;

VK_EXT_image_view_min_lod :: 1;
VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION :: 1;
VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME :: "VK_EXT_image_view_min_lod";

VK_EXT_multi_draw :: 1;
VK_EXT_MULTI_DRAW_SPEC_VERSION :: 1;
VK_EXT_MULTI_DRAW_EXTENSION_NAME :: "VK_EXT_multi_draw";

VK_EXT_image_2d_view_of_3d :: 1;
VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION :: 1;
VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME :: "VK_EXT_image_2d_view_of_3d";

VK_EXT_shader_tile_image :: 1;
VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION :: 1;
VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME :: "VK_EXT_shader_tile_image";

VK_EXT_opacity_micromap :: 1;

VK_EXT_OPACITY_MICROMAP_SPEC_VERSION :: 2;
VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME :: "VK_EXT_opacity_micromap";

VK_EXT_load_store_op_none :: 1;
VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION :: 1;
VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME :: "VK_EXT_load_store_op_none";

VK_HUAWEI_cluster_culling_shader :: 1;
VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION :: 2;
VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME :: "VK_HUAWEI_cluster_culling_shader";

VK_EXT_border_color_swizzle :: 1;
VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION :: 1;
VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME :: "VK_EXT_border_color_swizzle";

VK_EXT_pageable_device_local_memory :: 1;
VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION :: 1;
VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME :: "VK_EXT_pageable_device_local_memory";

VK_ARM_shader_core_properties :: 1;
VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION :: 1;
VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME :: "VK_ARM_shader_core_properties";

VK_EXT_image_sliced_view_of_3d :: 1;
VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION :: 1;
VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME :: "VK_EXT_image_sliced_view_of_3d";
VK_REMAINING_3D_SLICES_EXT :: ~0;

VK_VALVE_descriptor_set_host_mapping :: 1;
VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION :: 1;
VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME :: "VK_VALVE_descriptor_set_host_mapping";

VK_EXT_depth_clamp_zero_one :: 1;
VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION :: 1;
VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME :: "VK_EXT_depth_clamp_zero_one";

VK_EXT_non_seamless_cube_map :: 1;
VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION :: 1;
VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME :: "VK_EXT_non_seamless_cube_map";

VK_QCOM_fragment_density_map_offset :: 1;
VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION :: 1;
VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME :: "VK_QCOM_fragment_density_map_offset";

VK_NV_copy_memory_indirect :: 1;
VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION :: 1;
VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME :: "VK_NV_copy_memory_indirect";

VK_NV_memory_decompression :: 1;
VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION :: 1;
VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME :: "VK_NV_memory_decompression";

VK_NV_device_generated_commands_compute :: 1;
VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION :: 2;
VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME :: "VK_NV_device_generated_commands_compute";

VK_NV_linear_color_attachment :: 1;
VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION :: 1;
VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME :: "VK_NV_linear_color_attachment";

VK_GOOGLE_surfaceless_query :: 1;
VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION :: 2;
VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME :: "VK_GOOGLE_surfaceless_query";

VK_EXT_image_compression_control_swapchain :: 1;
VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION :: 1;
VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME :: "VK_EXT_image_compression_control_swapchain";

VK_QCOM_image_processing :: 1;
VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION :: 1;
VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME :: "VK_QCOM_image_processing";

VK_EXT_nested_command_buffer :: 1;
VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION :: 1;
VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME :: "VK_EXT_nested_command_buffer";

VK_EXT_external_memory_acquire_unmodified :: 1;
VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION :: 1;
VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME :: "VK_EXT_external_memory_acquire_unmodified";

VK_EXT_extended_dynamic_state3 :: 1;
VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION :: 2;
VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME :: "VK_EXT_extended_dynamic_state3";

VK_EXT_subpass_merge_feedback :: 1;
VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION :: 2;
VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME :: "VK_EXT_subpass_merge_feedback";

VK_LUNARG_direct_driver_loading :: 1;
VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION :: 1;
VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME :: "VK_LUNARG_direct_driver_loading";

VK_EXT_shader_module_identifier :: 1;
VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT :: 32;
VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION :: 1;
VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME :: "VK_EXT_shader_module_identifier";

VK_EXT_rasterization_order_attachment_access :: 1;
VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION :: 1;
VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME :: "VK_EXT_rasterization_order_attachment_access";

VK_NV_optical_flow :: 1;

VK_NV_OPTICAL_FLOW_SPEC_VERSION :: 1;
VK_NV_OPTICAL_FLOW_EXTENSION_NAME :: "VK_NV_optical_flow";

VK_EXT_legacy_dithering :: 1;
VK_EXT_LEGACY_DITHERING_SPEC_VERSION :: 1;
VK_EXT_LEGACY_DITHERING_EXTENSION_NAME :: "VK_EXT_legacy_dithering";

VK_EXT_pipeline_protected_access :: 1;
VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION :: 1;
VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME :: "VK_EXT_pipeline_protected_access";

VK_EXT_shader_object :: 1;

VK_EXT_SHADER_OBJECT_SPEC_VERSION :: 1;
VK_EXT_SHADER_OBJECT_EXTENSION_NAME :: "VK_EXT_shader_object";

VK_QCOM_tile_properties :: 1;
VK_QCOM_TILE_PROPERTIES_SPEC_VERSION :: 1;
VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME :: "VK_QCOM_tile_properties";

VK_SEC_amigo_profiling :: 1;
VK_SEC_AMIGO_PROFILING_SPEC_VERSION :: 1;
VK_SEC_AMIGO_PROFILING_EXTENSION_NAME :: "VK_SEC_amigo_profiling";

VK_QCOM_multiview_per_view_viewports :: 1;
VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION :: 1;
VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME :: "VK_QCOM_multiview_per_view_viewports";

VK_NV_ray_tracing_invocation_reorder :: 1;
VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION :: 1;
VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME :: "VK_NV_ray_tracing_invocation_reorder";

VK_NV_extended_sparse_address_space :: 1;
VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION :: 1;
VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME :: "VK_NV_extended_sparse_address_space";

VK_EXT_mutable_descriptor_type :: 1;
VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION :: 1;
VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME :: "VK_EXT_mutable_descriptor_type";

VK_ARM_shader_core_builtins :: 1;
VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION :: 2;
VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME :: "VK_ARM_shader_core_builtins";

VK_EXT_pipeline_library_group_handles :: 1;
VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION :: 1;
VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME :: "VK_EXT_pipeline_library_group_handles";

VK_EXT_dynamic_rendering_unused_attachments :: 1;
VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION :: 1;
VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME :: "VK_EXT_dynamic_rendering_unused_attachments";

VK_NV_low_latency2 :: 1;
VK_NV_LOW_LATENCY_2_SPEC_VERSION :: 1;
VK_NV_LOW_LATENCY_2_EXTENSION_NAME :: "VK_NV_low_latency2";

VK_QCOM_multiview_per_view_render_areas :: 1;
VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION :: 1;
VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME :: "VK_QCOM_multiview_per_view_render_areas";

VK_QCOM_image_processing2 :: 1;
VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION :: 1;
VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME :: "VK_QCOM_image_processing2";

VK_QCOM_filter_cubic_weights :: 1;
VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION :: 1;
VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME :: "VK_QCOM_filter_cubic_weights";

VK_QCOM_ycbcr_degamma :: 1;
VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION :: 1;
VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME :: "VK_QCOM_ycbcr_degamma";

VK_QCOM_filter_cubic_clamp :: 1;
VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION :: 1;
VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME :: "VK_QCOM_filter_cubic_clamp";

VK_EXT_attachment_feedback_loop_dynamic_state :: 1;
VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION :: 1;
VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME :: "VK_EXT_attachment_feedback_loop_dynamic_state";

VK_MSFT_layered_driver :: 1;
VK_MSFT_LAYERED_DRIVER_SPEC_VERSION :: 1;
VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME :: "VK_MSFT_layered_driver";

VK_NV_descriptor_pool_overallocation :: 1;
VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION :: 1;
VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME :: "VK_NV_descriptor_pool_overallocation";

VK_KHR_acceleration_structure :: 1;
VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION :: 13;
VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME :: "VK_KHR_acceleration_structure";

VK_KHR_ray_tracing_pipeline :: 1;
VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION :: 1;
VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME :: "VK_KHR_ray_tracing_pipeline";

VK_KHR_ray_query :: 1;
VK_KHR_RAY_QUERY_SPEC_VERSION :: 1;
VK_KHR_RAY_QUERY_EXTENSION_NAME :: "VK_KHR_ray_query";

VK_EXT_mesh_shader :: 1;
VK_EXT_MESH_SHADER_SPEC_VERSION :: 1;
VK_EXT_MESH_SHADER_EXTENSION_NAME :: "VK_EXT_mesh_shader";

VMA_VULKAN_VERSION :: 1003000;

VMA_DEDICATED_ALLOCATION :: 1;

VMA_BIND_MEMORY2 :: 1;

VMA_MEMORY_BUDGET :: 1;

VMA_BUFFER_DEVICE_ADDRESS :: 1;

VMA_MEMORY_PRIORITY :: 1;

VMA_EXTERNAL_MEMORY :: 1;

VMA_STATS_STRING_ENABLED :: 1;

VkBool32 :: u32;
VkDeviceAddress :: u64;
VkDeviceSize :: u64;
VkFlags :: u32;
VkSampleMask :: u32;
VkBuffer_T :: struct {}
VkBuffer :: *VkBuffer_T;
VkImage_T :: struct {}
VkImage :: *VkImage_T;
VkInstance_T :: struct {}
VkInstance :: *VkInstance_T;
VkPhysicalDevice_T :: struct {}
VkPhysicalDevice :: *VkPhysicalDevice_T;
VkDevice_T :: struct {}
VkDevice :: *VkDevice_T;
VkQueue_T :: struct {}
VkQueue :: *VkQueue_T;
VkSemaphore_T :: struct {}
VkSemaphore :: *VkSemaphore_T;
VkCommandBuffer_T :: struct {}
VkCommandBuffer :: *VkCommandBuffer_T;
VkFence_T :: struct {}
VkFence :: *VkFence_T;
VkDeviceMemory_T :: struct {}
VkDeviceMemory :: *VkDeviceMemory_T;
VkEvent_T :: struct {}
VkEvent :: *VkEvent_T;
VkQueryPool_T :: struct {}
VkQueryPool :: *VkQueryPool_T;
VkBufferView_T :: struct {}
VkBufferView :: *VkBufferView_T;
VkImageView_T :: struct {}
VkImageView :: *VkImageView_T;
VkShaderModule_T :: struct {}
VkShaderModule :: *VkShaderModule_T;
VkPipelineCache_T :: struct {}
VkPipelineCache :: *VkPipelineCache_T;
VkPipelineLayout_T :: struct {}
VkPipelineLayout :: *VkPipelineLayout_T;
VkPipeline_T :: struct {}
VkPipeline :: *VkPipeline_T;
VkRenderPass_T :: struct {}
VkRenderPass :: *VkRenderPass_T;
VkDescriptorSetLayout_T :: struct {}
VkDescriptorSetLayout :: *VkDescriptorSetLayout_T;
VkSampler_T :: struct {}
VkSampler :: *VkSampler_T;
VkDescriptorSet_T :: struct {}
VkDescriptorSet :: *VkDescriptorSet_T;
VkDescriptorPool_T :: struct {}
VkDescriptorPool :: *VkDescriptorPool_T;
VkFramebuffer_T :: struct {}
VkFramebuffer :: *VkFramebuffer_T;
VkCommandPool_T :: struct {}
VkCommandPool :: *VkCommandPool_T;

VkResult :: enum s32 {
    SUCCESS                                            :: 0;
    NOT_READY                                          :: 1;
    TIMEOUT                                            :: 2;
    EVENT_SET                                          :: 3;
    EVENT_RESET                                        :: 4;
    INCOMPLETE                                         :: 5;
    ERROR_OUT_OF_HOST_MEMORY                           :: -1;
    ERROR_OUT_OF_DEVICE_MEMORY                         :: -2;
    ERROR_INITIALIZATION_FAILED                        :: -3;
    ERROR_DEVICE_LOST                                  :: -4;
    ERROR_MEMORY_MAP_FAILED                            :: -5;
    ERROR_LAYER_NOT_PRESENT                            :: -6;
    ERROR_EXTENSION_NOT_PRESENT                        :: -7;
    ERROR_FEATURE_NOT_PRESENT                          :: -8;
    ERROR_INCOMPATIBLE_DRIVER                          :: -9;
    ERROR_TOO_MANY_OBJECTS                             :: -10;
    ERROR_FORMAT_NOT_SUPPORTED                         :: -11;
    ERROR_FRAGMENTED_POOL                              :: -12;
    ERROR_UNKNOWN                                      :: -13;
    ERROR_OUT_OF_POOL_MEMORY                           :: -1000069000;
    ERROR_INVALID_EXTERNAL_HANDLE                      :: -1000072003;
    ERROR_FRAGMENTATION                                :: -1000161000;
    ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS               :: -1000257000;
    PIPELINE_COMPILE_REQUIRED                          :: 1000297000;
    ERROR_SURFACE_LOST_KHR                             :: -1000000000;
    ERROR_NATIVE_WINDOW_IN_USE_KHR                     :: -1000000001;
    SUBOPTIMAL_KHR                                     :: 1000001003;
    ERROR_OUT_OF_DATE_KHR                              :: -1000001004;
    ERROR_INCOMPATIBLE_DISPLAY_KHR                     :: -1000003001;
    ERROR_VALIDATION_FAILED_EXT                        :: -1000011001;
    ERROR_INVALID_SHADER_NV                            :: -1000012000;
    ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR                :: -1000023000;
    ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR       :: -1000023001;
    ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR    :: -1000023002;
    ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR       :: -1000023003;
    ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR        :: -1000023004;
    ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR          :: -1000023005;
    ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT :: -1000158000;
    ERROR_NOT_PERMITTED_KHR                            :: -1000174001;
    ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT          :: -1000255000;
    THREAD_IDLE_KHR                                    :: 1000268000;
    THREAD_DONE_KHR                                    :: 1000268001;
    OPERATION_DEFERRED_KHR                             :: 1000268002;
    OPERATION_NOT_DEFERRED_KHR                         :: 1000268003;

    ERROR_COMPRESSION_EXHAUSTED_EXT                    :: -1000338000;
    ERROR_INCOMPATIBLE_SHADER_BINARY_EXT               :: 1000482000;
    ERROR_OUT_OF_POOL_MEMORY_KHR                       :: -1000069000;
    ERROR_INVALID_EXTERNAL_HANDLE_KHR                  :: -1000072003;
    ERROR_FRAGMENTATION_EXT                            :: -1000161000;
    ERROR_NOT_PERMITTED_EXT                            :: -1000174001;
    ERROR_INVALID_DEVICE_ADDRESS_EXT                   :: -1000257000;
    ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR           :: -1000257000;
    PIPELINE_COMPILE_REQUIRED_EXT                      :: 1000297000;
    ERROR_PIPELINE_COMPILE_REQUIRED_EXT                :: 1000297000;
    RESULT_MAX_ENUM                                    :: 2147483647;
}

VkStructureType :: enum s32 {
    APPLICATION_INFO                                                    :: 0;
    INSTANCE_CREATE_INFO                                                :: 1;
    DEVICE_QUEUE_CREATE_INFO                                            :: 2;
    DEVICE_CREATE_INFO                                                  :: 3;
    SUBMIT_INFO                                                         :: 4;
    MEMORY_ALLOCATE_INFO                                                :: 5;
    MAPPED_MEMORY_RANGE                                                 :: 6;
    BIND_SPARSE_INFO                                                    :: 7;
    FENCE_CREATE_INFO                                                   :: 8;
    SEMAPHORE_CREATE_INFO                                               :: 9;
    EVENT_CREATE_INFO                                                   :: 10;
    QUERY_POOL_CREATE_INFO                                              :: 11;
    BUFFER_CREATE_INFO                                                  :: 12;
    BUFFER_VIEW_CREATE_INFO                                             :: 13;
    IMAGE_CREATE_INFO                                                   :: 14;
    IMAGE_VIEW_CREATE_INFO                                              :: 15;
    SHADER_MODULE_CREATE_INFO                                           :: 16;
    PIPELINE_CACHE_CREATE_INFO                                          :: 17;
    PIPELINE_SHADER_STAGE_CREATE_INFO                                   :: 18;
    PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO                             :: 19;
    PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO                           :: 20;
    PIPELINE_TESSELLATION_STATE_CREATE_INFO                             :: 21;
    PIPELINE_VIEWPORT_STATE_CREATE_INFO                                 :: 22;
    PIPELINE_RASTERIZATION_STATE_CREATE_INFO                            :: 23;
    PIPELINE_MULTISAMPLE_STATE_CREATE_INFO                              :: 24;
    PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO                            :: 25;
    PIPELINE_COLOR_BLEND_STATE_CREATE_INFO                              :: 26;
    PIPELINE_DYNAMIC_STATE_CREATE_INFO                                  :: 27;
    GRAPHICS_PIPELINE_CREATE_INFO                                       :: 28;
    COMPUTE_PIPELINE_CREATE_INFO                                        :: 29;
    PIPELINE_LAYOUT_CREATE_INFO                                         :: 30;
    SAMPLER_CREATE_INFO                                                 :: 31;
    DESCRIPTOR_SET_LAYOUT_CREATE_INFO                                   :: 32;
    DESCRIPTOR_POOL_CREATE_INFO                                         :: 33;
    DESCRIPTOR_SET_ALLOCATE_INFO                                        :: 34;
    WRITE_DESCRIPTOR_SET                                                :: 35;
    COPY_DESCRIPTOR_SET                                                 :: 36;
    FRAMEBUFFER_CREATE_INFO                                             :: 37;
    RENDER_PASS_CREATE_INFO                                             :: 38;
    COMMAND_POOL_CREATE_INFO                                            :: 39;
    COMMAND_BUFFER_ALLOCATE_INFO                                        :: 40;
    COMMAND_BUFFER_INHERITANCE_INFO                                     :: 41;
    COMMAND_BUFFER_BEGIN_INFO                                           :: 42;
    RENDER_PASS_BEGIN_INFO                                              :: 43;
    BUFFER_MEMORY_BARRIER                                               :: 44;
    IMAGE_MEMORY_BARRIER                                                :: 45;
    MEMORY_BARRIER                                                      :: 46;
    LOADER_INSTANCE_CREATE_INFO                                         :: 47;
    LOADER_DEVICE_CREATE_INFO                                           :: 48;
    PHYSICAL_DEVICE_SUBGROUP_PROPERTIES                                 :: 1000094000;
    BIND_BUFFER_MEMORY_INFO                                             :: 1000157000;
    BIND_IMAGE_MEMORY_INFO                                              :: 1000157001;
    PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES                              :: 1000083000;
    MEMORY_DEDICATED_REQUIREMENTS                                       :: 1000127000;
    MEMORY_DEDICATED_ALLOCATE_INFO                                      :: 1000127001;
    MEMORY_ALLOCATE_FLAGS_INFO                                          :: 1000060000;
    DEVICE_GROUP_RENDER_PASS_BEGIN_INFO                                 :: 1000060003;
    DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO                              :: 1000060004;
    DEVICE_GROUP_SUBMIT_INFO                                            :: 1000060005;
    DEVICE_GROUP_BIND_SPARSE_INFO                                       :: 1000060006;
    BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO                                :: 1000060013;
    BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO                                 :: 1000060014;
    PHYSICAL_DEVICE_GROUP_PROPERTIES                                    :: 1000070000;
    DEVICE_GROUP_DEVICE_CREATE_INFO                                     :: 1000070001;
    BUFFER_MEMORY_REQUIREMENTS_INFO_2                                   :: 1000146000;
    IMAGE_MEMORY_REQUIREMENTS_INFO_2                                    :: 1000146001;
    IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2                             :: 1000146002;
    MEMORY_REQUIREMENTS_2                                               :: 1000146003;
    SPARSE_IMAGE_MEMORY_REQUIREMENTS_2                                  :: 1000146004;
    PHYSICAL_DEVICE_FEATURES_2                                          :: 1000059000;
    PHYSICAL_DEVICE_PROPERTIES_2                                        :: 1000059001;
    FORMAT_PROPERTIES_2                                                 :: 1000059002;
    IMAGE_FORMAT_PROPERTIES_2                                           :: 1000059003;
    PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2                                 :: 1000059004;
    QUEUE_FAMILY_PROPERTIES_2                                           :: 1000059005;
    PHYSICAL_DEVICE_MEMORY_PROPERTIES_2                                 :: 1000059006;
    SPARSE_IMAGE_FORMAT_PROPERTIES_2                                    :: 1000059007;
    PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2                          :: 1000059008;
    PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES                           :: 1000117000;
    RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO                     :: 1000117001;
    IMAGE_VIEW_USAGE_CREATE_INFO                                        :: 1000117002;
    PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO               :: 1000117003;
    RENDER_PASS_MULTIVIEW_CREATE_INFO                                   :: 1000053000;
    PHYSICAL_DEVICE_MULTIVIEW_FEATURES                                  :: 1000053001;
    PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES                                :: 1000053002;
    PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES                          :: 1000120000;
    PROTECTED_SUBMIT_INFO                                               :: 1000145000;
    PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES                           :: 1000145001;
    PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES                         :: 1000145002;
    DEVICE_QUEUE_INFO_2                                                 :: 1000145003;
    SAMPLER_YCBCR_CONVERSION_CREATE_INFO                                :: 1000156000;
    SAMPLER_YCBCR_CONVERSION_INFO                                       :: 1000156001;
    BIND_IMAGE_PLANE_MEMORY_INFO                                        :: 1000156002;
    IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO                                :: 1000156003;
    PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES                   :: 1000156004;
    SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES                    :: 1000156005;
    DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO                              :: 1000085000;
    PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO                          :: 1000071000;
    EXTERNAL_IMAGE_FORMAT_PROPERTIES                                    :: 1000071001;
    PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO                                :: 1000071002;
    EXTERNAL_BUFFER_PROPERTIES                                          :: 1000071003;
    PHYSICAL_DEVICE_ID_PROPERTIES                                       :: 1000071004;
    EXTERNAL_MEMORY_BUFFER_CREATE_INFO                                  :: 1000072000;
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO                                   :: 1000072001;
    EXPORT_MEMORY_ALLOCATE_INFO                                         :: 1000072002;
    PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO                                 :: 1000112000;
    EXTERNAL_FENCE_PROPERTIES                                           :: 1000112001;
    EXPORT_FENCE_CREATE_INFO                                            :: 1000113000;
    EXPORT_SEMAPHORE_CREATE_INFO                                        :: 1000077000;
    PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO                             :: 1000076000;
    EXTERNAL_SEMAPHORE_PROPERTIES                                       :: 1000076001;
    PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES                            :: 1000168000;
    DESCRIPTOR_SET_LAYOUT_SUPPORT                                       :: 1000168001;
    PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES                     :: 1000063000;
    PHYSICAL_DEVICE_VULKAN_1_1_FEATURES                                 :: 49;
    PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES                               :: 50;
    PHYSICAL_DEVICE_VULKAN_1_2_FEATURES                                 :: 51;
    PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES                               :: 52;
    IMAGE_FORMAT_LIST_CREATE_INFO                                       :: 1000147000;
    ATTACHMENT_DESCRIPTION_2                                            :: 1000109000;
    ATTACHMENT_REFERENCE_2                                              :: 1000109001;
    SUBPASS_DESCRIPTION_2                                               :: 1000109002;
    SUBPASS_DEPENDENCY_2                                                :: 1000109003;
    RENDER_PASS_CREATE_INFO_2                                           :: 1000109004;
    SUBPASS_BEGIN_INFO                                                  :: 1000109005;
    SUBPASS_END_INFO                                                    :: 1000109006;
    PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES                               :: 1000177000;
    PHYSICAL_DEVICE_DRIVER_PROPERTIES                                   :: 1000196000;
    PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES                        :: 1000180000;
    PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES                        :: 1000082000;
    PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES                           :: 1000197000;
    DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO                     :: 1000161000;
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES                        :: 1000161001;
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES                      :: 1000161002;
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO              :: 1000161003;
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT             :: 1000161004;
    PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES                    :: 1000199000;
    SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE                           :: 1000199001;
    PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES                        :: 1000221000;
    IMAGE_STENCIL_USAGE_CREATE_INFO                                     :: 1000246000;
    PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES                    :: 1000130000;
    SAMPLER_REDUCTION_MODE_CREATE_INFO                                  :: 1000130001;
    PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES                        :: 1000211000;
    PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES                      :: 1000108000;
    FRAMEBUFFER_ATTACHMENTS_CREATE_INFO                                 :: 1000108001;
    FRAMEBUFFER_ATTACHMENT_IMAGE_INFO                                   :: 1000108002;
    RENDER_PASS_ATTACHMENT_BEGIN_INFO                                   :: 1000108003;
    PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES             :: 1000253000;
    PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES             :: 1000175000;
    PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES             :: 1000241000;
    ATTACHMENT_REFERENCE_STENCIL_LAYOUT                                 :: 1000241001;
    ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT                               :: 1000241002;
    PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES                           :: 1000261000;
    PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES                         :: 1000207000;
    PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES                       :: 1000207001;
    SEMAPHORE_TYPE_CREATE_INFO                                          :: 1000207002;
    TIMELINE_SEMAPHORE_SUBMIT_INFO                                      :: 1000207003;
    SEMAPHORE_WAIT_INFO                                                 :: 1000207004;
    SEMAPHORE_SIGNAL_INFO                                               :: 1000207005;
    PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES                      :: 1000257000;
    BUFFER_DEVICE_ADDRESS_INFO                                          :: 1000244001;
    BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO                           :: 1000257002;
    MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO                         :: 1000257003;
    DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO                           :: 1000257004;
    PHYSICAL_DEVICE_VULKAN_1_3_FEATURES                                 :: 53;
    PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES                               :: 54;
    PIPELINE_CREATION_FEEDBACK_CREATE_INFO                              :: 1000192000;
    PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES                :: 1000215000;
    PHYSICAL_DEVICE_TOOL_PROPERTIES                                     :: 1000245000;
    PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES         :: 1000276000;
    PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES                               :: 1000295000;
    DEVICE_PRIVATE_DATA_CREATE_INFO                                     :: 1000295001;
    PRIVATE_DATA_SLOT_CREATE_INFO                                       :: 1000295002;
    PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES            :: 1000297000;
    MEMORY_BARRIER_2                                                    :: 1000314000;
    BUFFER_MEMORY_BARRIER_2                                             :: 1000314001;
    IMAGE_MEMORY_BARRIER_2                                              :: 1000314002;
    DEPENDENCY_INFO                                                     :: 1000314003;
    SUBMIT_INFO_2                                                       :: 1000314004;
    SEMAPHORE_SUBMIT_INFO                                               :: 1000314005;
    COMMAND_BUFFER_SUBMIT_INFO                                          :: 1000314006;
    PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES                          :: 1000314007;
    PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES           :: 1000325000;
    PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES                           :: 1000335000;
    COPY_BUFFER_INFO_2                                                  :: 1000337000;
    COPY_IMAGE_INFO_2                                                   :: 1000337001;
    COPY_BUFFER_TO_IMAGE_INFO_2                                         :: 1000337002;
    COPY_IMAGE_TO_BUFFER_INFO_2                                         :: 1000337003;
    BLIT_IMAGE_INFO_2                                                   :: 1000337004;
    RESOLVE_IMAGE_INFO_2                                                :: 1000337005;
    BUFFER_COPY_2                                                       :: 1000337006;
    IMAGE_COPY_2                                                        :: 1000337007;
    IMAGE_BLIT_2                                                        :: 1000337008;
    BUFFER_IMAGE_COPY_2                                                 :: 1000337009;
    IMAGE_RESOLVE_2                                                     :: 1000337010;
    PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES                    :: 1000225000;
    PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO            :: 1000225001;
    PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES                      :: 1000225002;
    PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES                       :: 1000138000;
    PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES                     :: 1000138001;
    WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK                           :: 1000138002;
    DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO                    :: 1000138003;
    PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES               :: 1000066000;
    RENDERING_INFO                                                      :: 1000044000;
    RENDERING_ATTACHMENT_INFO                                           :: 1000044001;
    PIPELINE_RENDERING_CREATE_INFO                                      :: 1000044002;
    PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES                          :: 1000044003;
    COMMAND_BUFFER_INHERITANCE_RENDERING_INFO                           :: 1000044004;
    PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES                 :: 1000280000;
    PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES               :: 1000280001;
    PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES                   :: 1000281001;
    FORMAT_PROPERTIES_3                                                 :: 1000360000;
    PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES                              :: 1000413000;
    PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES                            :: 1000413001;
    DEVICE_BUFFER_MEMORY_REQUIREMENTS                                   :: 1000413002;
    DEVICE_IMAGE_MEMORY_REQUIREMENTS                                    :: 1000413003;
    SWAPCHAIN_CREATE_INFO_KHR                                           :: 1000001000;
    PRESENT_INFO_KHR                                                    :: 1000001001;
    DEVICE_GROUP_PRESENT_CAPABILITIES_KHR                               :: 1000060007;
    IMAGE_SWAPCHAIN_CREATE_INFO_KHR                                     :: 1000060008;
    BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR                                :: 1000060009;
    ACQUIRE_NEXT_IMAGE_INFO_KHR                                         :: 1000060010;
    DEVICE_GROUP_PRESENT_INFO_KHR                                       :: 1000060011;
    DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR                              :: 1000060012;
    DISPLAY_MODE_CREATE_INFO_KHR                                        :: 1000002000;
    DISPLAY_SURFACE_CREATE_INFO_KHR                                     :: 1000002001;
    DISPLAY_PRESENT_INFO_KHR                                            :: 1000003000;
    XLIB_SURFACE_CREATE_INFO_KHR                                        :: 1000004000;
    XCB_SURFACE_CREATE_INFO_KHR                                         :: 1000005000;
    WAYLAND_SURFACE_CREATE_INFO_KHR                                     :: 1000006000;
    ANDROID_SURFACE_CREATE_INFO_KHR                                     :: 1000008000;
    WIN32_SURFACE_CREATE_INFO_KHR                                       :: 1000009000;
    DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT                               :: 1000011000;
    PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD                :: 1000018000;
    DEBUG_MARKER_OBJECT_NAME_INFO_EXT                                   :: 1000022000;
    DEBUG_MARKER_OBJECT_TAG_INFO_EXT                                    :: 1000022001;
    DEBUG_MARKER_MARKER_INFO_EXT                                        :: 1000022002;
    VIDEO_PROFILE_INFO_KHR                                              :: 1000023000;
    VIDEO_CAPABILITIES_KHR                                              :: 1000023001;
    VIDEO_PICTURE_RESOURCE_INFO_KHR                                     :: 1000023002;
    VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR                               :: 1000023003;
    BIND_VIDEO_SESSION_MEMORY_INFO_KHR                                  :: 1000023004;
    VIDEO_SESSION_CREATE_INFO_KHR                                       :: 1000023005;
    VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR                            :: 1000023006;
    VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR                            :: 1000023007;
    VIDEO_BEGIN_CODING_INFO_KHR                                         :: 1000023008;
    VIDEO_END_CODING_INFO_KHR                                           :: 1000023009;
    VIDEO_CODING_CONTROL_INFO_KHR                                       :: 1000023010;
    VIDEO_REFERENCE_SLOT_INFO_KHR                                       :: 1000023011;
    QUEUE_FAMILY_VIDEO_PROPERTIES_KHR                                   :: 1000023012;
    VIDEO_PROFILE_LIST_INFO_KHR                                         :: 1000023013;
    PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR                               :: 1000023014;
    VIDEO_FORMAT_PROPERTIES_KHR                                         :: 1000023015;
    QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR                     :: 1000023016;
    VIDEO_DECODE_INFO_KHR                                               :: 1000024000;
    VIDEO_DECODE_CAPABILITIES_KHR                                       :: 1000024001;
    VIDEO_DECODE_USAGE_INFO_KHR                                         :: 1000024002;
    DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV                           :: 1000026000;
    DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV                          :: 1000026001;
    DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV                        :: 1000026002;
    PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT                     :: 1000028000;
    PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT                   :: 1000028001;
    PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT                 :: 1000028002;
    CU_MODULE_CREATE_INFO_NVX                                           :: 1000029000;
    CU_FUNCTION_CREATE_INFO_NVX                                         :: 1000029001;
    CU_LAUNCH_INFO_NVX                                                  :: 1000029002;
    IMAGE_VIEW_HANDLE_INFO_NVX                                          :: 1000030000;
    IMAGE_VIEW_ADDRESS_PROPERTIES_NVX                                   :: 1000030001;

    VIDEO_DECODE_H264_CAPABILITIES_KHR                                  :: 1000040000;
    VIDEO_DECODE_H264_PICTURE_INFO_KHR                                  :: 1000040001;
    VIDEO_DECODE_H264_PROFILE_INFO_KHR                                  :: 1000040003;
    VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR                :: 1000040004;
    VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR                   :: 1000040005;
    VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR                                 :: 1000040006;
    TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD                            :: 1000041000;
    RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR                 :: 1000044006;
    RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT                  :: 1000044007;
    ATTACHMENT_SAMPLE_COUNT_INFO_AMD                                    :: 1000044008;
    MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX                              :: 1000044009;
    STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP                           :: 1000049000;
    PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV                    :: 1000050000;
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV                                :: 1000056000;
    EXPORT_MEMORY_ALLOCATE_INFO_NV                                      :: 1000056001;
    IMPORT_MEMORY_WIN32_HANDLE_INFO_NV                                  :: 1000057000;
    EXPORT_MEMORY_WIN32_HANDLE_INFO_NV                                  :: 1000057001;
    WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV                           :: 1000058000;
    VALIDATION_FLAGS_EXT                                                :: 1000061000;
    VI_SURFACE_CREATE_INFO_NN                                           :: 1000062000;
    IMAGE_VIEW_ASTC_DECODE_MODE_EXT                                     :: 1000067000;
    PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT                            :: 1000067001;
    PIPELINE_ROBUSTNESS_CREATE_INFO_EXT                                 :: 1000068000;
    PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT                    :: 1000068001;
    PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT                  :: 1000068002;
    IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR                                 :: 1000073000;
    EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR                                 :: 1000073001;
    MEMORY_WIN32_HANDLE_PROPERTIES_KHR                                  :: 1000073002;
    MEMORY_GET_WIN32_HANDLE_INFO_KHR                                    :: 1000073003;
    IMPORT_MEMORY_FD_INFO_KHR                                           :: 1000074000;
    MEMORY_FD_PROPERTIES_KHR                                            :: 1000074001;
    MEMORY_GET_FD_INFO_KHR                                              :: 1000074002;
    WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR                          :: 1000075000;
    IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR                              :: 1000078000;
    EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR                              :: 1000078001;
    D3D12_FENCE_SUBMIT_INFO_KHR                                         :: 1000078002;
    SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR                                 :: 1000078003;
    IMPORT_SEMAPHORE_FD_INFO_KHR                                        :: 1000079000;
    SEMAPHORE_GET_FD_INFO_KHR                                           :: 1000079001;
    PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR                      :: 1000080000;
    COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT           :: 1000081000;
    PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT                  :: 1000081001;
    CONDITIONAL_RENDERING_BEGIN_INFO_EXT                                :: 1000081002;
    PRESENT_REGIONS_KHR                                                 :: 1000084000;
    PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV                    :: 1000087000;
    SURFACE_CAPABILITIES_2_EXT                                          :: 1000090000;
    DISPLAY_POWER_INFO_EXT                                              :: 1000091000;
    DEVICE_EVENT_INFO_EXT                                               :: 1000091001;
    DISPLAY_EVENT_INFO_EXT                                              :: 1000091002;
    SWAPCHAIN_COUNTER_CREATE_INFO_EXT                                   :: 1000091003;
    PRESENT_TIMES_INFO_GOOGLE                                           :: 1000092000;
    PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX        :: 1000097000;
    PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV                      :: 1000098000;
    PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT                    :: 1000099000;
    PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT                    :: 1000099001;
    PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT           :: 1000101000;
    PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT           :: 1000101001;
    PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT                      :: 1000102000;
    PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT             :: 1000102001;
    HDR_METADATA_EXT                                                    :: 1000105000;
    SHARED_PRESENT_SURFACE_CAPABILITIES_KHR                             :: 1000111000;
    IMPORT_FENCE_WIN32_HANDLE_INFO_KHR                                  :: 1000114000;
    EXPORT_FENCE_WIN32_HANDLE_INFO_KHR                                  :: 1000114001;
    FENCE_GET_WIN32_HANDLE_INFO_KHR                                     :: 1000114002;
    IMPORT_FENCE_FD_INFO_KHR                                            :: 1000115000;
    FENCE_GET_FD_INFO_KHR                                               :: 1000115001;
    PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR                      :: 1000116000;
    PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR                    :: 1000116001;
    QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR                              :: 1000116002;
    PERFORMANCE_QUERY_SUBMIT_INFO_KHR                                   :: 1000116003;
    ACQUIRE_PROFILING_LOCK_INFO_KHR                                     :: 1000116004;
    PERFORMANCE_COUNTER_KHR                                             :: 1000116005;
    PERFORMANCE_COUNTER_DESCRIPTION_KHR                                 :: 1000116006;
    PHYSICAL_DEVICE_SURFACE_INFO_2_KHR                                  :: 1000119000;
    SURFACE_CAPABILITIES_2_KHR                                          :: 1000119001;
    SURFACE_FORMAT_2_KHR                                                :: 1000119002;
    DISPLAY_PROPERTIES_2_KHR                                            :: 1000121000;
    DISPLAY_PLANE_PROPERTIES_2_KHR                                      :: 1000121001;
    DISPLAY_MODE_PROPERTIES_2_KHR                                       :: 1000121002;
    DISPLAY_PLANE_INFO_2_KHR                                            :: 1000121003;
    DISPLAY_PLANE_CAPABILITIES_2_KHR                                    :: 1000121004;
    IOS_SURFACE_CREATE_INFO_MVK                                         :: 1000122000;
    MACOS_SURFACE_CREATE_INFO_MVK                                       :: 1000123000;
    DEBUG_UTILS_OBJECT_NAME_INFO_EXT                                    :: 1000128000;
    DEBUG_UTILS_OBJECT_TAG_INFO_EXT                                     :: 1000128001;
    DEBUG_UTILS_LABEL_EXT                                               :: 1000128002;
    DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT                             :: 1000128003;
    DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT                               :: 1000128004;
    ANDROID_HARDWARE_BUFFER_USAGE_ANDROID                               :: 1000129000;
    ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID                          :: 1000129001;
    ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID                   :: 1000129002;
    IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID                         :: 1000129003;
    MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID                     :: 1000129004;
    EXTERNAL_FORMAT_ANDROID                                             :: 1000129005;
    ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID                 :: 1000129006;

    SAMPLE_LOCATIONS_INFO_EXT                                           :: 1000143000;
    RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT                         :: 1000143001;
    PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT                     :: 1000143002;
    PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT                     :: 1000143003;
    MULTISAMPLE_PROPERTIES_EXT                                          :: 1000143004;
    PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT               :: 1000148000;
    PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT             :: 1000148001;
    PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT                 :: 1000148002;
    PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV                     :: 1000149000;
    WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR                     :: 1000150007;
    ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR                      :: 1000150000;
    ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR                      :: 1000150002;
    ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR                      :: 1000150003;
    ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR                  :: 1000150004;
    ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR                  :: 1000150005;
    ACCELERATION_STRUCTURE_GEOMETRY_KHR                                 :: 1000150006;
    ACCELERATION_STRUCTURE_VERSION_INFO_KHR                             :: 1000150009;
    COPY_ACCELERATION_STRUCTURE_INFO_KHR                                :: 1000150010;
    COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR                      :: 1000150011;
    COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR                      :: 1000150012;
    PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR                 :: 1000150013;
    PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR               :: 1000150014;
    ACCELERATION_STRUCTURE_CREATE_INFO_KHR                              :: 1000150017;
    ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR                         :: 1000150020;
    PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR                   :: 1000347000;
    PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR                 :: 1000347001;
    RAY_TRACING_PIPELINE_CREATE_INFO_KHR                                :: 1000150015;
    RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR                            :: 1000150016;
    RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR                      :: 1000150018;
    PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR                              :: 1000348013;
    PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV                   :: 1000152000;
    PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV                      :: 1000154000;
    PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV                    :: 1000154001;
    DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT                             :: 1000158000;
    PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT                  :: 1000158002;
    IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT                      :: 1000158003;
    IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT                  :: 1000158004;
    IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT                            :: 1000158005;
    DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT                           :: 1000158006;
    VALIDATION_CACHE_CREATE_INFO_EXT                                    :: 1000160000;
    SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT                      :: 1000160001;

    PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV           :: 1000164000;
    PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV                      :: 1000164001;
    PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV                    :: 1000164002;
    PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV          :: 1000164005;
    RAY_TRACING_PIPELINE_CREATE_INFO_NV                                 :: 1000165000;
    ACCELERATION_STRUCTURE_CREATE_INFO_NV                               :: 1000165001;
    GEOMETRY_NV                                                         :: 1000165003;
    GEOMETRY_TRIANGLES_NV                                               :: 1000165004;
    GEOMETRY_AABB_NV                                                    :: 1000165005;
    BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV                          :: 1000165006;
    WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV                      :: 1000165007;
    ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV                  :: 1000165008;
    PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV                           :: 1000165009;
    RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV                             :: 1000165011;
    ACCELERATION_STRUCTURE_INFO_NV                                      :: 1000165012;
    PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV            :: 1000166000;
    PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV          :: 1000166001;
    PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT                    :: 1000170000;
    FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT                 :: 1000170001;
    IMPORT_MEMORY_HOST_POINTER_INFO_EXT                                 :: 1000178000;
    MEMORY_HOST_POINTER_PROPERTIES_EXT                                  :: 1000178001;
    PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT                 :: 1000178002;
    PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR                           :: 1000181000;
    PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD                           :: 1000183000;
    CALIBRATED_TIMESTAMP_INFO_EXT                                       :: 1000184000;
    PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD                          :: 1000185000;
    VIDEO_DECODE_H265_CAPABILITIES_KHR                                  :: 1000187000;
    VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR                :: 1000187001;
    VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR                   :: 1000187002;
    VIDEO_DECODE_H265_PROFILE_INFO_KHR                                  :: 1000187003;
    VIDEO_DECODE_H265_PICTURE_INFO_KHR                                  :: 1000187004;
    VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR                                 :: 1000187005;
    DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR                        :: 1000174000;
    PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR                  :: 1000388000;
    QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR                         :: 1000388001;
    DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD                        :: 1000189000;
    PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT             :: 1000190000;
    PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT                 :: 1000190001;
    PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT               :: 1000190002;
    PRESENT_FRAME_TOKEN_GGP                                             :: 1000191000;
    PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV              :: 1000201000;
    PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV                             :: 1000202000;
    PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV                           :: 1000202001;
    PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV                  :: 1000204000;
    PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV            :: 1000205000;
    PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV                       :: 1000205002;
    CHECKPOINT_DATA_NV                                                  :: 1000206000;
    QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV                               :: 1000206001;
    PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL           :: 1000209000;
    QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL                      :: 1000210000;
    INITIALIZE_PERFORMANCE_API_INFO_INTEL                               :: 1000210001;
    PERFORMANCE_MARKER_INFO_INTEL                                       :: 1000210002;
    PERFORMANCE_STREAM_MARKER_INFO_INTEL                                :: 1000210003;
    PERFORMANCE_OVERRIDE_INFO_INTEL                                     :: 1000210004;
    PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL                        :: 1000210005;
    PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT                         :: 1000212000;
    DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD                         :: 1000213000;
    SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD                        :: 1000213001;
    IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA                               :: 1000214000;
    METAL_SURFACE_CREATE_INFO_EXT                                       :: 1000217000;
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT                   :: 1000218000;
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT                 :: 1000218001;
    RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT                    :: 1000218002;
    FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR                           :: 1000226000;
    PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR                :: 1000226001;
    PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR                :: 1000226002;
    PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR                  :: 1000226003;
    PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR                           :: 1000226004;
    PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD                        :: 1000227000;
    PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD                        :: 1000229000;
    PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT              :: 1000234000;
    PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT                        :: 1000237000;
    PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT                        :: 1000238000;
    MEMORY_PRIORITY_ALLOCATE_INFO_EXT                                   :: 1000238001;
    SURFACE_PROTECTED_CAPABILITIES_KHR                                  :: 1000239000;
    PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV     :: 1000240000;
    PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT                  :: 1000244000;
    BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT                               :: 1000244002;
    VALIDATION_FEATURES_EXT                                             :: 1000247000;
    PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR                           :: 1000248000;
    PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV                      :: 1000249000;
    COOPERATIVE_MATRIX_PROPERTIES_NV                                    :: 1000249001;
    PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV                    :: 1000249002;
    PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV                 :: 1000250000;
    PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV                    :: 1000250001;
    FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV                            :: 1000250002;
    PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT              :: 1000251000;
    PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT                     :: 1000252000;
    PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT                       :: 1000254000;
    PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT       :: 1000254001;
    PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT                     :: 1000254002;
    SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT                              :: 1000255000;
    SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT                      :: 1000255002;
    SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT                        :: 1000255001;
    HEADLESS_SURFACE_CREATE_INFO_EXT                                    :: 1000256000;
    PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT                     :: 1000259000;
    PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT                   :: 1000259001;
    PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT                   :: 1000259002;
    PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT                    :: 1000260000;
    PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT                       :: 1000265000;
    PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT                 :: 1000267000;
    PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR         :: 1000269000;
    PIPELINE_INFO_KHR                                                   :: 1000269001;
    PIPELINE_EXECUTABLE_PROPERTIES_KHR                                  :: 1000269002;
    PIPELINE_EXECUTABLE_INFO_KHR                                        :: 1000269003;
    PIPELINE_EXECUTABLE_STATISTIC_KHR                                   :: 1000269004;
    PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR                     :: 1000269005;
    PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT                        :: 1000270000;
    PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT                      :: 1000270001;
    MEMORY_TO_IMAGE_COPY_EXT                                            :: 1000270002;
    IMAGE_TO_MEMORY_COPY_EXT                                            :: 1000270003;
    COPY_IMAGE_TO_MEMORY_INFO_EXT                                       :: 1000270004;
    COPY_MEMORY_TO_IMAGE_INFO_EXT                                       :: 1000270005;
    HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT                               :: 1000270006;
    COPY_IMAGE_TO_IMAGE_INFO_EXT                                        :: 1000270007;
    SUBRESOURCE_HOST_MEMCPY_SIZE_EXT                                    :: 1000270008;
    HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT                        :: 1000270009;
    MEMORY_MAP_INFO_KHR                                                 :: 1000271000;
    MEMORY_UNMAP_INFO_KHR                                               :: 1000271001;
    PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT                  :: 1000273000;
    SURFACE_PRESENT_MODE_EXT                                            :: 1000274000;
    SURFACE_PRESENT_SCALING_CAPABILITIES_EXT                            :: 1000274001;
    SURFACE_PRESENT_MODE_COMPATIBILITY_EXT                              :: 1000274002;
    PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT                :: 1000275000;
    SWAPCHAIN_PRESENT_FENCE_INFO_EXT                                    :: 1000275001;
    SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT                             :: 1000275002;
    SWAPCHAIN_PRESENT_MODE_INFO_EXT                                     :: 1000275003;
    SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT                           :: 1000275004;
    RELEASE_SWAPCHAIN_IMAGES_INFO_EXT                                   :: 1000275005;
    PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV             :: 1000277000;
    GRAPHICS_SHADER_GROUP_CREATE_INFO_NV                                :: 1000277001;
    GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV                      :: 1000277002;
    INDIRECT_COMMANDS_LAYOUT_TOKEN_NV                                   :: 1000277003;
    INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV                             :: 1000277004;
    GENERATED_COMMANDS_INFO_NV                                          :: 1000277005;
    GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV                      :: 1000277006;
    PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV               :: 1000277007;
    PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV              :: 1000278000;
    COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV                 :: 1000278001;
    PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT                 :: 1000281000;
    COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM          :: 1000282000;
    RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM                               :: 1000282001;
    PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT                     :: 1000283000;
    DEPTH_BIAS_INFO_EXT                                                 :: 1000283001;
    DEPTH_BIAS_REPRESENTATION_INFO_EXT                                  :: 1000283002;
    PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT                   :: 1000284000;
    DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT                         :: 1000284001;
    DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT                              :: 1000284002;
    PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT                           :: 1000286000;
    PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT                         :: 1000286001;
    SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT                         :: 1000287000;
    PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT                  :: 1000287001;
    PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT                    :: 1000287002;
    PIPELINE_LIBRARY_CREATE_INFO_KHR                                    :: 1000290000;
    PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV                         :: 1000292000;
    SURFACE_CAPABILITIES_PRESENT_BARRIER_NV                             :: 1000292001;
    SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV                            :: 1000292002;
    PRESENT_ID_KHR                                                      :: 1000294000;
    PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR                             :: 1000294001;

    PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV                      :: 1000300000;
    DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV                            :: 1000300001;
    QUERY_LOW_LATENCY_SUPPORT_NV                                        :: 1000310000;
    EXPORT_METAL_OBJECT_CREATE_INFO_EXT                                 :: 1000311000;
    EXPORT_METAL_OBJECTS_INFO_EXT                                       :: 1000311001;
    EXPORT_METAL_DEVICE_INFO_EXT                                        :: 1000311002;
    EXPORT_METAL_COMMAND_QUEUE_INFO_EXT                                 :: 1000311003;
    EXPORT_METAL_BUFFER_INFO_EXT                                        :: 1000311004;
    IMPORT_METAL_BUFFER_INFO_EXT                                        :: 1000311005;
    EXPORT_METAL_TEXTURE_INFO_EXT                                       :: 1000311006;
    IMPORT_METAL_TEXTURE_INFO_EXT                                       :: 1000311007;
    EXPORT_METAL_IO_SURFACE_INFO_EXT                                    :: 1000311008;
    IMPORT_METAL_IO_SURFACE_INFO_EXT                                    :: 1000311009;
    EXPORT_METAL_SHARED_EVENT_INFO_EXT                                  :: 1000311010;
    IMPORT_METAL_SHARED_EVENT_INFO_EXT                                  :: 1000311011;
    QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV                             :: 1000314008;
    CHECKPOINT_DATA_2_NV                                                :: 1000314009;
    PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT                    :: 1000316000;
    PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT        :: 1000316001;
    PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT                      :: 1000316002;
    DESCRIPTOR_ADDRESS_INFO_EXT                                         :: 1000316003;
    DESCRIPTOR_GET_INFO_EXT                                             :: 1000316004;
    BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT                             :: 1000316005;
    IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT                              :: 1000316006;
    IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT                         :: 1000316007;
    SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT                            :: 1000316008;
    OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT                      :: 1000316010;
    DESCRIPTOR_BUFFER_BINDING_INFO_EXT                                  :: 1000316011;
    DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT         :: 1000316012;
    ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT             :: 1000316009;
    PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT              :: 1000320000;
    PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT            :: 1000320001;
    GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT                           :: 1000320002;
    PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD   :: 1000321000;
    PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR            :: 1000203000;
    PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR          :: 1000322000;
    PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR   :: 1000323000;
    PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV           :: 1000326000;
    PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV             :: 1000326001;
    PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV            :: 1000326002;
    ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV            :: 1000327000;
    PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV                 :: 1000327001;
    ACCELERATION_STRUCTURE_MOTION_INFO_NV                               :: 1000327002;
    PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT                            :: 1000328000;
    PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT                          :: 1000328001;
    PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT              :: 1000330000;
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT                 :: 1000332000;
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT               :: 1000332001;
    COPY_COMMAND_TRANSFORM_INFO_QCOM                                    :: 1000333000;
    PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR       :: 1000336000;
    PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT              :: 1000338000;
    IMAGE_COMPRESSION_CONTROL_EXT                                       :: 1000338001;
    IMAGE_COMPRESSION_PROPERTIES_EXT                                    :: 1000338004;
    PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT        :: 1000339000;
    PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT                           :: 1000340000;
    PHYSICAL_DEVICE_FAULT_FEATURES_EXT                                  :: 1000341000;
    DEVICE_FAULT_COUNTS_EXT                                             :: 1000341001;
    DEVICE_FAULT_INFO_EXT                                               :: 1000341002;
    PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT                       :: 1000344000;
    DIRECTFB_SURFACE_CREATE_INFO_EXT                                    :: 1000346000;
    PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT             :: 1000352000;
    VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT                              :: 1000352001;
    VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT                            :: 1000352002;
    PHYSICAL_DEVICE_DRM_PROPERTIES_EXT                                  :: 1000353000;
    PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT                 :: 1000354000;
    DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT                            :: 1000354001;
    PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT                     :: 1000355000;
    PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT                :: 1000355001;
    PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT        :: 1000356000;
    IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA                            :: 1000364000;
    MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA                             :: 1000364001;
    MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA                               :: 1000364002;
    IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA                         :: 1000365000;
    SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA                            :: 1000365001;
    BUFFER_COLLECTION_CREATE_INFO_FUCHSIA                               :: 1000366000;
    IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA                             :: 1000366001;
    BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA                         :: 1000366002;
    BUFFER_COLLECTION_PROPERTIES_FUCHSIA                                :: 1000366003;
    BUFFER_CONSTRAINTS_INFO_FUCHSIA                                     :: 1000366004;
    BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA                        :: 1000366005;
    IMAGE_CONSTRAINTS_INFO_FUCHSIA                                      :: 1000366006;
    IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA                               :: 1000366007;
    SYSMEM_COLOR_SPACE_FUCHSIA                                          :: 1000366008;
    BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA                          :: 1000366009;
    SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI                         :: 1000369000;
    PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI                     :: 1000369001;
    PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI                   :: 1000369002;
    PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI                     :: 1000370000;
    MEMORY_GET_REMOTE_ADDRESS_INFO_NV                                   :: 1000371000;
    PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV                    :: 1000371001;
    PIPELINE_PROPERTIES_IDENTIFIER_EXT                                  :: 1000372000;
    PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT                    :: 1000372001;
    PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT                         :: 1000375000;
    FRAME_BOUNDARY_EXT                                                  :: 1000375001;
    PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT  :: 1000376000;
    SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT                               :: 1000376001;
    MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT                      :: 1000376002;
    PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT               :: 1000377000;
    SCREEN_SURFACE_CREATE_INFO_QNX                                      :: 1000378000;
    PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT                     :: 1000381000;
    PIPELINE_COLOR_WRITE_CREATE_INFO_EXT                                :: 1000381001;
    PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT             :: 1000382000;
    PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR              :: 1000386000;
    PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT                     :: 1000391000;
    IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT                                  :: 1000391001;
    PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT                             :: 1000392000;
    PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT                           :: 1000392001;
    PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT                    :: 1000393000;
    PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT                      :: 1000395000;
    PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT                    :: 1000395001;
    MICROMAP_BUILD_INFO_EXT                                             :: 1000396000;
    MICROMAP_VERSION_INFO_EXT                                           :: 1000396001;
    COPY_MICROMAP_INFO_EXT                                              :: 1000396002;
    COPY_MICROMAP_TO_MEMORY_INFO_EXT                                    :: 1000396003;
    COPY_MEMORY_TO_MICROMAP_INFO_EXT                                    :: 1000396004;
    PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT                       :: 1000396005;
    PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT                     :: 1000396006;
    MICROMAP_CREATE_INFO_EXT                                            :: 1000396007;
    MICROMAP_BUILD_SIZES_INFO_EXT                                       :: 1000396008;
    ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT               :: 1000396009;

    PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI              :: 1000404000;
    PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI            :: 1000404001;
    PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT                   :: 1000411000;
    SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT              :: 1000411001;
    PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT           :: 1000412000;
    PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM                          :: 1000415000;
    PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT                :: 1000418000;
    IMAGE_VIEW_SLICED_CREATE_INFO_EXT                                   :: 1000418001;
    PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE          :: 1000420000;
    DESCRIPTOR_SET_BINDING_REFERENCE_VALVE                              :: 1000420001;
    DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE                       :: 1000420002;
    PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT                   :: 1000421000;
    PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT                  :: 1000422000;
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM           :: 1000425000;
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM         :: 1000425001;
    SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM                   :: 1000425002;
    PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV                    :: 1000426000;
    PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV                  :: 1000426001;
    PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV                    :: 1000427000;
    PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV                  :: 1000427001;
    PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV       :: 1000428000;
    COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV                            :: 1000428001;
    PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV                            :: 1000428002;
    PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV                 :: 1000430000;
    PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT    :: 1000437000;
    PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM                      :: 1000440000;
    PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM                    :: 1000440001;
    IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM                           :: 1000440002;
    PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT                  :: 1000451000;
    PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT                :: 1000451001;
    EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT                              :: 1000453000;
    PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT               :: 1000455000;
    PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT             :: 1000455001;
    PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT                 :: 1000458000;
    RENDER_PASS_CREATION_CONTROL_EXT                                    :: 1000458001;
    RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT                       :: 1000458002;
    RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT                        :: 1000458003;
    DIRECT_DRIVER_LOADING_INFO_LUNARG                                   :: 1000459000;
    DIRECT_DRIVER_LOADING_LIST_LUNARG                                   :: 1000459001;
    PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT               :: 1000462000;
    PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT             :: 1000462001;
    PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT             :: 1000462002;
    SHADER_MODULE_IDENTIFIER_EXT                                        :: 1000462003;
    PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT  :: 1000342000;
    PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV                            :: 1000464000;
    PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV                          :: 1000464001;
    OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV                                   :: 1000464002;
    OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV                             :: 1000464003;
    OPTICAL_FLOW_SESSION_CREATE_INFO_NV                                 :: 1000464004;
    OPTICAL_FLOW_EXECUTE_INFO_NV                                        :: 1000464005;
    OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV                    :: 1000464010;
    PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT                       :: 1000465000;
    PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT              :: 1000466000;
    PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID            :: 1000468000;
    PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID          :: 1000468001;
    ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID           :: 1000468002;
    PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR                          :: 1000470000;
    PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR                        :: 1000470001;
    RENDERING_AREA_INFO_KHR                                             :: 1000470003;
    DEVICE_IMAGE_SUBRESOURCE_INFO_KHR                                   :: 1000470004;
    SUBRESOURCE_LAYOUT_2_KHR                                            :: 1000338002;
    IMAGE_SUBRESOURCE_2_KHR                                             :: 1000338003;
    PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR                             :: 1000470005;
    BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR                                :: 1000470006;
    PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR             :: 1000481000;
    PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT                          :: 1000482000;
    PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT                        :: 1000482001;
    SHADER_CREATE_INFO_EXT                                              :: 1000482002;
    PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM                       :: 1000484000;
    TILE_PROPERTIES_QCOM                                                :: 1000484001;
    PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC                        :: 1000485000;
    AMIGO_PROFILING_SUBMIT_INFO_SEC                                     :: 1000485001;
    PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM          :: 1000488000;
    PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV          :: 1000490000;
    PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV        :: 1000490001;
    PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV           :: 1000492000;
    PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV         :: 1000492001;
    PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT                :: 1000351000;
    MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT                             :: 1000351002;
    PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM                   :: 1000497000;
    PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM                 :: 1000497001;
    PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT         :: 1000498000;
    PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT   :: 1000499000;
    LATENCY_SLEEP_MODE_INFO_NV                                          :: 1000505000;
    LATENCY_SLEEP_INFO_NV                                               :: 1000505001;
    SET_LATENCY_MARKER_INFO_NV                                          :: 1000505002;
    GET_LATENCY_MARKER_INFO_NV                                          :: 1000505003;
    LATENCY_TIMINGS_FRAME_REPORT_NV                                     :: 1000505004;
    LATENCY_SUBMISSION_PRESENT_ID_NV                                    :: 1000505005;
    OUT_OF_BAND_QUEUE_TYPE_INFO_NV                                      :: 1000505006;
    SWAPCHAIN_LATENCY_CREATE_INFO_NV                                    :: 1000505007;
    LATENCY_SURFACE_CAPABILITIES_NV                                     :: 1000505008;
    PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR                     :: 1000506000;
    COOPERATIVE_MATRIX_PROPERTIES_KHR                                   :: 1000506001;
    PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR                   :: 1000506002;
    PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM       :: 1000510000;
    MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM         :: 1000510001;
    PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM                    :: 1000518000;
    PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM                  :: 1000518001;
    SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM                         :: 1000518002;
    SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM                              :: 1000519000;
    PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM                         :: 1000519001;
    BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM                                  :: 1000519002;
    PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM                         :: 1000520000;
    SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM             :: 1000520001;
    PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM                           :: 1000521000;
    PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT :: 1000524000;
    SCREEN_BUFFER_PROPERTIES_QNX                                        :: 1000529000;
    SCREEN_BUFFER_FORMAT_PROPERTIES_QNX                                 :: 1000529001;
    IMPORT_SCREEN_BUFFER_INFO_QNX                                       :: 1000529002;
    EXTERNAL_FORMAT_QNX                                                 :: 1000529003;
    PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX          :: 1000529004;
    PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT                      :: 1000530000;
    PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV          :: 1000546000;
    PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES                           :: 1000120000;
    PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES                      :: 1000063000;
    DEBUG_REPORT_CREATE_INFO_EXT                                        :: 1000011000;
    RENDERING_INFO_KHR                                                  :: 1000044000;
    RENDERING_ATTACHMENT_INFO_KHR                                       :: 1000044001;
    PIPELINE_RENDERING_CREATE_INFO_KHR                                  :: 1000044002;
    PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR                      :: 1000044003;
    COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR                       :: 1000044004;
    ATTACHMENT_SAMPLE_COUNT_INFO_NV                                     :: 1000044008;
    RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR                               :: 1000053000;
    PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR                              :: 1000053001;
    PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR                            :: 1000053002;
    PHYSICAL_DEVICE_FEATURES_2_KHR                                      :: 1000059000;
    PHYSICAL_DEVICE_PROPERTIES_2_KHR                                    :: 1000059001;
    FORMAT_PROPERTIES_2_KHR                                             :: 1000059002;
    IMAGE_FORMAT_PROPERTIES_2_KHR                                       :: 1000059003;
    PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR                             :: 1000059004;
    QUEUE_FAMILY_PROPERTIES_2_KHR                                       :: 1000059005;
    PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR                             :: 1000059006;
    SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR                                :: 1000059007;
    PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR                      :: 1000059008;
    MEMORY_ALLOCATE_FLAGS_INFO_KHR                                      :: 1000060000;
    DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR                             :: 1000060003;
    DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR                          :: 1000060004;
    DEVICE_GROUP_SUBMIT_INFO_KHR                                        :: 1000060005;
    DEVICE_GROUP_BIND_SPARSE_INFO_KHR                                   :: 1000060006;
    BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR                            :: 1000060013;
    BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR                             :: 1000060014;
    PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT           :: 1000066000;
    PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR                                :: 1000070000;
    DEVICE_GROUP_DEVICE_CREATE_INFO_KHR                                 :: 1000070001;
    PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR                      :: 1000071000;
    EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR                                :: 1000071001;
    PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR                            :: 1000071002;
    EXTERNAL_BUFFER_PROPERTIES_KHR                                      :: 1000071003;
    PHYSICAL_DEVICE_ID_PROPERTIES_KHR                                   :: 1000071004;
    EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR                              :: 1000072000;
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR                               :: 1000072001;
    EXPORT_MEMORY_ALLOCATE_INFO_KHR                                     :: 1000072002;
    PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR                         :: 1000076000;
    EXTERNAL_SEMAPHORE_PROPERTIES_KHR                                   :: 1000076001;
    EXPORT_SEMAPHORE_CREATE_INFO_KHR                                    :: 1000077000;
    PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR                    :: 1000082000;
    PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR                           :: 1000082000;
    PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR                          :: 1000083000;
    DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR                          :: 1000085000;
    SURFACE_CAPABILITIES2_EXT                                           :: 1000090000;
    PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR                  :: 1000108000;
    FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR                             :: 1000108001;
    FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR                               :: 1000108002;
    RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR                               :: 1000108003;
    ATTACHMENT_DESCRIPTION_2_KHR                                        :: 1000109000;
    ATTACHMENT_REFERENCE_2_KHR                                          :: 1000109001;
    SUBPASS_DESCRIPTION_2_KHR                                           :: 1000109002;
    SUBPASS_DEPENDENCY_2_KHR                                            :: 1000109003;
    RENDER_PASS_CREATE_INFO_2_KHR                                       :: 1000109004;
    SUBPASS_BEGIN_INFO_KHR                                              :: 1000109005;
    SUBPASS_END_INFO_KHR                                                :: 1000109006;
    PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR                             :: 1000112000;
    EXTERNAL_FENCE_PROPERTIES_KHR                                       :: 1000112001;
    EXPORT_FENCE_CREATE_INFO_KHR                                        :: 1000113000;
    PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR                       :: 1000117000;
    RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR                 :: 1000117001;
    IMAGE_VIEW_USAGE_CREATE_INFO_KHR                                    :: 1000117002;
    PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR           :: 1000117003;
    PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR                      :: 1000120000;
    PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR                       :: 1000120000;
    MEMORY_DEDICATED_REQUIREMENTS_KHR                                   :: 1000127000;
    MEMORY_DEDICATED_ALLOCATE_INFO_KHR                                  :: 1000127001;
    PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT                :: 1000130000;
    SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT                              :: 1000130001;
    PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT                   :: 1000138000;
    PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT                 :: 1000138001;
    WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT                       :: 1000138002;
    DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT                :: 1000138003;
    BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR                               :: 1000146000;
    IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR                                :: 1000146001;
    IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR                         :: 1000146002;
    MEMORY_REQUIREMENTS_2_KHR                                           :: 1000146003;
    SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR                              :: 1000146004;
    IMAGE_FORMAT_LIST_CREATE_INFO_KHR                                   :: 1000147000;
    SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR                            :: 1000156000;
    SAMPLER_YCBCR_CONVERSION_INFO_KHR                                   :: 1000156001;
    BIND_IMAGE_PLANE_MEMORY_INFO_KHR                                    :: 1000156002;
    IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR                            :: 1000156003;
    PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR               :: 1000156004;
    SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR                :: 1000156005;
    BIND_BUFFER_MEMORY_INFO_KHR                                         :: 1000157000;
    BIND_IMAGE_MEMORY_INFO_KHR                                          :: 1000157001;
    DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT                 :: 1000161000;
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT                    :: 1000161001;
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT                  :: 1000161002;
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT          :: 1000161003;
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT         :: 1000161004;
    PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR                        :: 1000168000;
    DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR                                   :: 1000168001;
    DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT                        :: 1000174000;
    PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR         :: 1000175000;
    PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR                           :: 1000177000;
    PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR                    :: 1000180000;
    PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT                          :: 1000192000;
    PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR                               :: 1000196000;
    PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR                       :: 1000197000;
    PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR                :: 1000199000;
    SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR                       :: 1000199001;
    PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV             :: 1000203000;
    PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR                     :: 1000207000;
    PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR                   :: 1000207001;
    SEMAPHORE_TYPE_CREATE_INFO_KHR                                      :: 1000207002;
    TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR                                  :: 1000207003;
    SEMAPHORE_WAIT_INFO_KHR                                             :: 1000207004;
    SEMAPHORE_SIGNAL_INFO_KHR                                           :: 1000207005;
    QUERY_POOL_CREATE_INFO_INTEL                                        :: 1000210000;
    PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR                    :: 1000211000;
    PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR            :: 1000215000;
    PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT                    :: 1000221000;
    PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT                :: 1000225000;
    PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT        :: 1000225001;
    PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT                  :: 1000225002;
    PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR         :: 1000241000;
    ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR                             :: 1000241001;
    ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR                           :: 1000241002;
    PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT                         :: 1000244000;
    BUFFER_DEVICE_ADDRESS_INFO_EXT                                      :: 1000244001;
    PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT                                 :: 1000245000;
    IMAGE_STENCIL_USAGE_CREATE_INFO_EXT                                 :: 1000246000;
    PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR         :: 1000253000;
    PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR                  :: 1000257000;
    BUFFER_DEVICE_ADDRESS_INFO_KHR                                      :: 1000244001;
    BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR                       :: 1000257002;
    MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR                     :: 1000257003;
    DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR                       :: 1000257004;
    PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT                       :: 1000261000;
    PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT     :: 1000276000;
    PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR             :: 1000280000;
    PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR           :: 1000280001;
    PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT               :: 1000281001;
    PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT                           :: 1000295000;
    DEVICE_PRIVATE_DATA_CREATE_INFO_EXT                                 :: 1000295001;
    PRIVATE_DATA_SLOT_CREATE_INFO_EXT                                   :: 1000295002;
    PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT        :: 1000297000;
    MEMORY_BARRIER_2_KHR                                                :: 1000314000;
    BUFFER_MEMORY_BARRIER_2_KHR                                         :: 1000314001;
    IMAGE_MEMORY_BARRIER_2_KHR                                          :: 1000314002;
    DEPENDENCY_INFO_KHR                                                 :: 1000314003;
    SUBMIT_INFO_2_KHR                                                   :: 1000314004;
    SEMAPHORE_SUBMIT_INFO_KHR                                           :: 1000314005;
    COMMAND_BUFFER_SUBMIT_INFO_KHR                                      :: 1000314006;
    PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR                      :: 1000314007;
    PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR       :: 1000325000;
    PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT                       :: 1000335000;
    COPY_BUFFER_INFO_2_KHR                                              :: 1000337000;
    COPY_IMAGE_INFO_2_KHR                                               :: 1000337001;
    COPY_BUFFER_TO_IMAGE_INFO_2_KHR                                     :: 1000337002;
    COPY_IMAGE_TO_BUFFER_INFO_2_KHR                                     :: 1000337003;
    BLIT_IMAGE_INFO_2_KHR                                               :: 1000337004;
    RESOLVE_IMAGE_INFO_2_KHR                                            :: 1000337005;
    BUFFER_COPY_2_KHR                                                   :: 1000337006;
    IMAGE_COPY_2_KHR                                                    :: 1000337007;
    IMAGE_BLIT_2_KHR                                                    :: 1000337008;
    BUFFER_IMAGE_COPY_2_KHR                                             :: 1000337009;
    IMAGE_RESOLVE_2_KHR                                                 :: 1000337010;
    SUBRESOURCE_LAYOUT_2_EXT                                            :: 1000338002;
    IMAGE_SUBRESOURCE_2_EXT                                             :: 1000338003;
    PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM  :: 1000342000;
    PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE              :: 1000351000;
    MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE                           :: 1000351002;
    FORMAT_PROPERTIES_3_KHR                                             :: 1000360000;
    PIPELINE_INFO_EXT                                                   :: 1000269001;
    PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT                  :: 1000388000;
    QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT                         :: 1000388001;
    PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR                          :: 1000413000;
    PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR                        :: 1000413001;
    DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR                               :: 1000413002;
    DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR                                :: 1000413003;
    SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT                       :: 1000225001;
    MAX_ENUM                                                            :: 2147483647;
}

VkPipelineCacheHeaderVersion :: enum s32 {
    ONE      :: 1;
    MAX_ENUM :: 2147483647;
}

VkImageLayout :: enum s32 {
    UNDEFINED                                      :: 0;
    GENERAL                                        :: 1;
    COLOR_ATTACHMENT_OPTIMAL                       :: 2;
    DEPTH_STENCIL_ATTACHMENT_OPTIMAL               :: 3;
    DEPTH_STENCIL_READ_ONLY_OPTIMAL                :: 4;
    SHADER_READ_ONLY_OPTIMAL                       :: 5;
    TRANSFER_SRC_OPTIMAL                           :: 6;
    TRANSFER_DST_OPTIMAL                           :: 7;
    PREINITIALIZED                                 :: 8;
    DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL     :: 1000117000;
    DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL     :: 1000117001;
    DEPTH_ATTACHMENT_OPTIMAL                       :: 1000241000;
    DEPTH_READ_ONLY_OPTIMAL                        :: 1000241001;
    STENCIL_ATTACHMENT_OPTIMAL                     :: 1000241002;
    STENCIL_READ_ONLY_OPTIMAL                      :: 1000241003;
    READ_ONLY_OPTIMAL                              :: 1000314000;
    ATTACHMENT_OPTIMAL                             :: 1000314001;
    PRESENT_SRC_KHR                                :: 1000001002;
    VIDEO_DECODE_DST_KHR                           :: 1000024000;
    VIDEO_DECODE_SRC_KHR                           :: 1000024001;
    VIDEO_DECODE_DPB_KHR                           :: 1000024002;
    SHARED_PRESENT_KHR                             :: 1000111000;
    FRAGMENT_DENSITY_MAP_OPTIMAL_EXT               :: 1000218000;
    FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR   :: 1000164003;

    ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT           :: 1000339000;
    DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR :: 1000117000;
    DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR :: 1000117001;
    SHADING_RATE_OPTIMAL_NV                        :: 1000164003;
    DEPTH_ATTACHMENT_OPTIMAL_KHR                   :: 1000241000;
    DEPTH_READ_ONLY_OPTIMAL_KHR                    :: 1000241001;
    STENCIL_ATTACHMENT_OPTIMAL_KHR                 :: 1000241002;
    STENCIL_READ_ONLY_OPTIMAL_KHR                  :: 1000241003;
    READ_ONLY_OPTIMAL_KHR                          :: 1000314000;
    ATTACHMENT_OPTIMAL_KHR                         :: 1000314001;
    MAX_ENUM                                       :: 2147483647;
}

VkObjectType :: enum s32 {
    UNKNOWN                         :: 0;
    INSTANCE                        :: 1;
    PHYSICAL_DEVICE                 :: 2;
    DEVICE                          :: 3;
    QUEUE                           :: 4;
    SEMAPHORE                       :: 5;
    COMMAND_BUFFER                  :: 6;
    FENCE                           :: 7;
    DEVICE_MEMORY                   :: 8;
    BUFFER                          :: 9;
    IMAGE                           :: 10;
    EVENT                           :: 11;
    QUERY_POOL                      :: 12;
    BUFFER_VIEW                     :: 13;
    IMAGE_VIEW                      :: 14;
    SHADER_MODULE                   :: 15;
    PIPELINE_CACHE                  :: 16;
    PIPELINE_LAYOUT                 :: 17;
    RENDER_PASS                     :: 18;
    PIPELINE                        :: 19;
    DESCRIPTOR_SET_LAYOUT           :: 20;
    SAMPLER                         :: 21;
    DESCRIPTOR_POOL                 :: 22;
    DESCRIPTOR_SET                  :: 23;
    FRAMEBUFFER                     :: 24;
    COMMAND_POOL                    :: 25;
    SAMPLER_YCBCR_CONVERSION        :: 1000156000;
    DESCRIPTOR_UPDATE_TEMPLATE      :: 1000085000;
    PRIVATE_DATA_SLOT               :: 1000295000;
    SURFACE_KHR                     :: 1000000000;
    SWAPCHAIN_KHR                   :: 1000001000;
    DISPLAY_KHR                     :: 1000002000;
    DISPLAY_MODE_KHR                :: 1000002001;
    DEBUG_REPORT_CALLBACK_EXT       :: 1000011000;
    VIDEO_SESSION_KHR               :: 1000023000;
    VIDEO_SESSION_PARAMETERS_KHR    :: 1000023001;
    CU_MODULE_NVX                   :: 1000029000;
    CU_FUNCTION_NVX                 :: 1000029001;
    DEBUG_UTILS_MESSENGER_EXT       :: 1000128000;
    ACCELERATION_STRUCTURE_KHR      :: 1000150000;
    VALIDATION_CACHE_EXT            :: 1000160000;
    ACCELERATION_STRUCTURE_NV       :: 1000165000;
    PERFORMANCE_CONFIGURATION_INTEL :: 1000210000;
    DEFERRED_OPERATION_KHR          :: 1000268000;
    INDIRECT_COMMANDS_LAYOUT_NV     :: 1000277000;
    BUFFER_COLLECTION_FUCHSIA       :: 1000366000;
    MICROMAP_EXT                    :: 1000396000;
    OPTICAL_FLOW_SESSION_NV         :: 1000464000;
    SHADER_EXT                      :: 1000482000;
    DESCRIPTOR_UPDATE_TEMPLATE_KHR  :: 1000085000;
    SAMPLER_YCBCR_CONVERSION_KHR    :: 1000156000;
    PRIVATE_DATA_SLOT_EXT           :: 1000295000;
    MAX_ENUM                        :: 2147483647;
}

VkVendorId :: enum s32 {
    VIV      :: 65537;
    VSI      :: 65538;
    KAZAN    :: 65539;
    CODEPLAY :: 65540;
    MESA     :: 65541;
    POCL     :: 65542;
    MOBILEYE :: 65543;
    MAX_ENUM :: 2147483647;
}

VkSystemAllocationScope :: enum s32 {
    COMMAND  :: 0;
    OBJECT   :: 1;
    CACHE    :: 2;
    DEVICE   :: 3;
    INSTANCE :: 4;
    MAX_ENUM :: 2147483647;
}

VkInternalAllocationType :: enum s32 {
    EXECUTABLE :: 0;
    MAX_ENUM   :: 2147483647;
}

VkFormat :: enum s32 {
    UNDEFINED                                      :: 0;
    R4G4_UNORM_PACK8                               :: 1;
    R4G4B4A4_UNORM_PACK16                          :: 2;
    B4G4R4A4_UNORM_PACK16                          :: 3;
    R5G6B5_UNORM_PACK16                            :: 4;
    B5G6R5_UNORM_PACK16                            :: 5;
    R5G5B5A1_UNORM_PACK16                          :: 6;
    B5G5R5A1_UNORM_PACK16                          :: 7;
    A1R5G5B5_UNORM_PACK16                          :: 8;
    R8_UNORM                                       :: 9;
    R8_SNORM                                       :: 10;
    R8_USCALED                                     :: 11;
    R8_SSCALED                                     :: 12;
    R8_UINT                                        :: 13;
    R8_SINT                                        :: 14;
    R8_SRGB                                        :: 15;
    R8G8_UNORM                                     :: 16;
    R8G8_SNORM                                     :: 17;
    R8G8_USCALED                                   :: 18;
    R8G8_SSCALED                                   :: 19;
    R8G8_UINT                                      :: 20;
    R8G8_SINT                                      :: 21;
    R8G8_SRGB                                      :: 22;
    R8G8B8_UNORM                                   :: 23;
    R8G8B8_SNORM                                   :: 24;
    R8G8B8_USCALED                                 :: 25;
    R8G8B8_SSCALED                                 :: 26;
    R8G8B8_UINT                                    :: 27;
    R8G8B8_SINT                                    :: 28;
    R8G8B8_SRGB                                    :: 29;
    B8G8R8_UNORM                                   :: 30;
    B8G8R8_SNORM                                   :: 31;
    B8G8R8_USCALED                                 :: 32;
    B8G8R8_SSCALED                                 :: 33;
    B8G8R8_UINT                                    :: 34;
    B8G8R8_SINT                                    :: 35;
    B8G8R8_SRGB                                    :: 36;
    R8G8B8A8_UNORM                                 :: 37;
    R8G8B8A8_SNORM                                 :: 38;
    R8G8B8A8_USCALED                               :: 39;
    R8G8B8A8_SSCALED                               :: 40;
    R8G8B8A8_UINT                                  :: 41;
    R8G8B8A8_SINT                                  :: 42;
    R8G8B8A8_SRGB                                  :: 43;
    B8G8R8A8_UNORM                                 :: 44;
    B8G8R8A8_SNORM                                 :: 45;
    B8G8R8A8_USCALED                               :: 46;
    B8G8R8A8_SSCALED                               :: 47;
    B8G8R8A8_UINT                                  :: 48;
    B8G8R8A8_SINT                                  :: 49;
    B8G8R8A8_SRGB                                  :: 50;
    A8B8G8R8_UNORM_PACK32                          :: 51;
    A8B8G8R8_SNORM_PACK32                          :: 52;
    A8B8G8R8_USCALED_PACK32                        :: 53;
    A8B8G8R8_SSCALED_PACK32                        :: 54;
    A8B8G8R8_UINT_PACK32                           :: 55;
    A8B8G8R8_SINT_PACK32                           :: 56;
    A8B8G8R8_SRGB_PACK32                           :: 57;
    A2R10G10B10_UNORM_PACK32                       :: 58;
    A2R10G10B10_SNORM_PACK32                       :: 59;
    A2R10G10B10_USCALED_PACK32                     :: 60;
    A2R10G10B10_SSCALED_PACK32                     :: 61;
    A2R10G10B10_UINT_PACK32                        :: 62;
    A2R10G10B10_SINT_PACK32                        :: 63;
    A2B10G10R10_UNORM_PACK32                       :: 64;
    A2B10G10R10_SNORM_PACK32                       :: 65;
    A2B10G10R10_USCALED_PACK32                     :: 66;
    A2B10G10R10_SSCALED_PACK32                     :: 67;
    A2B10G10R10_UINT_PACK32                        :: 68;
    A2B10G10R10_SINT_PACK32                        :: 69;
    R16_UNORM                                      :: 70;
    R16_SNORM                                      :: 71;
    R16_USCALED                                    :: 72;
    R16_SSCALED                                    :: 73;
    R16_UINT                                       :: 74;
    R16_SINT                                       :: 75;
    R16_SFLOAT                                     :: 76;
    R16G16_UNORM                                   :: 77;
    R16G16_SNORM                                   :: 78;
    R16G16_USCALED                                 :: 79;
    R16G16_SSCALED                                 :: 80;
    R16G16_UINT                                    :: 81;
    R16G16_SINT                                    :: 82;
    R16G16_SFLOAT                                  :: 83;
    R16G16B16_UNORM                                :: 84;
    R16G16B16_SNORM                                :: 85;
    R16G16B16_USCALED                              :: 86;
    R16G16B16_SSCALED                              :: 87;
    R16G16B16_UINT                                 :: 88;
    R16G16B16_SINT                                 :: 89;
    R16G16B16_SFLOAT                               :: 90;
    R16G16B16A16_UNORM                             :: 91;
    R16G16B16A16_SNORM                             :: 92;
    R16G16B16A16_USCALED                           :: 93;
    R16G16B16A16_SSCALED                           :: 94;
    R16G16B16A16_UINT                              :: 95;
    R16G16B16A16_SINT                              :: 96;
    R16G16B16A16_SFLOAT                            :: 97;
    R32_UINT                                       :: 98;
    R32_SINT                                       :: 99;
    R32_SFLOAT                                     :: 100;
    R32G32_UINT                                    :: 101;
    R32G32_SINT                                    :: 102;
    R32G32_SFLOAT                                  :: 103;
    R32G32B32_UINT                                 :: 104;
    R32G32B32_SINT                                 :: 105;
    R32G32B32_SFLOAT                               :: 106;
    R32G32B32A32_UINT                              :: 107;
    R32G32B32A32_SINT                              :: 108;
    R32G32B32A32_SFLOAT                            :: 109;
    R64_UINT                                       :: 110;
    R64_SINT                                       :: 111;
    R64_SFLOAT                                     :: 112;
    R64G64_UINT                                    :: 113;
    R64G64_SINT                                    :: 114;
    R64G64_SFLOAT                                  :: 115;
    R64G64B64_UINT                                 :: 116;
    R64G64B64_SINT                                 :: 117;
    R64G64B64_SFLOAT                               :: 118;
    R64G64B64A64_UINT                              :: 119;
    R64G64B64A64_SINT                              :: 120;
    R64G64B64A64_SFLOAT                            :: 121;
    B10G11R11_UFLOAT_PACK32                        :: 122;
    E5B9G9R9_UFLOAT_PACK32                         :: 123;
    D16_UNORM                                      :: 124;
    X8_D24_UNORM_PACK32                            :: 125;
    D32_SFLOAT                                     :: 126;
    S8_UINT                                        :: 127;
    D16_UNORM_S8_UINT                              :: 128;
    D24_UNORM_S8_UINT                              :: 129;
    D32_SFLOAT_S8_UINT                             :: 130;
    BC1_RGB_UNORM_BLOCK                            :: 131;
    BC1_RGB_SRGB_BLOCK                             :: 132;
    BC1_RGBA_UNORM_BLOCK                           :: 133;
    BC1_RGBA_SRGB_BLOCK                            :: 134;
    BC2_UNORM_BLOCK                                :: 135;
    BC2_SRGB_BLOCK                                 :: 136;
    BC3_UNORM_BLOCK                                :: 137;
    BC3_SRGB_BLOCK                                 :: 138;
    BC4_UNORM_BLOCK                                :: 139;
    BC4_SNORM_BLOCK                                :: 140;
    BC5_UNORM_BLOCK                                :: 141;
    BC5_SNORM_BLOCK                                :: 142;
    BC6H_UFLOAT_BLOCK                              :: 143;
    BC6H_SFLOAT_BLOCK                              :: 144;
    BC7_UNORM_BLOCK                                :: 145;
    BC7_SRGB_BLOCK                                 :: 146;
    ETC2_R8G8B8_UNORM_BLOCK                        :: 147;
    ETC2_R8G8B8_SRGB_BLOCK                         :: 148;
    ETC2_R8G8B8A1_UNORM_BLOCK                      :: 149;
    ETC2_R8G8B8A1_SRGB_BLOCK                       :: 150;
    ETC2_R8G8B8A8_UNORM_BLOCK                      :: 151;
    ETC2_R8G8B8A8_SRGB_BLOCK                       :: 152;
    EAC_R11_UNORM_BLOCK                            :: 153;
    EAC_R11_SNORM_BLOCK                            :: 154;
    EAC_R11G11_UNORM_BLOCK                         :: 155;
    EAC_R11G11_SNORM_BLOCK                         :: 156;
    ASTC_4x4_UNORM_BLOCK                           :: 157;
    ASTC_4x4_SRGB_BLOCK                            :: 158;
    ASTC_5x4_UNORM_BLOCK                           :: 159;
    ASTC_5x4_SRGB_BLOCK                            :: 160;
    ASTC_5x5_UNORM_BLOCK                           :: 161;
    ASTC_5x5_SRGB_BLOCK                            :: 162;
    ASTC_6x5_UNORM_BLOCK                           :: 163;
    ASTC_6x5_SRGB_BLOCK                            :: 164;
    ASTC_6x6_UNORM_BLOCK                           :: 165;
    ASTC_6x6_SRGB_BLOCK                            :: 166;
    ASTC_8x5_UNORM_BLOCK                           :: 167;
    ASTC_8x5_SRGB_BLOCK                            :: 168;
    ASTC_8x6_UNORM_BLOCK                           :: 169;
    ASTC_8x6_SRGB_BLOCK                            :: 170;
    ASTC_8x8_UNORM_BLOCK                           :: 171;
    ASTC_8x8_SRGB_BLOCK                            :: 172;
    ASTC_10x5_UNORM_BLOCK                          :: 173;
    ASTC_10x5_SRGB_BLOCK                           :: 174;
    ASTC_10x6_UNORM_BLOCK                          :: 175;
    ASTC_10x6_SRGB_BLOCK                           :: 176;
    ASTC_10x8_UNORM_BLOCK                          :: 177;
    ASTC_10x8_SRGB_BLOCK                           :: 178;
    ASTC_10x10_UNORM_BLOCK                         :: 179;
    ASTC_10x10_SRGB_BLOCK                          :: 180;
    ASTC_12x10_UNORM_BLOCK                         :: 181;
    ASTC_12x10_SRGB_BLOCK                          :: 182;
    ASTC_12x12_UNORM_BLOCK                         :: 183;
    ASTC_12x12_SRGB_BLOCK                          :: 184;
    G8B8G8R8_422_UNORM                             :: 1000156000;
    B8G8R8G8_422_UNORM                             :: 1000156001;
    G8_B8_R8_3PLANE_420_UNORM                      :: 1000156002;
    G8_B8R8_2PLANE_420_UNORM                       :: 1000156003;
    G8_B8_R8_3PLANE_422_UNORM                      :: 1000156004;
    G8_B8R8_2PLANE_422_UNORM                       :: 1000156005;
    G8_B8_R8_3PLANE_444_UNORM                      :: 1000156006;
    R10X6_UNORM_PACK16                             :: 1000156007;
    R10X6G10X6_UNORM_2PACK16                       :: 1000156008;
    R10X6G10X6B10X6A10X6_UNORM_4PACK16             :: 1000156009;
    G10X6B10X6G10X6R10X6_422_UNORM_4PACK16         :: 1000156010;
    B10X6G10X6R10X6G10X6_422_UNORM_4PACK16         :: 1000156011;
    G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16     :: 1000156012;
    G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16      :: 1000156013;
    G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16     :: 1000156014;
    G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16      :: 1000156015;
    G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16     :: 1000156016;
    R12X4_UNORM_PACK16                             :: 1000156017;
    R12X4G12X4_UNORM_2PACK16                       :: 1000156018;
    R12X4G12X4B12X4A12X4_UNORM_4PACK16             :: 1000156019;
    G12X4B12X4G12X4R12X4_422_UNORM_4PACK16         :: 1000156020;
    B12X4G12X4R12X4G12X4_422_UNORM_4PACK16         :: 1000156021;
    G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16     :: 1000156022;
    G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16      :: 1000156023;
    G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16     :: 1000156024;
    G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16      :: 1000156025;
    G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16     :: 1000156026;
    G16B16G16R16_422_UNORM                         :: 1000156027;
    B16G16R16G16_422_UNORM                         :: 1000156028;
    G16_B16_R16_3PLANE_420_UNORM                   :: 1000156029;
    G16_B16R16_2PLANE_420_UNORM                    :: 1000156030;
    G16_B16_R16_3PLANE_422_UNORM                   :: 1000156031;
    G16_B16R16_2PLANE_422_UNORM                    :: 1000156032;
    G16_B16_R16_3PLANE_444_UNORM                   :: 1000156033;
    G8_B8R8_2PLANE_444_UNORM                       :: 1000330000;
    G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16      :: 1000330001;
    G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16      :: 1000330002;
    G16_B16R16_2PLANE_444_UNORM                    :: 1000330003;
    A4R4G4B4_UNORM_PACK16                          :: 1000340000;
    A4B4G4R4_UNORM_PACK16                          :: 1000340001;
    ASTC_4x4_SFLOAT_BLOCK                          :: 1000066000;
    ASTC_5x4_SFLOAT_BLOCK                          :: 1000066001;
    ASTC_5x5_SFLOAT_BLOCK                          :: 1000066002;
    ASTC_6x5_SFLOAT_BLOCK                          :: 1000066003;
    ASTC_6x6_SFLOAT_BLOCK                          :: 1000066004;
    ASTC_8x5_SFLOAT_BLOCK                          :: 1000066005;
    ASTC_8x6_SFLOAT_BLOCK                          :: 1000066006;
    ASTC_8x8_SFLOAT_BLOCK                          :: 1000066007;
    ASTC_10x5_SFLOAT_BLOCK                         :: 1000066008;
    ASTC_10x6_SFLOAT_BLOCK                         :: 1000066009;
    ASTC_10x8_SFLOAT_BLOCK                         :: 1000066010;
    ASTC_10x10_SFLOAT_BLOCK                        :: 1000066011;
    ASTC_12x10_SFLOAT_BLOCK                        :: 1000066012;
    ASTC_12x12_SFLOAT_BLOCK                        :: 1000066013;
    PVRTC1_2BPP_UNORM_BLOCK_IMG                    :: 1000054000;
    PVRTC1_4BPP_UNORM_BLOCK_IMG                    :: 1000054001;
    PVRTC2_2BPP_UNORM_BLOCK_IMG                    :: 1000054002;
    PVRTC2_4BPP_UNORM_BLOCK_IMG                    :: 1000054003;
    PVRTC1_2BPP_SRGB_BLOCK_IMG                     :: 1000054004;
    PVRTC1_4BPP_SRGB_BLOCK_IMG                     :: 1000054005;
    PVRTC2_2BPP_SRGB_BLOCK_IMG                     :: 1000054006;
    PVRTC2_4BPP_SRGB_BLOCK_IMG                     :: 1000054007;
    R16G16_S10_5_NV                                :: 1000464000;
    A1B5G5R5_UNORM_PACK16_KHR                      :: 1000470000;
    A8_UNORM_KHR                                   :: 1000470001;
    ASTC_4x4_SFLOAT_BLOCK_EXT                      :: 1000066000;
    ASTC_5x4_SFLOAT_BLOCK_EXT                      :: 1000066001;
    ASTC_5x5_SFLOAT_BLOCK_EXT                      :: 1000066002;
    ASTC_6x5_SFLOAT_BLOCK_EXT                      :: 1000066003;
    ASTC_6x6_SFLOAT_BLOCK_EXT                      :: 1000066004;
    ASTC_8x5_SFLOAT_BLOCK_EXT                      :: 1000066005;
    ASTC_8x6_SFLOAT_BLOCK_EXT                      :: 1000066006;
    ASTC_8x8_SFLOAT_BLOCK_EXT                      :: 1000066007;
    ASTC_10x5_SFLOAT_BLOCK_EXT                     :: 1000066008;
    ASTC_10x6_SFLOAT_BLOCK_EXT                     :: 1000066009;
    ASTC_10x8_SFLOAT_BLOCK_EXT                     :: 1000066010;
    ASTC_10x10_SFLOAT_BLOCK_EXT                    :: 1000066011;
    ASTC_12x10_SFLOAT_BLOCK_EXT                    :: 1000066012;
    ASTC_12x12_SFLOAT_BLOCK_EXT                    :: 1000066013;
    G8B8G8R8_422_UNORM_KHR                         :: 1000156000;
    B8G8R8G8_422_UNORM_KHR                         :: 1000156001;
    G8_B8_R8_3PLANE_420_UNORM_KHR                  :: 1000156002;
    G8_B8R8_2PLANE_420_UNORM_KHR                   :: 1000156003;
    G8_B8_R8_3PLANE_422_UNORM_KHR                  :: 1000156004;
    G8_B8R8_2PLANE_422_UNORM_KHR                   :: 1000156005;
    G8_B8_R8_3PLANE_444_UNORM_KHR                  :: 1000156006;
    R10X6_UNORM_PACK16_KHR                         :: 1000156007;
    R10X6G10X6_UNORM_2PACK16_KHR                   :: 1000156008;
    R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR         :: 1000156009;
    G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR     :: 1000156010;
    B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR     :: 1000156011;
    G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR :: 1000156012;
    G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR  :: 1000156013;
    G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR :: 1000156014;
    G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR  :: 1000156015;
    G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR :: 1000156016;
    R12X4_UNORM_PACK16_KHR                         :: 1000156017;
    R12X4G12X4_UNORM_2PACK16_KHR                   :: 1000156018;
    R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR         :: 1000156019;
    G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR     :: 1000156020;
    B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR     :: 1000156021;
    G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR :: 1000156022;
    G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR  :: 1000156023;
    G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR :: 1000156024;
    G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR  :: 1000156025;
    G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR :: 1000156026;
    G16B16G16R16_422_UNORM_KHR                     :: 1000156027;
    B16G16R16G16_422_UNORM_KHR                     :: 1000156028;
    G16_B16_R16_3PLANE_420_UNORM_KHR               :: 1000156029;
    G16_B16R16_2PLANE_420_UNORM_KHR                :: 1000156030;
    G16_B16_R16_3PLANE_422_UNORM_KHR               :: 1000156031;
    G16_B16R16_2PLANE_422_UNORM_KHR                :: 1000156032;
    G16_B16_R16_3PLANE_444_UNORM_KHR               :: 1000156033;
    G8_B8R8_2PLANE_444_UNORM_EXT                   :: 1000330000;
    G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT  :: 1000330001;
    G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT  :: 1000330002;
    G16_B16R16_2PLANE_444_UNORM_EXT                :: 1000330003;
    A4R4G4B4_UNORM_PACK16_EXT                      :: 1000340000;
    A4B4G4R4_UNORM_PACK16_EXT                      :: 1000340001;
    MAX_ENUM                                       :: 2147483647;
}

VkImageTiling :: enum s32 {
    OPTIMAL                 :: 0;
    LINEAR                  :: 1;
    DRM_FORMAT_MODIFIER_EXT :: 1000158000;
    MAX_ENUM                :: 2147483647;
}

VkImageType :: enum s32 {
    _1D      :: 0;
    _2D      :: 1;
    _3D      :: 2;
    MAX_ENUM :: 2147483647;
}

VkPhysicalDeviceType :: enum s32 {
    OTHER          :: 0;
    INTEGRATED_GPU :: 1;
    DISCRETE_GPU   :: 2;
    VIRTUAL_GPU    :: 3;
    CPU            :: 4;
    MAX_ENUM       :: 2147483647;
}

VkQueryType :: enum s32 {
    OCCLUSION                                                      :: 0;
    PIPELINE_STATISTICS                                            :: 1;
    TIMESTAMP                                                      :: 2;
    RESULT_STATUS_ONLY_KHR                                         :: 1000023000;
    TRANSFORM_FEEDBACK_STREAM_EXT                                  :: 1000028004;
    PERFORMANCE_QUERY_KHR                                          :: 1000116000;
    ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR                      :: 1000150000;
    ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR                  :: 1000150001;
    ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV                       :: 1000165000;
    PERFORMANCE_QUERY_INTEL                                        :: 1000210000;

    MESH_PRIMITIVES_GENERATED_EXT                                  :: 1000328000;
    PRIMITIVES_GENERATED_EXT                                       :: 1000382000;
    ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR :: 1000386000;
    ACCELERATION_STRUCTURE_SIZE_KHR                                :: 1000386001;
    MICROMAP_SERIALIZATION_SIZE_EXT                                :: 1000396000;
    MICROMAP_COMPACTED_SIZE_EXT                                    :: 1000396001;
    MAX_ENUM                                                       :: 2147483647;
}

VkSharingMode :: enum s32 {
    EXCLUSIVE  :: 0;
    CONCURRENT :: 1;
    MAX_ENUM   :: 2147483647;
}

VkComponentSwizzle :: enum s32 {
    IDENTITY :: 0;
    ZERO     :: 1;
    ONE      :: 2;
    R        :: 3;
    G        :: 4;
    B        :: 5;
    A        :: 6;
    MAX_ENUM :: 2147483647;
}

VkImageViewType :: enum s32 {
    _1D        :: 0;
    _2D        :: 1;
    _3D        :: 2;
    CUBE       :: 3;
    _1D_ARRAY  :: 4;
    _2D_ARRAY  :: 5;
    CUBE_ARRAY :: 6;
    MAX_ENUM   :: 2147483647;
}

VkBlendFactor :: enum s32 {
    ZERO                     :: 0;
    ONE                      :: 1;
    SRC_COLOR                :: 2;
    ONE_MINUS_SRC_COLOR      :: 3;
    DST_COLOR                :: 4;
    ONE_MINUS_DST_COLOR      :: 5;
    SRC_ALPHA                :: 6;
    ONE_MINUS_SRC_ALPHA      :: 7;
    DST_ALPHA                :: 8;
    ONE_MINUS_DST_ALPHA      :: 9;
    CONSTANT_COLOR           :: 10;
    ONE_MINUS_CONSTANT_COLOR :: 11;
    CONSTANT_ALPHA           :: 12;
    ONE_MINUS_CONSTANT_ALPHA :: 13;
    SRC_ALPHA_SATURATE       :: 14;
    SRC1_COLOR               :: 15;
    ONE_MINUS_SRC1_COLOR     :: 16;
    SRC1_ALPHA               :: 17;
    ONE_MINUS_SRC1_ALPHA     :: 18;
    MAX_ENUM                 :: 2147483647;
}

VkBlendOp :: enum s32 {
    ADD                    :: 0;
    SUBTRACT               :: 1;
    REVERSE_SUBTRACT       :: 2;
    MIN                    :: 3;
    MAX                    :: 4;
    ZERO_EXT               :: 1000148000;
    SRC_EXT                :: 1000148001;
    DST_EXT                :: 1000148002;
    SRC_OVER_EXT           :: 1000148003;
    DST_OVER_EXT           :: 1000148004;
    SRC_IN_EXT             :: 1000148005;
    DST_IN_EXT             :: 1000148006;
    SRC_OUT_EXT            :: 1000148007;
    DST_OUT_EXT            :: 1000148008;
    SRC_ATOP_EXT           :: 1000148009;
    DST_ATOP_EXT           :: 1000148010;
    XOR_EXT                :: 1000148011;
    MULTIPLY_EXT           :: 1000148012;
    SCREEN_EXT             :: 1000148013;
    OVERLAY_EXT            :: 1000148014;
    DARKEN_EXT             :: 1000148015;
    LIGHTEN_EXT            :: 1000148016;
    COLORDODGE_EXT         :: 1000148017;
    COLORBURN_EXT          :: 1000148018;
    HARDLIGHT_EXT          :: 1000148019;
    SOFTLIGHT_EXT          :: 1000148020;
    DIFFERENCE_EXT         :: 1000148021;
    EXCLUSION_EXT          :: 1000148022;
    INVERT_EXT             :: 1000148023;
    INVERT_RGB_EXT         :: 1000148024;
    LINEARDODGE_EXT        :: 1000148025;
    LINEARBURN_EXT         :: 1000148026;
    VIVIDLIGHT_EXT         :: 1000148027;
    LINEARLIGHT_EXT        :: 1000148028;
    PINLIGHT_EXT           :: 1000148029;
    HARDMIX_EXT            :: 1000148030;
    HSL_HUE_EXT            :: 1000148031;
    HSL_SATURATION_EXT     :: 1000148032;
    HSL_COLOR_EXT          :: 1000148033;
    HSL_LUMINOSITY_EXT     :: 1000148034;
    PLUS_EXT               :: 1000148035;
    PLUS_CLAMPED_EXT       :: 1000148036;
    PLUS_CLAMPED_ALPHA_EXT :: 1000148037;
    PLUS_DARKER_EXT        :: 1000148038;
    MINUS_EXT              :: 1000148039;
    MINUS_CLAMPED_EXT      :: 1000148040;
    CONTRAST_EXT           :: 1000148041;
    INVERT_OVG_EXT         :: 1000148042;
    RED_EXT                :: 1000148043;
    GREEN_EXT              :: 1000148044;
    BLUE_EXT               :: 1000148045;
    MAX_ENUM               :: 2147483647;
}

VkCompareOp :: enum s32 {
    NEVER            :: 0;
    LESS             :: 1;
    EQUAL            :: 2;
    LESS_OR_EQUAL    :: 3;
    GREATER          :: 4;
    NOT_EQUAL        :: 5;
    GREATER_OR_EQUAL :: 6;
    ALWAYS           :: 7;
    MAX_ENUM         :: 2147483647;
}

VkDynamicState :: enum s32 {
    VIEWPORT                                :: 0;
    SCISSOR                                 :: 1;
    LINE_WIDTH                              :: 2;
    DEPTH_BIAS                              :: 3;
    BLEND_CONSTANTS                         :: 4;
    DEPTH_BOUNDS                            :: 5;
    STENCIL_COMPARE_MASK                    :: 6;
    STENCIL_WRITE_MASK                      :: 7;
    STENCIL_REFERENCE                       :: 8;
    CULL_MODE                               :: 1000267000;
    FRONT_FACE                              :: 1000267001;
    PRIMITIVE_TOPOLOGY                      :: 1000267002;
    VIEWPORT_WITH_COUNT                     :: 1000267003;
    SCISSOR_WITH_COUNT                      :: 1000267004;
    VERTEX_INPUT_BINDING_STRIDE             :: 1000267005;
    DEPTH_TEST_ENABLE                       :: 1000267006;
    DEPTH_WRITE_ENABLE                      :: 1000267007;
    DEPTH_COMPARE_OP                        :: 1000267008;
    DEPTH_BOUNDS_TEST_ENABLE                :: 1000267009;
    STENCIL_TEST_ENABLE                     :: 1000267010;
    STENCIL_OP                              :: 1000267011;
    RASTERIZER_DISCARD_ENABLE               :: 1000377001;
    DEPTH_BIAS_ENABLE                       :: 1000377002;
    PRIMITIVE_RESTART_ENABLE                :: 1000377004;
    VIEWPORT_W_SCALING_NV                   :: 1000087000;
    DISCARD_RECTANGLE_EXT                   :: 1000099000;
    DISCARD_RECTANGLE_ENABLE_EXT            :: 1000099001;
    DISCARD_RECTANGLE_MODE_EXT              :: 1000099002;
    SAMPLE_LOCATIONS_EXT                    :: 1000143000;
    RAY_TRACING_PIPELINE_STACK_SIZE_KHR     :: 1000347000;
    VIEWPORT_SHADING_RATE_PALETTE_NV        :: 1000164004;
    VIEWPORT_COARSE_SAMPLE_ORDER_NV         :: 1000164006;
    EXCLUSIVE_SCISSOR_ENABLE_NV             :: 1000205000;
    EXCLUSIVE_SCISSOR_NV                    :: 1000205001;
    FRAGMENT_SHADING_RATE_KHR               :: 1000226000;
    LINE_STIPPLE_EXT                        :: 1000259000;
    VERTEX_INPUT_EXT                        :: 1000352000;
    PATCH_CONTROL_POINTS_EXT                :: 1000377000;
    LOGIC_OP_EXT                            :: 1000377003;
    COLOR_WRITE_ENABLE_EXT                  :: 1000381000;
    TESSELLATION_DOMAIN_ORIGIN_EXT          :: 1000455002;
    DEPTH_CLAMP_ENABLE_EXT                  :: 1000455003;
    POLYGON_MODE_EXT                        :: 1000455004;
    RASTERIZATION_SAMPLES_EXT               :: 1000455005;
    SAMPLE_MASK_EXT                         :: 1000455006;
    ALPHA_TO_COVERAGE_ENABLE_EXT            :: 1000455007;
    ALPHA_TO_ONE_ENABLE_EXT                 :: 1000455008;
    LOGIC_OP_ENABLE_EXT                     :: 1000455009;
    COLOR_BLEND_ENABLE_EXT                  :: 1000455010;
    COLOR_BLEND_EQUATION_EXT                :: 1000455011;
    COLOR_WRITE_MASK_EXT                    :: 1000455012;
    RASTERIZATION_STREAM_EXT                :: 1000455013;
    CONSERVATIVE_RASTERIZATION_MODE_EXT     :: 1000455014;
    EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT :: 1000455015;
    DEPTH_CLIP_ENABLE_EXT                   :: 1000455016;
    SAMPLE_LOCATIONS_ENABLE_EXT             :: 1000455017;
    COLOR_BLEND_ADVANCED_EXT                :: 1000455018;
    PROVOKING_VERTEX_MODE_EXT               :: 1000455019;
    LINE_RASTERIZATION_MODE_EXT             :: 1000455020;
    LINE_STIPPLE_ENABLE_EXT                 :: 1000455021;
    DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT      :: 1000455022;
    VIEWPORT_W_SCALING_ENABLE_NV            :: 1000455023;
    VIEWPORT_SWIZZLE_NV                     :: 1000455024;
    COVERAGE_TO_COLOR_ENABLE_NV             :: 1000455025;
    COVERAGE_TO_COLOR_LOCATION_NV           :: 1000455026;
    COVERAGE_MODULATION_MODE_NV             :: 1000455027;
    COVERAGE_MODULATION_TABLE_ENABLE_NV     :: 1000455028;
    COVERAGE_MODULATION_TABLE_NV            :: 1000455029;
    SHADING_RATE_IMAGE_ENABLE_NV            :: 1000455030;
    REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV  :: 1000455031;
    COVERAGE_REDUCTION_MODE_NV              :: 1000455032;
    ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT     :: 1000524000;
    CULL_MODE_EXT                           :: 1000267000;
    FRONT_FACE_EXT                          :: 1000267001;
    PRIMITIVE_TOPOLOGY_EXT                  :: 1000267002;
    VIEWPORT_WITH_COUNT_EXT                 :: 1000267003;
    SCISSOR_WITH_COUNT_EXT                  :: 1000267004;
    VERTEX_INPUT_BINDING_STRIDE_EXT         :: 1000267005;
    DEPTH_TEST_ENABLE_EXT                   :: 1000267006;
    DEPTH_WRITE_ENABLE_EXT                  :: 1000267007;
    DEPTH_COMPARE_OP_EXT                    :: 1000267008;
    DEPTH_BOUNDS_TEST_ENABLE_EXT            :: 1000267009;
    STENCIL_TEST_ENABLE_EXT                 :: 1000267010;
    STENCIL_OP_EXT                          :: 1000267011;
    RASTERIZER_DISCARD_ENABLE_EXT           :: 1000377001;
    DEPTH_BIAS_ENABLE_EXT                   :: 1000377002;
    PRIMITIVE_RESTART_ENABLE_EXT            :: 1000377004;
    MAX_ENUM                                :: 2147483647;
}

VkFrontFace :: enum s32 {
    COUNTER_CLOCKWISE :: 0;
    CLOCKWISE         :: 1;
    MAX_ENUM          :: 2147483647;
}

VkVertexInputRate :: enum s32 {
    VERTEX   :: 0;
    INSTANCE :: 1;
    MAX_ENUM :: 2147483647;
}

VkPrimitiveTopology :: enum s32 {
    POINT_LIST                    :: 0;
    LINE_LIST                     :: 1;
    LINE_STRIP                    :: 2;
    TRIANGLE_LIST                 :: 3;
    TRIANGLE_STRIP                :: 4;
    TRIANGLE_FAN                  :: 5;
    LINE_LIST_WITH_ADJACENCY      :: 6;
    LINE_STRIP_WITH_ADJACENCY     :: 7;
    TRIANGLE_LIST_WITH_ADJACENCY  :: 8;
    TRIANGLE_STRIP_WITH_ADJACENCY :: 9;
    PATCH_LIST                    :: 10;
    MAX_ENUM                      :: 2147483647;
}

VkPolygonMode :: enum s32 {
    FILL              :: 0;
    LINE              :: 1;
    POINT             :: 2;
    FILL_RECTANGLE_NV :: 1000153000;
    MAX_ENUM          :: 2147483647;
}

VkStencilOp :: enum s32 {
    KEEP                :: 0;
    ZERO                :: 1;
    REPLACE             :: 2;
    INCREMENT_AND_CLAMP :: 3;
    DECREMENT_AND_CLAMP :: 4;
    INVERT              :: 5;
    INCREMENT_AND_WRAP  :: 6;
    DECREMENT_AND_WRAP  :: 7;
    MAX_ENUM            :: 2147483647;
}

VkLogicOp :: enum s32 {
    CLEAR         :: 0;
    AND           :: 1;
    AND_REVERSE   :: 2;
    COPY          :: 3;
    AND_INVERTED  :: 4;
    NO_OP         :: 5;
    XOR           :: 6;
    OR            :: 7;
    NOR           :: 8;
    EQUIVALENT    :: 9;
    INVERT        :: 10;
    OR_REVERSE    :: 11;
    COPY_INVERTED :: 12;
    OR_INVERTED   :: 13;
    NAND          :: 14;
    SET           :: 15;
    MAX_ENUM      :: 2147483647;
}

VkBorderColor :: enum s32 {
    FLOAT_TRANSPARENT_BLACK :: 0;
    INT_TRANSPARENT_BLACK   :: 1;
    FLOAT_OPAQUE_BLACK      :: 2;
    INT_OPAQUE_BLACK        :: 3;
    FLOAT_OPAQUE_WHITE      :: 4;
    INT_OPAQUE_WHITE        :: 5;
    FLOAT_CUSTOM_EXT        :: 1000287003;
    INT_CUSTOM_EXT          :: 1000287004;
    MAX_ENUM                :: 2147483647;
}

VkFilter :: enum s32 {
    NEAREST   :: 0;
    LINEAR    :: 1;
    CUBIC_EXT :: 1000015000;
    CUBIC_IMG :: 1000015000;
    MAX_ENUM  :: 2147483647;
}

VkSamplerAddressMode :: enum s32 {
    REPEAT                   :: 0;
    MIRRORED_REPEAT          :: 1;
    CLAMP_TO_EDGE            :: 2;
    CLAMP_TO_BORDER          :: 3;
    MIRROR_CLAMP_TO_EDGE     :: 4;
    MIRROR_CLAMP_TO_EDGE_KHR :: 4;
    MAX_ENUM                 :: 2147483647;
}

VkSamplerMipmapMode :: enum s32 {
    NEAREST  :: 0;
    LINEAR   :: 1;
    MAX_ENUM :: 2147483647;
}

VkDescriptorType :: enum s32 {
    SAMPLER                    :: 0;
    COMBINED_IMAGE_SAMPLER     :: 1;
    SAMPLED_IMAGE              :: 2;
    STORAGE_IMAGE              :: 3;
    UNIFORM_TEXEL_BUFFER       :: 4;
    STORAGE_TEXEL_BUFFER       :: 5;
    UNIFORM_BUFFER             :: 6;
    STORAGE_BUFFER             :: 7;
    UNIFORM_BUFFER_DYNAMIC     :: 8;
    STORAGE_BUFFER_DYNAMIC     :: 9;
    INPUT_ATTACHMENT           :: 10;
    INLINE_UNIFORM_BLOCK       :: 1000138000;
    ACCELERATION_STRUCTURE_KHR :: 1000150000;
    ACCELERATION_STRUCTURE_NV  :: 1000165000;
    SAMPLE_WEIGHT_IMAGE_QCOM   :: 1000440000;
    BLOCK_MATCH_IMAGE_QCOM     :: 1000440001;
    MUTABLE_EXT                :: 1000351000;
    INLINE_UNIFORM_BLOCK_EXT   :: 1000138000;
    MUTABLE_VALVE              :: 1000351000;
    MAX_ENUM                   :: 2147483647;
}

VkAttachmentLoadOp :: enum s32 {
    LOAD      :: 0;
    CLEAR     :: 1;
    DONT_CARE :: 2;
    NONE_EXT  :: 1000400000;
    MAX_ENUM  :: 2147483647;
}

VkAttachmentStoreOp :: enum s32 {
    STORE     :: 0;
    DONT_CARE :: 1;
    NONE      :: 1000301000;
    NONE_KHR  :: 1000301000;
    NONE_QCOM :: 1000301000;
    NONE_EXT  :: 1000301000;
    MAX_ENUM  :: 2147483647;
}

VkPipelineBindPoint :: enum s32 {
    GRAPHICS               :: 0;
    COMPUTE                :: 1;

    RAY_TRACING_KHR        :: 1000165000;
    SUBPASS_SHADING_HUAWEI :: 1000369003;
    RAY_TRACING_NV         :: 1000165000;
    MAX_ENUM               :: 2147483647;
}

VkCommandBufferLevel :: enum s32 {
    PRIMARY   :: 0;
    SECONDARY :: 1;
    MAX_ENUM  :: 2147483647;
}

VkIndexType :: enum s32 {
    UINT16    :: 0;
    UINT32    :: 1;
    NONE_KHR  :: 1000165000;
    UINT8_EXT :: 1000265000;
    NONE_NV   :: 1000165000;
    MAX_ENUM  :: 2147483647;
}

VkSubpassContents :: enum s32 {
    INLINE                                   :: 0;
    SECONDARY_COMMAND_BUFFERS                :: 1;
    INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT :: 1000451000;
    MAX_ENUM                                 :: 2147483647;
}

VkAccessFlagBits :: enum s32 {
    INDIRECT_COMMAND_READ_BIT                     :: 1;
    INDEX_READ_BIT                                :: 2;
    VERTEX_ATTRIBUTE_READ_BIT                     :: 4;
    UNIFORM_READ_BIT                              :: 8;
    INPUT_ATTACHMENT_READ_BIT                     :: 16;
    SHADER_READ_BIT                               :: 32;
    SHADER_WRITE_BIT                              :: 64;
    COLOR_ATTACHMENT_READ_BIT                     :: 128;
    COLOR_ATTACHMENT_WRITE_BIT                    :: 256;
    DEPTH_STENCIL_ATTACHMENT_READ_BIT             :: 512;
    DEPTH_STENCIL_ATTACHMENT_WRITE_BIT            :: 1024;
    TRANSFER_READ_BIT                             :: 2048;
    TRANSFER_WRITE_BIT                            :: 4096;
    HOST_READ_BIT                                 :: 8192;
    HOST_WRITE_BIT                                :: 16384;
    MEMORY_READ_BIT                               :: 32768;
    MEMORY_WRITE_BIT                              :: 65536;
    NONE                                          :: 0;
    TRANSFORM_FEEDBACK_WRITE_BIT_EXT              :: 33554432;
    TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT       :: 67108864;
    TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT      :: 134217728;
    CONDITIONAL_RENDERING_READ_BIT_EXT            :: 1048576;
    COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT     :: 524288;
    ACCELERATION_STRUCTURE_READ_BIT_KHR           :: 2097152;
    ACCELERATION_STRUCTURE_WRITE_BIT_KHR          :: 4194304;
    FRAGMENT_DENSITY_MAP_READ_BIT_EXT             :: 16777216;
    FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR :: 8388608;
    COMMAND_PREPROCESS_READ_BIT_NV                :: 131072;
    COMMAND_PREPROCESS_WRITE_BIT_NV               :: 262144;
    SHADING_RATE_IMAGE_READ_BIT_NV                :: 8388608;
    ACCELERATION_STRUCTURE_READ_BIT_NV            :: 2097152;
    ACCELERATION_STRUCTURE_WRITE_BIT_NV           :: 4194304;
    NONE_KHR                                      :: 0;
    FLAG_BITS_MAX_ENUM                            :: 2147483647;
}

VkAccessFlags :: VkFlags;

VkImageAspectFlagBits :: enum s32 {
    COLOR_BIT              :: 1;
    DEPTH_BIT              :: 2;
    STENCIL_BIT            :: 4;
    METADATA_BIT           :: 8;
    PLANE_0_BIT            :: 16;
    PLANE_1_BIT            :: 32;
    PLANE_2_BIT            :: 64;
    NONE                   :: 0;
    MEMORY_PLANE_0_BIT_EXT :: 128;
    MEMORY_PLANE_1_BIT_EXT :: 256;
    MEMORY_PLANE_2_BIT_EXT :: 512;
    MEMORY_PLANE_3_BIT_EXT :: 1024;
    PLANE_0_BIT_KHR        :: 16;
    PLANE_1_BIT_KHR        :: 32;
    PLANE_2_BIT_KHR        :: 64;
    NONE_KHR               :: 0;
    FLAG_BITS_MAX_ENUM     :: 2147483647;
}

VkImageAspectFlags :: VkFlags;

VkFormatFeatureFlagBits :: enum s32 {
    SAMPLED_IMAGE_BIT                                                               :: 1;
    STORAGE_IMAGE_BIT                                                               :: 2;
    STORAGE_IMAGE_ATOMIC_BIT                                                        :: 4;
    UNIFORM_TEXEL_BUFFER_BIT                                                        :: 8;
    STORAGE_TEXEL_BUFFER_BIT                                                        :: 16;
    STORAGE_TEXEL_BUFFER_ATOMIC_BIT                                                 :: 32;
    VERTEX_BUFFER_BIT                                                               :: 64;
    COLOR_ATTACHMENT_BIT                                                            :: 128;
    COLOR_ATTACHMENT_BLEND_BIT                                                      :: 256;
    DEPTH_STENCIL_ATTACHMENT_BIT                                                    :: 512;
    BLIT_SRC_BIT                                                                    :: 1024;
    BLIT_DST_BIT                                                                    :: 2048;
    SAMPLED_IMAGE_FILTER_LINEAR_BIT                                                 :: 4096;
    TRANSFER_SRC_BIT                                                                :: 16384;
    TRANSFER_DST_BIT                                                                :: 32768;
    MIDPOINT_CHROMA_SAMPLES_BIT                                                     :: 131072;
    SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT                                :: 262144;
    SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT               :: 524288;
    SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT               :: 1048576;
    SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT     :: 2097152;
    DISJOINT_BIT                                                                    :: 4194304;
    COSITED_CHROMA_SAMPLES_BIT                                                      :: 8388608;
    SAMPLED_IMAGE_FILTER_MINMAX_BIT                                                 :: 65536;
    VIDEO_DECODE_OUTPUT_BIT_KHR                                                     :: 33554432;
    VIDEO_DECODE_DPB_BIT_KHR                                                        :: 67108864;
    ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR                                    :: 536870912;
    SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT                                              :: 8192;
    FRAGMENT_DENSITY_MAP_BIT_EXT                                                    :: 16777216;
    FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR                                        :: 1073741824;

    SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG                                              :: 8192;
    TRANSFER_SRC_BIT_KHR                                                            :: 16384;
    TRANSFER_DST_BIT_KHR                                                            :: 32768;
    SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT                                             :: 65536;
    MIDPOINT_CHROMA_SAMPLES_BIT_KHR                                                 :: 131072;
    SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR                            :: 262144;
    SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR           :: 524288;
    SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR           :: 1048576;
    SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR :: 2097152;
    DISJOINT_BIT_KHR                                                                :: 4194304;
    COSITED_CHROMA_SAMPLES_BIT_KHR                                                  :: 8388608;
    FLAG_BITS_MAX_ENUM                                                              :: 2147483647;
}

VkFormatFeatureFlags :: VkFlags;

VkImageCreateFlagBits :: enum s32 {
    SPARSE_BINDING_BIT                            :: 1;
    SPARSE_RESIDENCY_BIT                          :: 2;
    SPARSE_ALIASED_BIT                            :: 4;
    MUTABLE_FORMAT_BIT                            :: 8;
    CUBE_COMPATIBLE_BIT                           :: 16;
    ALIAS_BIT                                     :: 1024;
    SPLIT_INSTANCE_BIND_REGIONS_BIT               :: 64;
    _2D_ARRAY_COMPATIBLE_BIT                      :: 32;
    BLOCK_TEXEL_VIEW_COMPATIBLE_BIT               :: 128;
    EXTENDED_USAGE_BIT                            :: 256;
    PROTECTED_BIT                                 :: 2048;
    DISJOINT_BIT                                  :: 512;
    CORNER_SAMPLED_BIT_NV                         :: 8192;
    SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT     :: 4096;
    SUBSAMPLED_BIT_EXT                            :: 16384;
    DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT      :: 65536;
    MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT :: 262144;
    _2D_VIEW_COMPATIBLE_BIT_EXT                   :: 131072;
    FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM          :: 32768;
    SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR           :: 64;
    _2D_ARRAY_COMPATIBLE_BIT_KHR                  :: 32;
    BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR           :: 128;
    EXTENDED_USAGE_BIT_KHR                        :: 256;
    DISJOINT_BIT_KHR                              :: 512;
    ALIAS_BIT_KHR                                 :: 1024;
    FLAG_BITS_MAX_ENUM                            :: 2147483647;
}

VkImageCreateFlags :: VkFlags;

VkSampleCountFlagBits :: enum s32 {
    _1_BIT             :: 1;
    _2_BIT             :: 2;
    _4_BIT             :: 4;
    _8_BIT             :: 8;
    _16_BIT            :: 16;
    _32_BIT            :: 32;
    _64_BIT            :: 64;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkSampleCountFlags :: VkFlags;

VkImageUsageFlagBits :: enum s32 {
    TRANSFER_SRC_BIT                         :: 1;
    TRANSFER_DST_BIT                         :: 2;
    SAMPLED_BIT                              :: 4;
    STORAGE_BIT                              :: 8;
    COLOR_ATTACHMENT_BIT                     :: 16;
    DEPTH_STENCIL_ATTACHMENT_BIT             :: 32;
    TRANSIENT_ATTACHMENT_BIT                 :: 64;
    INPUT_ATTACHMENT_BIT                     :: 128;
    VIDEO_DECODE_DST_BIT_KHR                 :: 1024;
    VIDEO_DECODE_SRC_BIT_KHR                 :: 2048;
    VIDEO_DECODE_DPB_BIT_KHR                 :: 4096;
    FRAGMENT_DENSITY_MAP_BIT_EXT             :: 512;
    FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR :: 256;
    HOST_TRANSFER_BIT_EXT                    :: 4194304;

    ATTACHMENT_FEEDBACK_LOOP_BIT_EXT         :: 524288;
    INVOCATION_MASK_BIT_HUAWEI               :: 262144;
    SAMPLE_WEIGHT_BIT_QCOM                   :: 1048576;
    SAMPLE_BLOCK_MATCH_BIT_QCOM              :: 2097152;
    SHADING_RATE_IMAGE_BIT_NV                :: 256;
    FLAG_BITS_MAX_ENUM                       :: 2147483647;
}

VkImageUsageFlags :: VkFlags;

VkInstanceCreateFlagBits :: enum s32 {
    ENUMERATE_PORTABILITY_BIT_KHR :: 1;
    FLAG_BITS_MAX_ENUM            :: 2147483647;
}

VkInstanceCreateFlags :: VkFlags;

VkMemoryHeapFlagBits :: enum s32 {
    DEVICE_LOCAL_BIT       :: 1;
    MULTI_INSTANCE_BIT     :: 2;
    MULTI_INSTANCE_BIT_KHR :: 2;
    FLAG_BITS_MAX_ENUM     :: 2147483647;
}

VkMemoryHeapFlags :: VkFlags;

VkMemoryPropertyFlagBits :: enum s32 {
    DEVICE_LOCAL_BIT        :: 1;
    HOST_VISIBLE_BIT        :: 2;
    HOST_COHERENT_BIT       :: 4;
    HOST_CACHED_BIT         :: 8;
    LAZILY_ALLOCATED_BIT    :: 16;
    PROTECTED_BIT           :: 32;
    DEVICE_COHERENT_BIT_AMD :: 64;
    DEVICE_UNCACHED_BIT_AMD :: 128;
    RDMA_CAPABLE_BIT_NV     :: 256;
    FLAG_BITS_MAX_ENUM      :: 2147483647;
}

VkMemoryPropertyFlags :: VkFlags;

VkQueueFlagBits :: enum s32 {
    GRAPHICS_BIT         :: 1;
    COMPUTE_BIT          :: 2;
    TRANSFER_BIT         :: 4;
    SPARSE_BINDING_BIT   :: 8;
    PROTECTED_BIT        :: 16;
    VIDEO_DECODE_BIT_KHR :: 32;

    OPTICAL_FLOW_BIT_NV  :: 256;
    FLAG_BITS_MAX_ENUM   :: 2147483647;
}

VkQueueFlags :: VkFlags;
VkDeviceCreateFlags :: VkFlags;

VkDeviceQueueCreateFlagBits :: enum s32 {
    PROTECTED_BIT      :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkDeviceQueueCreateFlags :: VkFlags;

VkPipelineStageFlagBits :: enum s32 {
    TOP_OF_PIPE_BIT                          :: 1;
    DRAW_INDIRECT_BIT                        :: 2;
    VERTEX_INPUT_BIT                         :: 4;
    VERTEX_SHADER_BIT                        :: 8;
    TESSELLATION_CONTROL_SHADER_BIT          :: 16;
    TESSELLATION_EVALUATION_SHADER_BIT       :: 32;
    GEOMETRY_SHADER_BIT                      :: 64;
    FRAGMENT_SHADER_BIT                      :: 128;
    EARLY_FRAGMENT_TESTS_BIT                 :: 256;
    LATE_FRAGMENT_TESTS_BIT                  :: 512;
    COLOR_ATTACHMENT_OUTPUT_BIT              :: 1024;
    COMPUTE_SHADER_BIT                       :: 2048;
    TRANSFER_BIT                             :: 4096;
    BOTTOM_OF_PIPE_BIT                       :: 8192;
    HOST_BIT                                 :: 16384;
    ALL_GRAPHICS_BIT                         :: 32768;
    ALL_COMMANDS_BIT                         :: 65536;
    NONE                                     :: 0;
    TRANSFORM_FEEDBACK_BIT_EXT               :: 16777216;
    CONDITIONAL_RENDERING_BIT_EXT            :: 262144;
    ACCELERATION_STRUCTURE_BUILD_BIT_KHR     :: 33554432;
    RAY_TRACING_SHADER_BIT_KHR               :: 2097152;
    FRAGMENT_DENSITY_PROCESS_BIT_EXT         :: 8388608;
    FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR :: 4194304;
    COMMAND_PREPROCESS_BIT_NV                :: 131072;
    TASK_SHADER_BIT_EXT                      :: 524288;
    MESH_SHADER_BIT_EXT                      :: 1048576;
    SHADING_RATE_IMAGE_BIT_NV                :: 4194304;
    RAY_TRACING_SHADER_BIT_NV                :: 2097152;
    ACCELERATION_STRUCTURE_BUILD_BIT_NV      :: 33554432;
    TASK_SHADER_BIT_NV                       :: 524288;
    MESH_SHADER_BIT_NV                       :: 1048576;
    NONE_KHR                                 :: 0;
    FLAG_BITS_MAX_ENUM                       :: 2147483647;
}

VkPipelineStageFlags :: VkFlags;
VkMemoryMapFlags :: VkFlags;

VkSparseMemoryBindFlagBits :: enum s32 {
    METADATA_BIT       :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkSparseMemoryBindFlags :: VkFlags;

VkSparseImageFormatFlagBits :: enum s32 {
    SINGLE_MIPTAIL_BIT         :: 1;
    ALIGNED_MIP_SIZE_BIT       :: 2;
    NONSTANDARD_BLOCK_SIZE_BIT :: 4;
    FLAG_BITS_MAX_ENUM         :: 2147483647;
}

VkSparseImageFormatFlags :: VkFlags;

VkFenceCreateFlagBits :: enum s32 {
    SIGNALED_BIT       :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkFenceCreateFlags :: VkFlags;
VkSemaphoreCreateFlags :: VkFlags;

VkEventCreateFlagBits :: enum s32 {
    DEVICE_ONLY_BIT     :: 1;
    DEVICE_ONLY_BIT_KHR :: 1;
    FLAG_BITS_MAX_ENUM  :: 2147483647;
}

VkEventCreateFlags :: VkFlags;

VkQueryPipelineStatisticFlagBits :: enum s32 {
    INPUT_ASSEMBLY_VERTICES_BIT                    :: 1;
    INPUT_ASSEMBLY_PRIMITIVES_BIT                  :: 2;
    VERTEX_SHADER_INVOCATIONS_BIT                  :: 4;
    GEOMETRY_SHADER_INVOCATIONS_BIT                :: 8;
    GEOMETRY_SHADER_PRIMITIVES_BIT                 :: 16;
    CLIPPING_INVOCATIONS_BIT                       :: 32;
    CLIPPING_PRIMITIVES_BIT                        :: 64;
    FRAGMENT_SHADER_INVOCATIONS_BIT                :: 128;
    TESSELLATION_CONTROL_SHADER_PATCHES_BIT        :: 256;
    TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT :: 512;
    COMPUTE_SHADER_INVOCATIONS_BIT                 :: 1024;
    TASK_SHADER_INVOCATIONS_BIT_EXT                :: 2048;
    MESH_SHADER_INVOCATIONS_BIT_EXT                :: 4096;
    CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI  :: 8192;
    FLAG_BITS_MAX_ENUM                             :: 2147483647;
}

VkQueryPipelineStatisticFlags :: VkFlags;
VkQueryPoolCreateFlags :: VkFlags;

VkQueryResultFlagBits :: enum s32 {
    _64_BIT               :: 1;
    WAIT_BIT              :: 2;
    WITH_AVAILABILITY_BIT :: 4;
    PARTIAL_BIT           :: 8;
    WITH_STATUS_BIT_KHR   :: 16;
    FLAG_BITS_MAX_ENUM    :: 2147483647;
}

VkQueryResultFlags :: VkFlags;

VkBufferCreateFlagBits :: enum s32 {
    SPARSE_BINDING_BIT                       :: 1;
    SPARSE_RESIDENCY_BIT                     :: 2;
    SPARSE_ALIASED_BIT                       :: 4;
    PROTECTED_BIT                            :: 8;
    DEVICE_ADDRESS_CAPTURE_REPLAY_BIT        :: 16;
    DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT :: 32;
    DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT    :: 16;
    DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR    :: 16;
    FLAG_BITS_MAX_ENUM                       :: 2147483647;
}

VkBufferCreateFlags :: VkFlags;

VkBufferUsageFlagBits :: enum s32 {
    TRANSFER_SRC_BIT                                     :: 1;
    TRANSFER_DST_BIT                                     :: 2;
    UNIFORM_TEXEL_BUFFER_BIT                             :: 4;
    STORAGE_TEXEL_BUFFER_BIT                             :: 8;
    UNIFORM_BUFFER_BIT                                   :: 16;
    STORAGE_BUFFER_BIT                                   :: 32;
    INDEX_BUFFER_BIT                                     :: 64;
    VERTEX_BUFFER_BIT                                    :: 128;
    INDIRECT_BUFFER_BIT                                  :: 256;
    SHADER_DEVICE_ADDRESS_BIT                            :: 131072;
    VIDEO_DECODE_SRC_BIT_KHR                             :: 8192;
    VIDEO_DECODE_DST_BIT_KHR                             :: 16384;
    TRANSFORM_FEEDBACK_BUFFER_BIT_EXT                    :: 2048;
    TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT            :: 4096;
    CONDITIONAL_RENDERING_BIT_EXT                        :: 512;

    ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR :: 524288;
    ACCELERATION_STRUCTURE_STORAGE_BIT_KHR               :: 1048576;
    SHADER_BINDING_TABLE_BIT_KHR                         :: 1024;

    SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT                    :: 2097152;
    RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT                   :: 4194304;
    PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT           :: 67108864;
    MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT               :: 8388608;
    MICROMAP_STORAGE_BIT_EXT                             :: 16777216;
    RAY_TRACING_BIT_NV                                   :: 1024;
    SHADER_DEVICE_ADDRESS_BIT_EXT                        :: 131072;
    SHADER_DEVICE_ADDRESS_BIT_KHR                        :: 131072;
    FLAG_BITS_MAX_ENUM                                   :: 2147483647;
}

VkBufferUsageFlags :: VkFlags;
VkBufferViewCreateFlags :: VkFlags;

VkImageViewCreateFlagBits :: enum s32 {
    FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT     :: 1;
    DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT :: 4;
    FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT    :: 2;
    FLAG_BITS_MAX_ENUM                       :: 2147483647;
}

VkImageViewCreateFlags :: VkFlags;
VkShaderModuleCreateFlags :: VkFlags;

VkPipelineCacheCreateFlagBits :: enum s32 {
    EXTERNALLY_SYNCHRONIZED_BIT     :: 1;
    EXTERNALLY_SYNCHRONIZED_BIT_EXT :: 1;
    FLAG_BITS_MAX_ENUM              :: 2147483647;
}

VkPipelineCacheCreateFlags :: VkFlags;

VkColorComponentFlagBits :: enum s32 {
    R_BIT              :: 1;
    G_BIT              :: 2;
    B_BIT              :: 4;
    A_BIT              :: 8;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkColorComponentFlags :: VkFlags;

VkPipelineCreateFlagBits :: enum s32 {
    CREATE_DISABLE_OPTIMIZATION_BIT                                     :: 1;
    CREATE_ALLOW_DERIVATIVES_BIT                                        :: 2;
    CREATE_DERIVATIVE_BIT                                               :: 4;
    CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT                             :: 8;
    CREATE_DISPATCH_BASE_BIT                                            :: 16;
    CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT                        :: 256;
    CREATE_EARLY_RETURN_ON_FAILURE_BIT                                  :: 512;
    CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR           :: 2097152;
    CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT            :: 4194304;
    CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR                  :: 16384;
    CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR              :: 32768;
    CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR                     :: 65536;
    CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR             :: 131072;
    CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR                           :: 4096;
    CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR                               :: 8192;
    CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR       :: 524288;
    CREATE_DEFER_COMPILE_BIT_NV                                         :: 32;
    CREATE_CAPTURE_STATISTICS_BIT_KHR                                   :: 64;
    CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR                     :: 128;
    CREATE_INDIRECT_BINDABLE_BIT_NV                                     :: 262144;
    CREATE_LIBRARY_BIT_KHR                                              :: 2048;
    CREATE_DESCRIPTOR_BUFFER_BIT_EXT                                    :: 536870912;
    CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT                   :: 8388608;
    CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT                               :: 1024;
    CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV                              :: 1048576;
    CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT                       :: 33554432;
    CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT               :: 67108864;
    CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT                         :: 16777216;

    CREATE_NO_PROTECTED_ACCESS_BIT_EXT                                  :: 134217728;
    CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT                                :: 1073741824;
    CREATE_DISPATCH_BASE                                                :: 16;
    RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR :: 2097152;
    RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT  :: 4194304;
    CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR                         :: 8;
    CREATE_DISPATCH_BASE_KHR                                            :: 16;
    CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT                    :: 256;
    CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT                              :: 512;
    CREATE_FLAG_BITS_MAX_ENUM                                           :: 2147483647;
}

VkPipelineCreateFlags :: VkFlags;

VkPipelineShaderStageCreateFlagBits :: enum s32 {
    ALLOW_VARYING_SUBGROUP_SIZE_BIT     :: 1;
    REQUIRE_FULL_SUBGROUPS_BIT          :: 2;
    ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT :: 1;
    REQUIRE_FULL_SUBGROUPS_BIT_EXT      :: 2;
    FLAG_BITS_MAX_ENUM                  :: 2147483647;
}

VkPipelineShaderStageCreateFlags :: VkFlags;

VkShaderStageFlagBits :: enum s32 {
    VERTEX_BIT                  :: 1;
    TESSELLATION_CONTROL_BIT    :: 2;
    TESSELLATION_EVALUATION_BIT :: 4;
    GEOMETRY_BIT                :: 8;
    FRAGMENT_BIT                :: 16;
    COMPUTE_BIT                 :: 32;
    ALL_GRAPHICS                :: 31;
    ALL                         :: 2147483647;
    RAYGEN_BIT_KHR              :: 256;
    ANY_HIT_BIT_KHR             :: 512;
    CLOSEST_HIT_BIT_KHR         :: 1024;
    MISS_BIT_KHR                :: 2048;
    INTERSECTION_BIT_KHR        :: 4096;
    CALLABLE_BIT_KHR            :: 8192;
    TASK_BIT_EXT                :: 64;
    MESH_BIT_EXT                :: 128;
    SUBPASS_SHADING_BIT_HUAWEI  :: 16384;
    CLUSTER_CULLING_BIT_HUAWEI  :: 524288;
    RAYGEN_BIT_NV               :: 256;
    ANY_HIT_BIT_NV              :: 512;
    CLOSEST_HIT_BIT_NV          :: 1024;
    MISS_BIT_NV                 :: 2048;
    INTERSECTION_BIT_NV         :: 4096;
    CALLABLE_BIT_NV             :: 8192;
    TASK_BIT_NV                 :: 64;
    MESH_BIT_NV                 :: 128;
    FLAG_BITS_MAX_ENUM          :: 2147483647;
}

VkCullModeFlagBits :: enum s32 {
    NONE               :: 0;
    FRONT_BIT          :: 1;
    BACK_BIT           :: 2;
    FRONT_AND_BACK     :: 3;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkCullModeFlags :: VkFlags;
VkPipelineVertexInputStateCreateFlags :: VkFlags;
VkPipelineInputAssemblyStateCreateFlags :: VkFlags;
VkPipelineTessellationStateCreateFlags :: VkFlags;
VkPipelineViewportStateCreateFlags :: VkFlags;
VkPipelineRasterizationStateCreateFlags :: VkFlags;
VkPipelineMultisampleStateCreateFlags :: VkFlags;

VkPipelineDepthStencilStateCreateFlagBits :: enum s32 {
    RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT   :: 1;
    RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT :: 2;
    RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM   :: 1;
    RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM :: 2;
    FLAG_BITS_MAX_ENUM                                    :: 2147483647;
}

VkPipelineDepthStencilStateCreateFlags :: VkFlags;

VkPipelineColorBlendStateCreateFlagBits :: enum s32 {
    RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT :: 1;
    RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM :: 1;
    FLAG_BITS_MAX_ENUM                            :: 2147483647;
}

VkPipelineColorBlendStateCreateFlags :: VkFlags;
VkPipelineDynamicStateCreateFlags :: VkFlags;

VkPipelineLayoutCreateFlagBits :: enum s32 {
    INDEPENDENT_SETS_BIT_EXT :: 2;
    FLAG_BITS_MAX_ENUM       :: 2147483647;
}

VkPipelineLayoutCreateFlags :: VkFlags;
VkShaderStageFlags :: VkFlags;

VkSamplerCreateFlagBits :: enum s32 {
    SUBSAMPLED_BIT_EXT                       :: 1;
    SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT :: 2;
    DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT :: 8;
    NON_SEAMLESS_CUBE_MAP_BIT_EXT            :: 4;
    IMAGE_PROCESSING_BIT_QCOM                :: 16;
    FLAG_BITS_MAX_ENUM                       :: 2147483647;
}

VkSamplerCreateFlags :: VkFlags;

VkDescriptorPoolCreateFlagBits :: enum s32 {
    FREE_DESCRIPTOR_SET_BIT           :: 1;
    UPDATE_AFTER_BIND_BIT             :: 2;
    HOST_ONLY_BIT_EXT                 :: 4;
    ALLOW_OVERALLOCATION_SETS_BIT_NV  :: 8;
    ALLOW_OVERALLOCATION_POOLS_BIT_NV :: 16;
    UPDATE_AFTER_BIND_BIT_EXT         :: 2;
    HOST_ONLY_BIT_VALVE               :: 4;
    FLAG_BITS_MAX_ENUM                :: 2147483647;
}

VkDescriptorPoolCreateFlags :: VkFlags;
VkDescriptorPoolResetFlags :: VkFlags;

VkDescriptorSetLayoutCreateFlagBits :: enum s32 {
    UPDATE_AFTER_BIND_POOL_BIT          :: 2;
    PUSH_DESCRIPTOR_BIT_KHR             :: 1;
    DESCRIPTOR_BUFFER_BIT_EXT           :: 16;
    EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT :: 32;
    INDIRECT_BINDABLE_BIT_NV            :: 128;
    HOST_ONLY_POOL_BIT_EXT              :: 4;
    UPDATE_AFTER_BIND_POOL_BIT_EXT      :: 2;
    HOST_ONLY_POOL_BIT_VALVE            :: 4;
    FLAG_BITS_MAX_ENUM                  :: 2147483647;
}

VkDescriptorSetLayoutCreateFlags :: VkFlags;

VkAttachmentDescriptionFlagBits :: enum s32 {
    MAY_ALIAS_BIT      :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkAttachmentDescriptionFlags :: VkFlags;

VkDependencyFlagBits :: enum s32 {
    BY_REGION_BIT         :: 1;
    DEVICE_GROUP_BIT      :: 4;
    VIEW_LOCAL_BIT        :: 2;
    FEEDBACK_LOOP_BIT_EXT :: 8;
    VIEW_LOCAL_BIT_KHR    :: 2;
    DEVICE_GROUP_BIT_KHR  :: 4;
    FLAG_BITS_MAX_ENUM    :: 2147483647;
}

VkDependencyFlags :: VkFlags;

VkFramebufferCreateFlagBits :: enum s32 {
    IMAGELESS_BIT      :: 1;
    IMAGELESS_BIT_KHR  :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkFramebufferCreateFlags :: VkFlags;

VkRenderPassCreateFlagBits :: enum s32 {
    TRANSFORM_BIT_QCOM :: 2;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkRenderPassCreateFlags :: VkFlags;

VkSubpassDescriptionFlagBits :: enum s32 {
    PER_VIEW_ATTRIBUTES_BIT_NVX                           :: 1;
    PER_VIEW_POSITION_X_ONLY_BIT_NVX                      :: 2;
    FRAGMENT_REGION_BIT_QCOM                              :: 4;
    SHADER_RESOLVE_BIT_QCOM                               :: 8;
    RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT   :: 16;
    RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT   :: 32;
    RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT :: 64;
    ENABLE_LEGACY_DITHERING_BIT_EXT                       :: 128;
    RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM   :: 16;
    RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM   :: 32;
    RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM :: 64;
    FLAG_BITS_MAX_ENUM                                    :: 2147483647;
}

VkSubpassDescriptionFlags :: VkFlags;

VkCommandPoolCreateFlagBits :: enum s32 {
    TRANSIENT_BIT            :: 1;
    RESET_COMMAND_BUFFER_BIT :: 2;
    PROTECTED_BIT            :: 4;
    FLAG_BITS_MAX_ENUM       :: 2147483647;
}

VkCommandPoolCreateFlags :: VkFlags;

VkCommandPoolResetFlagBits :: enum s32 {
    RELEASE_RESOURCES_BIT :: 1;
    FLAG_BITS_MAX_ENUM    :: 2147483647;
}

VkCommandPoolResetFlags :: VkFlags;

VkCommandBufferUsageFlagBits :: enum s32 {
    ONE_TIME_SUBMIT_BIT      :: 1;
    RENDER_PASS_CONTINUE_BIT :: 2;
    SIMULTANEOUS_USE_BIT     :: 4;
    FLAG_BITS_MAX_ENUM       :: 2147483647;
}

VkCommandBufferUsageFlags :: VkFlags;

VkQueryControlFlagBits :: enum s32 {
    PRECISE_BIT        :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkQueryControlFlags :: VkFlags;

VkCommandBufferResetFlagBits :: enum s32 {
    RELEASE_RESOURCES_BIT :: 1;
    FLAG_BITS_MAX_ENUM    :: 2147483647;
}

VkCommandBufferResetFlags :: VkFlags;

VkStencilFaceFlagBits :: enum s32 {
    FACE_FRONT_BIT          :: 1;
    FACE_BACK_BIT           :: 2;
    FACE_FRONT_AND_BACK     :: 3;
    FRONT_AND_BACK          :: 3;
    FACE_FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkStencilFaceFlags :: VkFlags;
VkExtent2D :: struct {
    width:  u32;
    height: u32;
}

VkExtent3D :: struct {
    width:  u32;
    height: u32;
    depth:  u32;
}

VkOffset2D :: struct {
    x: s32;
    y: s32;
}

VkOffset3D :: struct {
    x: s32;
    y: s32;
    z: s32;
}

VkRect2D :: struct {
    offset: VkOffset2D;
    extent: VkExtent2D;
}

VkBaseInStructure :: struct {
    sType: VkStructureType;
    pNext: *VkBaseInStructure;
}

VkBaseOutStructure :: struct {
    sType: VkStructureType;
    pNext: *VkBaseOutStructure;
}

VkBufferMemoryBarrier :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    srcAccessMask:       VkAccessFlags;
    dstAccessMask:       VkAccessFlags;
    srcQueueFamilyIndex: u32;
    dstQueueFamilyIndex: u32;
    buffer:              VkBuffer;
    offset:              VkDeviceSize;
    size:                VkDeviceSize;
}

VkDispatchIndirectCommand :: struct {
    x: u32;
    y: u32;
    z: u32;
}

VkDrawIndexedIndirectCommand :: struct {
    indexCount:    u32;
    instanceCount: u32;
    firstIndex:    u32;
    vertexOffset:  s32;
    firstInstance: u32;
}

VkDrawIndirectCommand :: struct {
    vertexCount:   u32;
    instanceCount: u32;
    firstVertex:   u32;
    firstInstance: u32;
}

VkImageSubresourceRange :: struct {
    aspectMask:     VkImageAspectFlags;
    baseMipLevel:   u32;
    levelCount:     u32;
    baseArrayLayer: u32;
    layerCount:     u32;
}

VkImageMemoryBarrier :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    srcAccessMask:       VkAccessFlags;
    dstAccessMask:       VkAccessFlags;
    oldLayout:           VkImageLayout;
    newLayout:           VkImageLayout;
    srcQueueFamilyIndex: u32;
    dstQueueFamilyIndex: u32;
    image:               VkImage;
    subresourceRange:    VkImageSubresourceRange;
}

VkMemoryBarrier :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    srcAccessMask: VkAccessFlags;
    dstAccessMask: VkAccessFlags;
}

VkPipelineCacheHeaderVersionOne :: struct {
    headerSize:        u32;
    headerVersion:     VkPipelineCacheHeaderVersion;
    vendorID:          u32;
    deviceID:          u32;
    pipelineCacheUUID: [16] u8;
}

PFN_vkAllocationFunction :: #type (pUserData: *void, size: u64, alignment: u64, allocationScope: VkSystemAllocationScope) -> *void #c_call;

PFN_vkFreeFunction :: #type (pUserData: *void, pMemory: *void) -> void #c_call;

PFN_vkInternalAllocationNotification :: #type (pUserData: *void, size: u64, allocationType: VkInternalAllocationType, allocationScope: VkSystemAllocationScope) -> void #c_call;

PFN_vkInternalFreeNotification :: #type (pUserData: *void, size: u64, allocationType: VkInternalAllocationType, allocationScope: VkSystemAllocationScope) -> void #c_call;

PFN_vkReallocationFunction :: #type (pUserData: *void, pOriginal: *void, size: u64, alignment: u64, allocationScope: VkSystemAllocationScope) -> *void #c_call;

PFN_vkVoidFunction :: #type () -> void #c_call;
VkAllocationCallbacks :: struct {
    pUserData:             *void;
    pfnAllocation:         PFN_vkAllocationFunction;
    pfnReallocation:       PFN_vkReallocationFunction;
    pfnFree:               PFN_vkFreeFunction;
    pfnInternalAllocation: PFN_vkInternalAllocationNotification;
    pfnInternalFree:       PFN_vkInternalFreeNotification;
}

VkApplicationInfo :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    pApplicationName:   *u8;
    applicationVersion: u32;
    pEngineName:        *u8;
    engineVersion:      u32;
    apiVersion:         u32;
}

VkFormatProperties :: struct {
    linearTilingFeatures:  VkFormatFeatureFlags;
    optimalTilingFeatures: VkFormatFeatureFlags;
    bufferFeatures:        VkFormatFeatureFlags;
}

VkImageFormatProperties :: struct {
    maxExtent:       VkExtent3D;
    maxMipLevels:    u32;
    maxArrayLayers:  u32;
    sampleCounts:    VkSampleCountFlags;
    maxResourceSize: VkDeviceSize;
}

VkInstanceCreateInfo :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    flags:                   VkInstanceCreateFlags;
    pApplicationInfo:        *VkApplicationInfo;
    enabledLayerCount:       u32;
    ppEnabledLayerNames:     **u8;
    enabledExtensionCount:   u32;
    ppEnabledExtensionNames: **u8;
}

VkMemoryHeap :: struct {
    size:  VkDeviceSize;
    flags: VkMemoryHeapFlags;
}

VkMemoryType :: struct {
    propertyFlags: VkMemoryPropertyFlags;
    heapIndex:     u32;
}

VkPhysicalDeviceFeatures :: struct {
    robustBufferAccess:                      VkBool32;
    fullDrawIndexUint32:                     VkBool32;
    imageCubeArray:                          VkBool32;
    independentBlend:                        VkBool32;
    geometryShader:                          VkBool32;
    tessellationShader:                      VkBool32;
    sampleRateShading:                       VkBool32;
    dualSrcBlend:                            VkBool32;
    logicOp:                                 VkBool32;
    multiDrawIndirect:                       VkBool32;
    drawIndirectFirstInstance:               VkBool32;
    depthClamp:                              VkBool32;
    depthBiasClamp:                          VkBool32;
    fillModeNonSolid:                        VkBool32;
    depthBounds:                             VkBool32;
    wideLines:                               VkBool32;
    largePoints:                             VkBool32;
    alphaToOne:                              VkBool32;
    multiViewport:                           VkBool32;
    samplerAnisotropy:                       VkBool32;
    textureCompressionETC2:                  VkBool32;
    textureCompressionASTC_LDR:              VkBool32;
    textureCompressionBC:                    VkBool32;
    occlusionQueryPrecise:                   VkBool32;
    pipelineStatisticsQuery:                 VkBool32;
    vertexPipelineStoresAndAtomics:          VkBool32;
    fragmentStoresAndAtomics:                VkBool32;
    shaderTessellationAndGeometryPointSize:  VkBool32;
    shaderImageGatherExtended:               VkBool32;
    shaderStorageImageExtendedFormats:       VkBool32;
    shaderStorageImageMultisample:           VkBool32;
    shaderStorageImageReadWithoutFormat:     VkBool32;
    shaderStorageImageWriteWithoutFormat:    VkBool32;
    shaderUniformBufferArrayDynamicIndexing: VkBool32;
    shaderSampledImageArrayDynamicIndexing:  VkBool32;
    shaderStorageBufferArrayDynamicIndexing: VkBool32;
    shaderStorageImageArrayDynamicIndexing:  VkBool32;
    shaderClipDistance:                      VkBool32;
    shaderCullDistance:                      VkBool32;
    shaderFloat64:                           VkBool32;
    shaderInt64:                             VkBool32;
    shaderInt16:                             VkBool32;
    shaderResourceResidency:                 VkBool32;
    shaderResourceMinLod:                    VkBool32;
    sparseBinding:                           VkBool32;
    sparseResidencyBuffer:                   VkBool32;
    sparseResidencyImage2D:                  VkBool32;
    sparseResidencyImage3D:                  VkBool32;
    sparseResidency2Samples:                 VkBool32;
    sparseResidency4Samples:                 VkBool32;
    sparseResidency8Samples:                 VkBool32;
    sparseResidency16Samples:                VkBool32;
    sparseResidencyAliased:                  VkBool32;
    variableMultisampleRate:                 VkBool32;
    inheritedQueries:                        VkBool32;
}

VkPhysicalDeviceLimits :: struct {
    maxImageDimension1D:                             u32;
    maxImageDimension2D:                             u32;
    maxImageDimension3D:                             u32;
    maxImageDimensionCube:                           u32;
    maxImageArrayLayers:                             u32;
    maxTexelBufferElements:                          u32;
    maxUniformBufferRange:                           u32;
    maxStorageBufferRange:                           u32;
    maxPushConstantsSize:                            u32;
    maxMemoryAllocationCount:                        u32;
    maxSamplerAllocationCount:                       u32;
    bufferImageGranularity:                          VkDeviceSize;
    sparseAddressSpaceSize:                          VkDeviceSize;
    maxBoundDescriptorSets:                          u32;
    maxPerStageDescriptorSamplers:                   u32;
    maxPerStageDescriptorUniformBuffers:             u32;
    maxPerStageDescriptorStorageBuffers:             u32;
    maxPerStageDescriptorSampledImages:              u32;
    maxPerStageDescriptorStorageImages:              u32;
    maxPerStageDescriptorInputAttachments:           u32;
    maxPerStageResources:                            u32;
    maxDescriptorSetSamplers:                        u32;
    maxDescriptorSetUniformBuffers:                  u32;
    maxDescriptorSetUniformBuffersDynamic:           u32;
    maxDescriptorSetStorageBuffers:                  u32;
    maxDescriptorSetStorageBuffersDynamic:           u32;
    maxDescriptorSetSampledImages:                   u32;
    maxDescriptorSetStorageImages:                   u32;
    maxDescriptorSetInputAttachments:                u32;
    maxVertexInputAttributes:                        u32;
    maxVertexInputBindings:                          u32;
    maxVertexInputAttributeOffset:                   u32;
    maxVertexInputBindingStride:                     u32;
    maxVertexOutputComponents:                       u32;
    maxTessellationGenerationLevel:                  u32;
    maxTessellationPatchSize:                        u32;
    maxTessellationControlPerVertexInputComponents:  u32;
    maxTessellationControlPerVertexOutputComponents: u32;
    maxTessellationControlPerPatchOutputComponents:  u32;
    maxTessellationControlTotalOutputComponents:     u32;
    maxTessellationEvaluationInputComponents:        u32;
    maxTessellationEvaluationOutputComponents:       u32;
    maxGeometryShaderInvocations:                    u32;
    maxGeometryInputComponents:                      u32;
    maxGeometryOutputComponents:                     u32;
    maxGeometryOutputVertices:                       u32;
    maxGeometryTotalOutputComponents:                u32;
    maxFragmentInputComponents:                      u32;
    maxFragmentOutputAttachments:                    u32;
    maxFragmentDualSrcAttachments:                   u32;
    maxFragmentCombinedOutputResources:              u32;
    maxComputeSharedMemorySize:                      u32;
    maxComputeWorkGroupCount:                        [3] u32;
    maxComputeWorkGroupInvocations:                  u32;
    maxComputeWorkGroupSize:                         [3] u32;
    subPixelPrecisionBits:                           u32;
    subTexelPrecisionBits:                           u32;
    mipmapPrecisionBits:                             u32;
    maxDrawIndexedIndexValue:                        u32;
    maxDrawIndirectCount:                            u32;
    maxSamplerLodBias:                               float;
    maxSamplerAnisotropy:                            float;
    maxViewports:                                    u32;
    maxViewportDimensions:                           [2] u32;
    viewportBoundsRange:                             [2] float;
    viewportSubPixelBits:                            u32;
    minMemoryMapAlignment:                           u64;
    minTexelBufferOffsetAlignment:                   VkDeviceSize;
    minUniformBufferOffsetAlignment:                 VkDeviceSize;
    minStorageBufferOffsetAlignment:                 VkDeviceSize;
    minTexelOffset:                                  s32;
    maxTexelOffset:                                  u32;
    minTexelGatherOffset:                            s32;
    maxTexelGatherOffset:                            u32;
    minInterpolationOffset:                          float;
    maxInterpolationOffset:                          float;
    subPixelInterpolationOffsetBits:                 u32;
    maxFramebufferWidth:                             u32;
    maxFramebufferHeight:                            u32;
    maxFramebufferLayers:                            u32;
    framebufferColorSampleCounts:                    VkSampleCountFlags;
    framebufferDepthSampleCounts:                    VkSampleCountFlags;
    framebufferStencilSampleCounts:                  VkSampleCountFlags;
    framebufferNoAttachmentsSampleCounts:            VkSampleCountFlags;
    maxColorAttachments:                             u32;
    sampledImageColorSampleCounts:                   VkSampleCountFlags;
    sampledImageIntegerSampleCounts:                 VkSampleCountFlags;
    sampledImageDepthSampleCounts:                   VkSampleCountFlags;
    sampledImageStencilSampleCounts:                 VkSampleCountFlags;
    storageImageSampleCounts:                        VkSampleCountFlags;
    maxSampleMaskWords:                              u32;
    timestampComputeAndGraphics:                     VkBool32;
    timestampPeriod:                                 float;
    maxClipDistances:                                u32;
    maxCullDistances:                                u32;
    maxCombinedClipAndCullDistances:                 u32;
    discreteQueuePriorities:                         u32;
    pointSizeRange:                                  [2] float;
    lineWidthRange:                                  [2] float;
    pointSizeGranularity:                            float;
    lineWidthGranularity:                            float;
    strictLines:                                     VkBool32;
    standardSampleLocations:                         VkBool32;
    optimalBufferCopyOffsetAlignment:                VkDeviceSize;
    optimalBufferCopyRowPitchAlignment:              VkDeviceSize;
    nonCoherentAtomSize:                             VkDeviceSize;
}

VkPhysicalDeviceMemoryProperties :: struct {
    memoryTypeCount: u32;
    memoryTypes:     [32] VkMemoryType;
    memoryHeapCount: u32;
    memoryHeaps:     [16] VkMemoryHeap;
}

VkPhysicalDeviceSparseProperties :: struct {
    residencyStandard2DBlockShape:            VkBool32;
    residencyStandard2DMultisampleBlockShape: VkBool32;
    residencyStandard3DBlockShape:            VkBool32;
    residencyAlignedMipSize:                  VkBool32;
    residencyNonResidentStrict:               VkBool32;
}

VkPhysicalDeviceProperties :: struct {
    apiVersion:        u32;
    driverVersion:     u32;
    vendorID:          u32;
    deviceID:          u32;
    deviceType:        VkPhysicalDeviceType;
    deviceName:        [256] u8;
    pipelineCacheUUID: [16] u8;
    limits:            VkPhysicalDeviceLimits;
    sparseProperties:  VkPhysicalDeviceSparseProperties;
}

VkQueueFamilyProperties :: struct {
    queueFlags:                  VkQueueFlags;
    queueCount:                  u32;
    timestampValidBits:          u32;
    minImageTransferGranularity: VkExtent3D;
}

VkDeviceQueueCreateInfo :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    flags:            VkDeviceQueueCreateFlags;
    queueFamilyIndex: u32;
    queueCount:       u32;
    pQueuePriorities: *float;
}

VkDeviceCreateInfo :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    flags:                   VkDeviceCreateFlags;
    queueCreateInfoCount:    u32;
    pQueueCreateInfos:       *VkDeviceQueueCreateInfo;
    enabledLayerCount:       u32;
    ppEnabledLayerNames:     **u8;
    enabledExtensionCount:   u32;
    ppEnabledExtensionNames: **u8;
    pEnabledFeatures:        *VkPhysicalDeviceFeatures;
}

VkExtensionProperties :: struct {
    extensionName: [256] u8;
    specVersion:   u32;
}

VkLayerProperties :: struct {
    layerName:             [256] u8;
    specVersion:           u32;
    implementationVersion: u32;
    description:           [256] u8;
}

VkSubmitInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    waitSemaphoreCount:   u32;
    pWaitSemaphores:      *VkSemaphore;
    pWaitDstStageMask:    *VkPipelineStageFlags;
    commandBufferCount:   u32;
    pCommandBuffers:      *VkCommandBuffer;
    signalSemaphoreCount: u32;
    pSignalSemaphores:    *VkSemaphore;
}

VkMappedMemoryRange :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    memory: VkDeviceMemory;
    offset: VkDeviceSize;
    size:   VkDeviceSize;
}

VkMemoryAllocateInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    allocationSize:  VkDeviceSize;
    memoryTypeIndex: u32;
}

VkMemoryRequirements :: struct {
    size:           VkDeviceSize;
    alignment:      VkDeviceSize;
    memoryTypeBits: u32;
}

VkSparseMemoryBind :: struct {
    resourceOffset: VkDeviceSize;
    size:           VkDeviceSize;
    memory:         VkDeviceMemory;
    memoryOffset:   VkDeviceSize;
    flags:          VkSparseMemoryBindFlags;
}

VkSparseBufferMemoryBindInfo :: struct {
    buffer:    VkBuffer;
    bindCount: u32;
    pBinds:    *VkSparseMemoryBind;
}

VkSparseImageOpaqueMemoryBindInfo :: struct {
    image:     VkImage;
    bindCount: u32;
    pBinds:    *VkSparseMemoryBind;
}

VkImageSubresource :: struct {
    aspectMask: VkImageAspectFlags;
    mipLevel:   u32;
    arrayLayer: u32;
}

VkSparseImageMemoryBind :: struct {
    subresource:  VkImageSubresource;
    offset:       VkOffset3D;
    extent:       VkExtent3D;
    memory:       VkDeviceMemory;
    memoryOffset: VkDeviceSize;
    flags:        VkSparseMemoryBindFlags;
}

VkSparseImageMemoryBindInfo :: struct {
    image:     VkImage;
    bindCount: u32;
    pBinds:    *VkSparseImageMemoryBind;
}

VkBindSparseInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    waitSemaphoreCount:   u32;
    pWaitSemaphores:      *VkSemaphore;
    bufferBindCount:      u32;
    pBufferBinds:         *VkSparseBufferMemoryBindInfo;
    imageOpaqueBindCount: u32;
    pImageOpaqueBinds:    *VkSparseImageOpaqueMemoryBindInfo;
    imageBindCount:       u32;
    pImageBinds:          *VkSparseImageMemoryBindInfo;
    signalSemaphoreCount: u32;
    pSignalSemaphores:    *VkSemaphore;
}

VkSparseImageFormatProperties :: struct {
    aspectMask:       VkImageAspectFlags;
    imageGranularity: VkExtent3D;
    flags:            VkSparseImageFormatFlags;
}

VkSparseImageMemoryRequirements :: struct {
    formatProperties:     VkSparseImageFormatProperties;
    imageMipTailFirstLod: u32;
    imageMipTailSize:     VkDeviceSize;
    imageMipTailOffset:   VkDeviceSize;
    imageMipTailStride:   VkDeviceSize;
}

VkFenceCreateInfo :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkFenceCreateFlags;
}

VkSemaphoreCreateInfo :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkSemaphoreCreateFlags;
}

VkEventCreateInfo :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkEventCreateFlags;
}

VkQueryPoolCreateInfo :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    flags:              VkQueryPoolCreateFlags;
    queryType:          VkQueryType;
    queryCount:         u32;
    pipelineStatistics: VkQueryPipelineStatisticFlags;
}

VkBufferCreateInfo :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    flags:                 VkBufferCreateFlags;
    size:                  VkDeviceSize;
    usage:                 VkBufferUsageFlags;
    sharingMode:           VkSharingMode;
    queueFamilyIndexCount: u32;
    pQueueFamilyIndices:   *u32;
}

VkBufferViewCreateInfo :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    flags:  VkBufferViewCreateFlags;
    buffer: VkBuffer;
    format: VkFormat;
    offset: VkDeviceSize;
    range:  VkDeviceSize;
}

VkImageCreateInfo :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    flags:                 VkImageCreateFlags;
    imageType:             VkImageType;
    format:                VkFormat;
    extent:                VkExtent3D;
    mipLevels:             u32;
    arrayLayers:           u32;
    samples:               VkSampleCountFlagBits;
    tiling:                VkImageTiling;
    usage:                 VkImageUsageFlags;
    sharingMode:           VkSharingMode;
    queueFamilyIndexCount: u32;
    pQueueFamilyIndices:   *u32;
    initialLayout:         VkImageLayout;
}

VkSubresourceLayout :: struct {
    offset:     VkDeviceSize;
    size:       VkDeviceSize;
    rowPitch:   VkDeviceSize;
    arrayPitch: VkDeviceSize;
    depthPitch: VkDeviceSize;
}

VkComponentMapping :: struct {
    r: VkComponentSwizzle;
    g: VkComponentSwizzle;
    b: VkComponentSwizzle;
    a: VkComponentSwizzle;
}

VkImageViewCreateInfo :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    flags:            VkImageViewCreateFlags;
    image:            VkImage;
    viewType:         VkImageViewType;
    format:           VkFormat;
    components:       VkComponentMapping;
    subresourceRange: VkImageSubresourceRange;
}

VkShaderModuleCreateInfo :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    flags:    VkShaderModuleCreateFlags;
    codeSize: u64;
    pCode:    *u32;
}

VkPipelineCacheCreateInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkPipelineCacheCreateFlags;
    initialDataSize: u64;
    pInitialData:    *void;
}

VkSpecializationMapEntry :: struct {
    constantID: u32;
    offset:     u32;
    size:       u64;
}

VkSpecializationInfo :: struct {
    mapEntryCount: u32;
    pMapEntries:   *VkSpecializationMapEntry;
    dataSize:      u64;
    pData:         *void;
}

VkPipelineShaderStageCreateInfo :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    flags:               VkPipelineShaderStageCreateFlags;
    stage:               VkShaderStageFlagBits;
    module:              VkShaderModule;
    pName:               *u8;
    pSpecializationInfo: *VkSpecializationInfo;
}

VkComputePipelineCreateInfo :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    flags:              VkPipelineCreateFlags;
    stage:              VkPipelineShaderStageCreateInfo;
    layout:             VkPipelineLayout;
    basePipelineHandle: VkPipeline;
    basePipelineIndex:  s32;
}

VkVertexInputBindingDescription :: struct {
    binding:   u32;
    stride:    u32;
    inputRate: VkVertexInputRate;
}

VkVertexInputAttributeDescription :: struct {
    location: u32;
    binding:  u32;
    format:   VkFormat;
    offset:   u32;
}

VkPipelineVertexInputStateCreateInfo :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    flags:                           VkPipelineVertexInputStateCreateFlags;
    vertexBindingDescriptionCount:   u32;
    pVertexBindingDescriptions:      *VkVertexInputBindingDescription;
    vertexAttributeDescriptionCount: u32;
    pVertexAttributeDescriptions:    *VkVertexInputAttributeDescription;
}

VkPipelineInputAssemblyStateCreateInfo :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    flags:                  VkPipelineInputAssemblyStateCreateFlags;
    topology:               VkPrimitiveTopology;
    primitiveRestartEnable: VkBool32;
}

VkPipelineTessellationStateCreateInfo :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    flags:              VkPipelineTessellationStateCreateFlags;
    patchControlPoints: u32;
}

VkViewport :: struct {
    x:        float;
    y:        float;
    width:    float;
    height:   float;
    minDepth: float;
    maxDepth: float;
}

VkPipelineViewportStateCreateInfo :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    flags:         VkPipelineViewportStateCreateFlags;
    viewportCount: u32;
    pViewports:    *VkViewport;
    scissorCount:  u32;
    pScissors:     *VkRect2D;
}

VkPipelineRasterizationStateCreateInfo :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    flags:                   VkPipelineRasterizationStateCreateFlags;
    depthClampEnable:        VkBool32;
    rasterizerDiscardEnable: VkBool32;
    polygonMode:             VkPolygonMode;
    cullMode:                VkCullModeFlags;
    frontFace:               VkFrontFace;
    depthBiasEnable:         VkBool32;
    depthBiasConstantFactor: float;
    depthBiasClamp:          float;
    depthBiasSlopeFactor:    float;
    lineWidth:               float;
}

VkPipelineMultisampleStateCreateInfo :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    flags:                 VkPipelineMultisampleStateCreateFlags;
    rasterizationSamples:  VkSampleCountFlagBits;
    sampleShadingEnable:   VkBool32;
    minSampleShading:      float;
    pSampleMask:           *VkSampleMask;
    alphaToCoverageEnable: VkBool32;
    alphaToOneEnable:      VkBool32;
}

VkStencilOpState :: struct {
    failOp:      VkStencilOp;
    passOp:      VkStencilOp;
    depthFailOp: VkStencilOp;
    compareOp:   VkCompareOp;
    compareMask: u32;
    writeMask:   u32;
    reference:   u32;
}

VkPipelineDepthStencilStateCreateInfo :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    flags:                 VkPipelineDepthStencilStateCreateFlags;
    depthTestEnable:       VkBool32;
    depthWriteEnable:      VkBool32;
    depthCompareOp:        VkCompareOp;
    depthBoundsTestEnable: VkBool32;
    stencilTestEnable:     VkBool32;
    front:                 VkStencilOpState;
    back:                  VkStencilOpState;
    minDepthBounds:        float;
    maxDepthBounds:        float;
}

VkPipelineColorBlendAttachmentState :: struct {
    blendEnable:         VkBool32;
    srcColorBlendFactor: VkBlendFactor;
    dstColorBlendFactor: VkBlendFactor;
    colorBlendOp:        VkBlendOp;
    srcAlphaBlendFactor: VkBlendFactor;
    dstAlphaBlendFactor: VkBlendFactor;
    alphaBlendOp:        VkBlendOp;
    colorWriteMask:      VkColorComponentFlags;
}

VkPipelineColorBlendStateCreateInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkPipelineColorBlendStateCreateFlags;
    logicOpEnable:   VkBool32;
    logicOp:         VkLogicOp;
    attachmentCount: u32;
    pAttachments:    *VkPipelineColorBlendAttachmentState;
    blendConstants:  [4] float;
}

VkPipelineDynamicStateCreateInfo :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    flags:             VkPipelineDynamicStateCreateFlags;
    dynamicStateCount: u32;
    pDynamicStates:    *VkDynamicState;
}

VkGraphicsPipelineCreateInfo :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    flags:               VkPipelineCreateFlags;
    stageCount:          u32;
    pStages:             *VkPipelineShaderStageCreateInfo;
    pVertexInputState:   *VkPipelineVertexInputStateCreateInfo;
    pInputAssemblyState: *VkPipelineInputAssemblyStateCreateInfo;
    pTessellationState:  *VkPipelineTessellationStateCreateInfo;
    pViewportState:      *VkPipelineViewportStateCreateInfo;
    pRasterizationState: *VkPipelineRasterizationStateCreateInfo;
    pMultisampleState:   *VkPipelineMultisampleStateCreateInfo;
    pDepthStencilState:  *VkPipelineDepthStencilStateCreateInfo;
    pColorBlendState:    *VkPipelineColorBlendStateCreateInfo;
    pDynamicState:       *VkPipelineDynamicStateCreateInfo;
    layout:              VkPipelineLayout;
    renderPass:          VkRenderPass;
    subpass:             u32;
    basePipelineHandle:  VkPipeline;
    basePipelineIndex:   s32;
}

VkPushConstantRange :: struct {
    stageFlags: VkShaderStageFlags;
    offset:     u32;
    size:       u32;
}

VkPipelineLayoutCreateInfo :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    flags:                  VkPipelineLayoutCreateFlags;
    setLayoutCount:         u32;
    pSetLayouts:            *VkDescriptorSetLayout;
    pushConstantRangeCount: u32;
    pPushConstantRanges:    *VkPushConstantRange;
}

VkSamplerCreateInfo :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    flags:                   VkSamplerCreateFlags;
    magFilter:               VkFilter;
    minFilter:               VkFilter;
    mipmapMode:              VkSamplerMipmapMode;
    addressModeU:            VkSamplerAddressMode;
    addressModeV:            VkSamplerAddressMode;
    addressModeW:            VkSamplerAddressMode;
    mipLodBias:              float;
    anisotropyEnable:        VkBool32;
    maxAnisotropy:           float;
    compareEnable:           VkBool32;
    compareOp:               VkCompareOp;
    minLod:                  float;
    maxLod:                  float;
    borderColor:             VkBorderColor;
    unnormalizedCoordinates: VkBool32;
}

VkCopyDescriptorSet :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    srcSet:          VkDescriptorSet;
    srcBinding:      u32;
    srcArrayElement: u32;
    dstSet:          VkDescriptorSet;
    dstBinding:      u32;
    dstArrayElement: u32;
    descriptorCount: u32;
}

VkDescriptorBufferInfo :: struct {
    buffer: VkBuffer;
    offset: VkDeviceSize;
    range:  VkDeviceSize;
}

VkDescriptorImageInfo :: struct {
    sampler:     VkSampler;
    imageView:   VkImageView;
    imageLayout: VkImageLayout;
}

VkDescriptorPoolSize :: struct {
    type:            VkDescriptorType;
    descriptorCount: u32;
}

VkDescriptorPoolCreateInfo :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    flags:         VkDescriptorPoolCreateFlags;
    maxSets:       u32;
    poolSizeCount: u32;
    pPoolSizes:    *VkDescriptorPoolSize;
}

VkDescriptorSetAllocateInfo :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    descriptorPool:     VkDescriptorPool;
    descriptorSetCount: u32;
    pSetLayouts:        *VkDescriptorSetLayout;
}

VkDescriptorSetLayoutBinding :: struct {
    binding:            u32;
    descriptorType:     VkDescriptorType;
    descriptorCount:    u32;
    stageFlags:         VkShaderStageFlags;
    pImmutableSamplers: *VkSampler;
}

VkDescriptorSetLayoutCreateInfo :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    flags:        VkDescriptorSetLayoutCreateFlags;
    bindingCount: u32;
    pBindings:    *VkDescriptorSetLayoutBinding;
}

VkWriteDescriptorSet :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    dstSet:           VkDescriptorSet;
    dstBinding:       u32;
    dstArrayElement:  u32;
    descriptorCount:  u32;
    descriptorType:   VkDescriptorType;
    pImageInfo:       *VkDescriptorImageInfo;
    pBufferInfo:      *VkDescriptorBufferInfo;
    pTexelBufferView: *VkBufferView;
}

VkAttachmentDescription :: struct {
    flags:          VkAttachmentDescriptionFlags;
    format:         VkFormat;
    samples:        VkSampleCountFlagBits;
    loadOp:         VkAttachmentLoadOp;
    storeOp:        VkAttachmentStoreOp;
    stencilLoadOp:  VkAttachmentLoadOp;
    stencilStoreOp: VkAttachmentStoreOp;
    initialLayout:  VkImageLayout;
    finalLayout:    VkImageLayout;
}

VkAttachmentReference :: struct {
    attachment: u32;
    layout:     VkImageLayout;
}

VkFramebufferCreateInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkFramebufferCreateFlags;
    renderPass:      VkRenderPass;
    attachmentCount: u32;
    pAttachments:    *VkImageView;
    width:           u32;
    height:          u32;
    layers:          u32;
}

VkSubpassDescription :: struct {
    flags:                   VkSubpassDescriptionFlags;
    pipelineBindPoint:       VkPipelineBindPoint;
    inputAttachmentCount:    u32;
    pInputAttachments:       *VkAttachmentReference;
    colorAttachmentCount:    u32;
    pColorAttachments:       *VkAttachmentReference;
    pResolveAttachments:     *VkAttachmentReference;
    pDepthStencilAttachment: *VkAttachmentReference;
    preserveAttachmentCount: u32;
    pPreserveAttachments:    *u32;
}

VkSubpassDependency :: struct {
    srcSubpass:      u32;
    dstSubpass:      u32;
    srcStageMask:    VkPipelineStageFlags;
    dstStageMask:    VkPipelineStageFlags;
    srcAccessMask:   VkAccessFlags;
    dstAccessMask:   VkAccessFlags;
    dependencyFlags: VkDependencyFlags;
}

VkRenderPassCreateInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkRenderPassCreateFlags;
    attachmentCount: u32;
    pAttachments:    *VkAttachmentDescription;
    subpassCount:    u32;
    pSubpasses:      *VkSubpassDescription;
    dependencyCount: u32;
    pDependencies:   *VkSubpassDependency;
}

VkCommandPoolCreateInfo :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    flags:            VkCommandPoolCreateFlags;
    queueFamilyIndex: u32;
}

VkCommandBufferAllocateInfo :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    commandPool:        VkCommandPool;
    level:              VkCommandBufferLevel;
    commandBufferCount: u32;
}

VkCommandBufferInheritanceInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    renderPass:           VkRenderPass;
    subpass:              u32;
    framebuffer:          VkFramebuffer;
    occlusionQueryEnable: VkBool32;
    queryFlags:           VkQueryControlFlags;
    pipelineStatistics:   VkQueryPipelineStatisticFlags;
}

VkCommandBufferBeginInfo :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    flags:            VkCommandBufferUsageFlags;
    pInheritanceInfo: *VkCommandBufferInheritanceInfo;
}

VkBufferCopy :: struct {
    srcOffset: VkDeviceSize;
    dstOffset: VkDeviceSize;
    size:      VkDeviceSize;
}

VkImageSubresourceLayers :: struct {
    aspectMask:     VkImageAspectFlags;
    mipLevel:       u32;
    baseArrayLayer: u32;
    layerCount:     u32;
}

VkBufferImageCopy :: struct {
    bufferOffset:      VkDeviceSize;
    bufferRowLength:   u32;
    bufferImageHeight: u32;
    imageSubresource:  VkImageSubresourceLayers;
    imageOffset:       VkOffset3D;
    imageExtent:       VkExtent3D;
}

VkClearColorValue :: union {
    _float32: [4] float;
    int32:    [4] s32;
    uint32:   [4] u32;
}

VkClearDepthStencilValue :: struct {
    depth:   float;
    stencil: u32;
}

VkClearValue :: union {
    color:        VkClearColorValue;
    depthStencil: VkClearDepthStencilValue;
}

VkClearAttachment :: struct {
    aspectMask:      VkImageAspectFlags;
    colorAttachment: u32;
    clearValue:      VkClearValue;
}

VkClearRect :: struct {
    rect:           VkRect2D;
    baseArrayLayer: u32;
    layerCount:     u32;
}

VkImageBlit :: struct {
    srcSubresource: VkImageSubresourceLayers;
    srcOffsets:     [2] VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffsets:     [2] VkOffset3D;
}

VkImageCopy :: struct {
    srcSubresource: VkImageSubresourceLayers;
    srcOffset:      VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset:      VkOffset3D;
    extent:         VkExtent3D;
}

VkImageResolve :: struct {
    srcSubresource: VkImageSubresourceLayers;
    srcOffset:      VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset:      VkOffset3D;
    extent:         VkExtent3D;
}

VkRenderPassBeginInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    renderPass:      VkRenderPass;
    framebuffer:     VkFramebuffer;
    renderArea:      VkRect2D;
    clearValueCount: u32;
    pClearValues:    *VkClearValue;
}

PFN_vkCreateInstance :: #type (pCreateInfo: *VkInstanceCreateInfo, pAllocator: *VkAllocationCallbacks, pInstance: *VkInstance) -> VkResult #c_call;
PFN_vkDestroyInstance :: #type (instance: VkInstance, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkEnumeratePhysicalDevices :: #type (instance: VkInstance, pPhysicalDeviceCount: *u32, pPhysicalDevices: *VkPhysicalDevice) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceFeatures :: #type (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures) -> void #c_call;
PFN_vkGetPhysicalDeviceFormatProperties :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceImageFormatProperties :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *VkImageFormatProperties) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceProperties :: #type (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceQueueFamilyProperties :: #type (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceMemoryProperties :: #type (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties) -> void #c_call;
PFN_vkGetInstanceProcAddr :: #type (instance: VkInstance, pName: *u8) -> PFN_vkVoidFunction #c_call;
PFN_vkGetDeviceProcAddr :: #type (device: VkDevice, pName: *u8) -> PFN_vkVoidFunction #c_call;
PFN_vkCreateDevice :: #type (physicalDevice: VkPhysicalDevice, pCreateInfo: *VkDeviceCreateInfo, pAllocator: *VkAllocationCallbacks, pDevice: *VkDevice) -> VkResult #c_call;
PFN_vkDestroyDevice :: #type (device: VkDevice, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkEnumerateInstanceExtensionProperties :: #type (pLayerName: *u8, pPropertyCount: *u32, pProperties: *VkExtensionProperties) -> VkResult #c_call;
PFN_vkEnumerateDeviceExtensionProperties :: #type (physicalDevice: VkPhysicalDevice, pLayerName: *u8, pPropertyCount: *u32, pProperties: *VkExtensionProperties) -> VkResult #c_call;
PFN_vkEnumerateInstanceLayerProperties :: #type (pPropertyCount: *u32, pProperties: *VkLayerProperties) -> VkResult #c_call;
PFN_vkEnumerateDeviceLayerProperties :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkLayerProperties) -> VkResult #c_call;
PFN_vkGetDeviceQueue :: #type (device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *VkQueue) -> void #c_call;
PFN_vkQueueSubmit :: #type (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo, fence: VkFence) -> VkResult #c_call;
PFN_vkQueueWaitIdle :: #type (queue: VkQueue) -> VkResult #c_call;
PFN_vkDeviceWaitIdle :: #type (device: VkDevice) -> VkResult #c_call;
PFN_vkAllocateMemory :: #type (device: VkDevice, pAllocateInfo: *VkMemoryAllocateInfo, pAllocator: *VkAllocationCallbacks, pMemory: *VkDeviceMemory) -> VkResult #c_call;
PFN_vkFreeMemory :: #type (device: VkDevice, memory: VkDeviceMemory, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkMapMemory :: #type (device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: **void) -> VkResult #c_call;
PFN_vkUnmapMemory :: #type (device: VkDevice, memory: VkDeviceMemory) -> void #c_call;
PFN_vkFlushMappedMemoryRanges :: #type (device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *VkMappedMemoryRange) -> VkResult #c_call;
PFN_vkInvalidateMappedMemoryRanges :: #type (device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *VkMappedMemoryRange) -> VkResult #c_call;
PFN_vkGetDeviceMemoryCommitment :: #type (device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *VkDeviceSize) -> void #c_call;
PFN_vkBindBufferMemory :: #type (device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult #c_call;
PFN_vkBindImageMemory :: #type (device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult #c_call;
PFN_vkGetBufferMemoryRequirements :: #type (device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *VkMemoryRequirements) -> void #c_call;
PFN_vkGetImageMemoryRequirements :: #type (device: VkDevice, image: VkImage, pMemoryRequirements: *VkMemoryRequirements) -> void #c_call;
PFN_vkGetImageSparseMemoryRequirements :: #type (device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements) -> void #c_call;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties) -> void #c_call;
PFN_vkQueueBindSparse :: #type (queue: VkQueue, bindInfoCount: u32, pBindInfo: *VkBindSparseInfo, fence: VkFence) -> VkResult #c_call;
PFN_vkCreateFence :: #type (device: VkDevice, pCreateInfo: *VkFenceCreateInfo, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) -> VkResult #c_call;
PFN_vkDestroyFence :: #type (device: VkDevice, fence: VkFence, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkResetFences :: #type (device: VkDevice, fenceCount: u32, pFences: *VkFence) -> VkResult #c_call;
PFN_vkGetFenceStatus :: #type (device: VkDevice, fence: VkFence) -> VkResult #c_call;
PFN_vkWaitForFences :: #type (device: VkDevice, fenceCount: u32, pFences: *VkFence, waitAll: VkBool32, timeout: u64) -> VkResult #c_call;
PFN_vkCreateSemaphore :: #type (device: VkDevice, pCreateInfo: *VkSemaphoreCreateInfo, pAllocator: *VkAllocationCallbacks, pSemaphore: *VkSemaphore) -> VkResult #c_call;
PFN_vkDestroySemaphore :: #type (device: VkDevice, semaphore: VkSemaphore, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateEvent :: #type (device: VkDevice, pCreateInfo: *VkEventCreateInfo, pAllocator: *VkAllocationCallbacks, pEvent: *VkEvent) -> VkResult #c_call;
PFN_vkDestroyEvent :: #type (device: VkDevice, event: VkEvent, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetEventStatus :: #type (device: VkDevice, event: VkEvent) -> VkResult #c_call;
PFN_vkSetEvent :: #type (device: VkDevice, event: VkEvent) -> VkResult #c_call;
PFN_vkResetEvent :: #type (device: VkDevice, event: VkEvent) -> VkResult #c_call;
PFN_vkCreateQueryPool :: #type (device: VkDevice, pCreateInfo: *VkQueryPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pQueryPool: *VkQueryPool) -> VkResult #c_call;
PFN_vkDestroyQueryPool :: #type (device: VkDevice, queryPool: VkQueryPool, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetQueryPoolResults :: #type (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: u64, pData: *void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> VkResult #c_call;
PFN_vkCreateBuffer :: #type (device: VkDevice, pCreateInfo: *VkBufferCreateInfo, pAllocator: *VkAllocationCallbacks, pBuffer: *VkBuffer) -> VkResult #c_call;
PFN_vkDestroyBuffer :: #type (device: VkDevice, buffer: VkBuffer, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateBufferView :: #type (device: VkDevice, pCreateInfo: *VkBufferViewCreateInfo, pAllocator: *VkAllocationCallbacks, pView: *VkBufferView) -> VkResult #c_call;
PFN_vkDestroyBufferView :: #type (device: VkDevice, bufferView: VkBufferView, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateImage :: #type (device: VkDevice, pCreateInfo: *VkImageCreateInfo, pAllocator: *VkAllocationCallbacks, pImage: *VkImage) -> VkResult #c_call;
PFN_vkDestroyImage :: #type (device: VkDevice, image: VkImage, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetImageSubresourceLayout :: #type (device: VkDevice, image: VkImage, pSubresource: *VkImageSubresource, pLayout: *VkSubresourceLayout) -> void #c_call;
PFN_vkCreateImageView :: #type (device: VkDevice, pCreateInfo: *VkImageViewCreateInfo, pAllocator: *VkAllocationCallbacks, pView: *VkImageView) -> VkResult #c_call;
PFN_vkDestroyImageView :: #type (device: VkDevice, imageView: VkImageView, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateShaderModule :: #type (device: VkDevice, pCreateInfo: *VkShaderModuleCreateInfo, pAllocator: *VkAllocationCallbacks, pShaderModule: *VkShaderModule) -> VkResult #c_call;
PFN_vkDestroyShaderModule :: #type (device: VkDevice, shaderModule: VkShaderModule, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreatePipelineCache :: #type (device: VkDevice, pCreateInfo: *VkPipelineCacheCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelineCache: *VkPipelineCache) -> VkResult #c_call;
PFN_vkDestroyPipelineCache :: #type (device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetPipelineCacheData :: #type (device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *u64, pData: *void) -> VkResult #c_call;
PFN_vkMergePipelineCaches :: #type (device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *VkPipelineCache) -> VkResult #c_call;
PFN_vkCreateGraphicsPipelines :: #type (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkGraphicsPipelineCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkCreateComputePipelines :: #type (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkComputePipelineCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkDestroyPipeline :: #type (device: VkDevice, pipeline: VkPipeline, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreatePipelineLayout :: #type (device: VkDevice, pCreateInfo: *VkPipelineLayoutCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelineLayout: *VkPipelineLayout) -> VkResult #c_call;
PFN_vkDestroyPipelineLayout :: #type (device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateSampler :: #type (device: VkDevice, pCreateInfo: *VkSamplerCreateInfo, pAllocator: *VkAllocationCallbacks, pSampler: *VkSampler) -> VkResult #c_call;
PFN_vkDestroySampler :: #type (device: VkDevice, sampler: VkSampler, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateDescriptorSetLayout :: #type (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pAllocator: *VkAllocationCallbacks, pSetLayout: *VkDescriptorSetLayout) -> VkResult #c_call;
PFN_vkDestroyDescriptorSetLayout :: #type (device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateDescriptorPool :: #type (device: VkDevice, pCreateInfo: *VkDescriptorPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorPool: *VkDescriptorPool) -> VkResult #c_call;
PFN_vkDestroyDescriptorPool :: #type (device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkResetDescriptorPool :: #type (device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> VkResult #c_call;
PFN_vkAllocateDescriptorSets :: #type (device: VkDevice, pAllocateInfo: *VkDescriptorSetAllocateInfo, pDescriptorSets: *VkDescriptorSet) -> VkResult #c_call;
PFN_vkFreeDescriptorSets :: #type (device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *VkDescriptorSet) -> VkResult #c_call;
PFN_vkUpdateDescriptorSets :: #type (device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *VkCopyDescriptorSet) -> void #c_call;
PFN_vkCreateFramebuffer :: #type (device: VkDevice, pCreateInfo: *VkFramebufferCreateInfo, pAllocator: *VkAllocationCallbacks, pFramebuffer: *VkFramebuffer) -> VkResult #c_call;
PFN_vkDestroyFramebuffer :: #type (device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateRenderPass :: #type (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) -> VkResult #c_call;
PFN_vkDestroyRenderPass :: #type (device: VkDevice, renderPass: VkRenderPass, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetRenderAreaGranularity :: #type (device: VkDevice, renderPass: VkRenderPass, pGranularity: *VkExtent2D) -> void #c_call;
PFN_vkCreateCommandPool :: #type (device: VkDevice, pCreateInfo: *VkCommandPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pCommandPool: *VkCommandPool) -> VkResult #c_call;
PFN_vkDestroyCommandPool :: #type (device: VkDevice, commandPool: VkCommandPool, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkResetCommandPool :: #type (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> VkResult #c_call;
PFN_vkAllocateCommandBuffers :: #type (device: VkDevice, pAllocateInfo: *VkCommandBufferAllocateInfo, pCommandBuffers: *VkCommandBuffer) -> VkResult #c_call;
PFN_vkFreeCommandBuffers :: #type (device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *VkCommandBuffer) -> void #c_call;
PFN_vkBeginCommandBuffer :: #type (commandBuffer: VkCommandBuffer, pBeginInfo: *VkCommandBufferBeginInfo) -> VkResult #c_call;
PFN_vkEndCommandBuffer :: #type (commandBuffer: VkCommandBuffer) -> VkResult #c_call;
PFN_vkResetCommandBuffer :: #type (commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> VkResult #c_call;
PFN_vkCmdBindPipeline :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) -> void #c_call;
PFN_vkCmdSetViewport :: #type (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *VkViewport) -> void #c_call;
PFN_vkCmdSetScissor :: #type (commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *VkRect2D) -> void #c_call;
PFN_vkCmdSetLineWidth :: #type (commandBuffer: VkCommandBuffer, lineWidth: float) -> void #c_call;
PFN_vkCmdSetDepthBias :: #type (commandBuffer: VkCommandBuffer, depthBiasConstantFactor: float, depthBiasClamp: float, depthBiasSlopeFactor: float) -> void #c_call;
PFN_vkCmdSetBlendConstants :: #type (commandBuffer: VkCommandBuffer, blendConstants: *[4] float) -> void #c_call;
PFN_vkCmdSetDepthBounds :: #type (commandBuffer: VkCommandBuffer, minDepthBounds: float, maxDepthBounds: float) -> void #c_call;
PFN_vkCmdSetStencilCompareMask :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32) -> void #c_call;
PFN_vkCmdSetStencilWriteMask :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32) -> void #c_call;
PFN_vkCmdSetStencilReference :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32) -> void #c_call;
PFN_vkCmdBindDescriptorSets :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *u32) -> void #c_call;
PFN_vkCmdBindIndexBuffer :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) -> void #c_call;
PFN_vkCmdBindVertexBuffers :: #type (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize) -> void #c_call;
PFN_vkCmdDraw :: #type (commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) -> void #c_call;
PFN_vkCmdDrawIndexed :: #type (commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: s32, firstInstance: u32) -> void #c_call;
PFN_vkCmdDrawIndirect :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawIndexedIndirect :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDispatch :: #type (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;
PFN_vkCmdDispatchIndirect :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) -> void #c_call;
PFN_vkCmdCopyBuffer :: #type (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *VkBufferCopy) -> void #c_call;
PFN_vkCmdCopyImage :: #type (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageCopy) -> void #c_call;
PFN_vkCmdBlitImage :: #type (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageBlit, filter: VkFilter) -> void #c_call;
PFN_vkCmdCopyBufferToImage :: #type (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkBufferImageCopy) -> void #c_call;
PFN_vkCmdCopyImageToBuffer :: #type (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *VkBufferImageCopy) -> void #c_call;
PFN_vkCmdUpdateBuffer :: #type (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *void) -> void #c_call;
PFN_vkCmdFillBuffer :: #type (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32) -> void #c_call;
PFN_vkCmdClearColorImage :: #type (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *VkClearColorValue, rangeCount: u32, pRanges: *VkImageSubresourceRange) -> void #c_call;
PFN_vkCmdClearDepthStencilImage :: #type (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *VkClearDepthStencilValue, rangeCount: u32, pRanges: *VkImageSubresourceRange) -> void #c_call;
PFN_vkCmdClearAttachments :: #type (commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *VkClearAttachment, rectCount: u32, pRects: *VkClearRect) -> void #c_call;
PFN_vkCmdResolveImage :: #type (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageResolve) -> void #c_call;
PFN_vkCmdSetEvent :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> void #c_call;
PFN_vkCmdResetEvent :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> void #c_call;
PFN_vkCmdWaitEvents :: #type (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *VkImageMemoryBarrier) -> void #c_call;
PFN_vkCmdPipelineBarrier :: #type (commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *VkImageMemoryBarrier) -> void #c_call;
PFN_vkCmdBeginQuery :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags) -> void #c_call;
PFN_vkCmdEndQuery :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32) -> void #c_call;
PFN_vkCmdResetQueryPool :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> void #c_call;
PFN_vkCmdWriteTimestamp :: #type (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32) -> void #c_call;
PFN_vkCmdCopyQueryPoolResults :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) -> void #c_call;
PFN_vkCmdPushConstants :: #type (commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *void) -> void #c_call;
PFN_vkCmdBeginRenderPass :: #type (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, contents: VkSubpassContents) -> void #c_call;
PFN_vkCmdNextSubpass :: #type (commandBuffer: VkCommandBuffer, contents: VkSubpassContents) -> void #c_call;
PFN_vkCmdEndRenderPass :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdExecuteCommands :: #type (commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *VkCommandBuffer) -> void #c_call;

VkSamplerYcbcrConversion_T :: struct {}
VkSamplerYcbcrConversion :: *VkSamplerYcbcrConversion_T;
VkDescriptorUpdateTemplate_T :: struct {}
VkDescriptorUpdateTemplate :: *VkDescriptorUpdateTemplate_T;

VkPointClippingBehavior :: enum s32 {
    ALL_CLIP_PLANES           :: 0;
    USER_CLIP_PLANES_ONLY     :: 1;
    ALL_CLIP_PLANES_KHR       :: 0;
    USER_CLIP_PLANES_ONLY_KHR :: 1;
    MAX_ENUM                  :: 2147483647;
}

VkTessellationDomainOrigin :: enum s32 {
    UPPER_LEFT     :: 0;
    LOWER_LEFT     :: 1;
    UPPER_LEFT_KHR :: 0;
    LOWER_LEFT_KHR :: 1;
    MAX_ENUM       :: 2147483647;
}

VkSamplerYcbcrModelConversion :: enum s32 {
    RGB_IDENTITY       :: 0;
    YCBCR_IDENTITY     :: 1;
    YCBCR_709          :: 2;
    YCBCR_601          :: 3;
    YCBCR_2020         :: 4;
    RGB_IDENTITY_KHR   :: 0;
    YCBCR_IDENTITY_KHR :: 1;
    YCBCR_709_KHR      :: 2;
    YCBCR_601_KHR      :: 3;
    YCBCR_2020_KHR     :: 4;
    MAX_ENUM           :: 2147483647;
}

VkSamplerYcbcrRange :: enum s32 {
    ITU_FULL       :: 0;
    ITU_NARROW     :: 1;
    ITU_FULL_KHR   :: 0;
    ITU_NARROW_KHR :: 1;
    MAX_ENUM       :: 2147483647;
}

VkChromaLocation :: enum s32 {
    COSITED_EVEN     :: 0;
    MIDPOINT         :: 1;
    COSITED_EVEN_KHR :: 0;
    MIDPOINT_KHR     :: 1;
    MAX_ENUM         :: 2147483647;
}

VkDescriptorUpdateTemplateType :: enum s32 {
    DESCRIPTOR_SET       :: 0;
    PUSH_DESCRIPTORS_KHR :: 1;
    DESCRIPTOR_SET_KHR   :: 0;
    MAX_ENUM             :: 2147483647;
}

VkSubgroupFeatureFlagBits :: enum s32 {
    BASIC_BIT            :: 1;
    VOTE_BIT             :: 2;
    ARITHMETIC_BIT       :: 4;
    BALLOT_BIT           :: 8;
    SHUFFLE_BIT          :: 16;
    SHUFFLE_RELATIVE_BIT :: 32;
    CLUSTERED_BIT        :: 64;
    QUAD_BIT             :: 128;
    PARTITIONED_BIT_NV   :: 256;
    FLAG_BITS_MAX_ENUM   :: 2147483647;
}

VkSubgroupFeatureFlags :: VkFlags;

VkPeerMemoryFeatureFlagBits :: enum s32 {
    COPY_SRC_BIT        :: 1;
    COPY_DST_BIT        :: 2;
    GENERIC_SRC_BIT     :: 4;
    GENERIC_DST_BIT     :: 8;
    COPY_SRC_BIT_KHR    :: 1;
    COPY_DST_BIT_KHR    :: 2;
    GENERIC_SRC_BIT_KHR :: 4;
    GENERIC_DST_BIT_KHR :: 8;
    FLAG_BITS_MAX_ENUM  :: 2147483647;
}

VkPeerMemoryFeatureFlags :: VkFlags;

VkMemoryAllocateFlagBits :: enum s32 {
    DEVICE_MASK_BIT                       :: 1;
    DEVICE_ADDRESS_BIT                    :: 2;
    DEVICE_ADDRESS_CAPTURE_REPLAY_BIT     :: 4;
    DEVICE_MASK_BIT_KHR                   :: 1;
    DEVICE_ADDRESS_BIT_KHR                :: 2;
    DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR :: 4;
    FLAG_BITS_MAX_ENUM                    :: 2147483647;
}

VkMemoryAllocateFlags :: VkFlags;
VkCommandPoolTrimFlags :: VkFlags;
VkDescriptorUpdateTemplateCreateFlags :: VkFlags;

VkExternalMemoryHandleTypeFlagBits :: enum s32 {
    OPAQUE_FD_BIT                       :: 1;
    OPAQUE_WIN32_BIT                    :: 2;
    OPAQUE_WIN32_KMT_BIT                :: 4;
    D3D11_TEXTURE_BIT                   :: 8;
    D3D11_TEXTURE_KMT_BIT               :: 16;
    D3D12_HEAP_BIT                      :: 32;
    D3D12_RESOURCE_BIT                  :: 64;
    DMA_BUF_BIT_EXT                     :: 512;
    ANDROID_HARDWARE_BUFFER_BIT_ANDROID :: 1024;
    HOST_ALLOCATION_BIT_EXT             :: 128;
    HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT  :: 256;
    ZIRCON_VMO_BIT_FUCHSIA              :: 2048;
    RDMA_ADDRESS_BIT_NV                 :: 4096;
    SCREEN_BUFFER_BIT_QNX               :: 16384;
    OPAQUE_FD_BIT_KHR                   :: 1;
    OPAQUE_WIN32_BIT_KHR                :: 2;
    OPAQUE_WIN32_KMT_BIT_KHR            :: 4;
    D3D11_TEXTURE_BIT_KHR               :: 8;
    D3D11_TEXTURE_KMT_BIT_KHR           :: 16;
    D3D12_HEAP_BIT_KHR                  :: 32;
    D3D12_RESOURCE_BIT_KHR              :: 64;
    FLAG_BITS_MAX_ENUM                  :: 2147483647;
}

VkExternalMemoryHandleTypeFlags :: VkFlags;

VkExternalMemoryFeatureFlagBits :: enum s32 {
    DEDICATED_ONLY_BIT     :: 1;
    EXPORTABLE_BIT         :: 2;
    IMPORTABLE_BIT         :: 4;
    DEDICATED_ONLY_BIT_KHR :: 1;
    EXPORTABLE_BIT_KHR     :: 2;
    IMPORTABLE_BIT_KHR     :: 4;
    FLAG_BITS_MAX_ENUM     :: 2147483647;
}

VkExternalMemoryFeatureFlags :: VkFlags;

VkExternalFenceHandleTypeFlagBits :: enum s32 {
    OPAQUE_FD_BIT            :: 1;
    OPAQUE_WIN32_BIT         :: 2;
    OPAQUE_WIN32_KMT_BIT     :: 4;
    SYNC_FD_BIT              :: 8;
    OPAQUE_FD_BIT_KHR        :: 1;
    OPAQUE_WIN32_BIT_KHR     :: 2;
    OPAQUE_WIN32_KMT_BIT_KHR :: 4;
    SYNC_FD_BIT_KHR          :: 8;
    FLAG_BITS_MAX_ENUM       :: 2147483647;
}

VkExternalFenceHandleTypeFlags :: VkFlags;

VkExternalFenceFeatureFlagBits :: enum s32 {
    EXPORTABLE_BIT     :: 1;
    IMPORTABLE_BIT     :: 2;
    EXPORTABLE_BIT_KHR :: 1;
    IMPORTABLE_BIT_KHR :: 2;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkExternalFenceFeatureFlags :: VkFlags;

VkFenceImportFlagBits :: enum s32 {
    TEMPORARY_BIT      :: 1;
    TEMPORARY_BIT_KHR  :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkFenceImportFlags :: VkFlags;

VkSemaphoreImportFlagBits :: enum s32 {
    TEMPORARY_BIT      :: 1;
    TEMPORARY_BIT_KHR  :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkSemaphoreImportFlags :: VkFlags;

VkExternalSemaphoreHandleTypeFlagBits :: enum s32 {
    OPAQUE_FD_BIT            :: 1;
    OPAQUE_WIN32_BIT         :: 2;
    OPAQUE_WIN32_KMT_BIT     :: 4;
    D3D12_FENCE_BIT          :: 8;
    SYNC_FD_BIT              :: 16;
    ZIRCON_EVENT_BIT_FUCHSIA :: 128;
    D3D11_FENCE_BIT          :: 8;
    OPAQUE_FD_BIT_KHR        :: 1;
    OPAQUE_WIN32_BIT_KHR     :: 2;
    OPAQUE_WIN32_KMT_BIT_KHR :: 4;
    D3D12_FENCE_BIT_KHR      :: 8;
    SYNC_FD_BIT_KHR          :: 16;
    FLAG_BITS_MAX_ENUM       :: 2147483647;
}

VkExternalSemaphoreHandleTypeFlags :: VkFlags;

VkExternalSemaphoreFeatureFlagBits :: enum s32 {
    EXPORTABLE_BIT     :: 1;
    IMPORTABLE_BIT     :: 2;
    EXPORTABLE_BIT_KHR :: 1;
    IMPORTABLE_BIT_KHR :: 2;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkExternalSemaphoreFeatureFlags :: VkFlags;
VkPhysicalDeviceSubgroupProperties :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    subgroupSize:              u32;
    supportedStages:           VkShaderStageFlags;
    supportedOperations:       VkSubgroupFeatureFlags;
    quadOperationsInAllStages: VkBool32;
}

VkBindBufferMemoryInfo :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    buffer:       VkBuffer;
    memory:       VkDeviceMemory;
    memoryOffset: VkDeviceSize;
}

VkBindImageMemoryInfo :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    image:        VkImage;
    memory:       VkDeviceMemory;
    memoryOffset: VkDeviceSize;
}

VkPhysicalDevice16BitStorageFeatures :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    storageBuffer16BitAccess:           VkBool32;
    uniformAndStorageBuffer16BitAccess: VkBool32;
    storagePushConstant16:              VkBool32;
    storageInputOutput16:               VkBool32;
}

VkMemoryDedicatedRequirements :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    prefersDedicatedAllocation:  VkBool32;
    requiresDedicatedAllocation: VkBool32;
}

VkMemoryDedicatedAllocateInfo :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    image:  VkImage;
    buffer: VkBuffer;
}

VkMemoryAllocateFlagsInfo :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    flags:      VkMemoryAllocateFlags;
    deviceMask: u32;
}

VkDeviceGroupRenderPassBeginInfo :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    deviceMask:            u32;
    deviceRenderAreaCount: u32;
    pDeviceRenderAreas:    *VkRect2D;
}

VkDeviceGroupCommandBufferBeginInfo :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    deviceMask: u32;
}

VkDeviceGroupSubmitInfo :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    waitSemaphoreCount:            u32;
    pWaitSemaphoreDeviceIndices:   *u32;
    commandBufferCount:            u32;
    pCommandBufferDeviceMasks:     *u32;
    signalSemaphoreCount:          u32;
    pSignalSemaphoreDeviceIndices: *u32;
}

VkDeviceGroupBindSparseInfo :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    resourceDeviceIndex: u32;
    memoryDeviceIndex:   u32;
}

VkBindBufferMemoryDeviceGroupInfo :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    deviceIndexCount: u32;
    pDeviceIndices:   *u32;
}

VkBindImageMemoryDeviceGroupInfo :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    deviceIndexCount:             u32;
    pDeviceIndices:               *u32;
    splitInstanceBindRegionCount: u32;
    pSplitInstanceBindRegions:    *VkRect2D;
}

VkPhysicalDeviceGroupProperties :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    physicalDeviceCount: u32;
    physicalDevices:     [32] VkPhysicalDevice;
    subsetAllocation:    VkBool32;
}

VkDeviceGroupDeviceCreateInfo :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    physicalDeviceCount: u32;
    pPhysicalDevices:    *VkPhysicalDevice;
}

VkBufferMemoryRequirementsInfo2 :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    buffer: VkBuffer;
}

VkImageMemoryRequirementsInfo2 :: struct {
    sType: VkStructureType;
    pNext: *void;
    image: VkImage;
}

VkImageSparseMemoryRequirementsInfo2 :: struct {
    sType: VkStructureType;
    pNext: *void;
    image: VkImage;
}

VkMemoryRequirements2 :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    memoryRequirements: VkMemoryRequirements;
}

VkSparseImageMemoryRequirements2 :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    memoryRequirements: VkSparseImageMemoryRequirements;
}

VkPhysicalDeviceFeatures2 :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    features: VkPhysicalDeviceFeatures;
}

VkPhysicalDeviceProperties2 :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    properties: VkPhysicalDeviceProperties;
}

VkFormatProperties2 :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    formatProperties: VkFormatProperties;
}

VkImageFormatProperties2 :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    imageFormatProperties: VkImageFormatProperties;
}

VkPhysicalDeviceImageFormatInfo2 :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    format: VkFormat;
    type:   VkImageType;
    tiling: VkImageTiling;
    usage:  VkImageUsageFlags;
    flags:  VkImageCreateFlags;
}

VkQueueFamilyProperties2 :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    queueFamilyProperties: VkQueueFamilyProperties;
}

VkPhysicalDeviceMemoryProperties2 :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    memoryProperties: VkPhysicalDeviceMemoryProperties;
}

VkSparseImageFormatProperties2 :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    properties: VkSparseImageFormatProperties;
}

VkPhysicalDeviceSparseImageFormatInfo2 :: struct {
    sType:   VkStructureType;
    pNext:   *void;
    format:  VkFormat;
    type:    VkImageType;
    samples: VkSampleCountFlagBits;
    usage:   VkImageUsageFlags;
    tiling:  VkImageTiling;
}

VkPhysicalDevicePointClippingProperties :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    pointClippingBehavior: VkPointClippingBehavior;
}

VkInputAttachmentAspectReference :: struct {
    subpass:              u32;
    inputAttachmentIndex: u32;
    aspectMask:           VkImageAspectFlags;
}

VkRenderPassInputAttachmentAspectCreateInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    aspectReferenceCount: u32;
    pAspectReferences:    *VkInputAttachmentAspectReference;
}

VkImageViewUsageCreateInfo :: struct {
    sType: VkStructureType;
    pNext: *void;
    usage: VkImageUsageFlags;
}

VkPipelineTessellationDomainOriginStateCreateInfo :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    domainOrigin: VkTessellationDomainOrigin;
}

VkRenderPassMultiviewCreateInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    subpassCount:         u32;
    pViewMasks:           *u32;
    dependencyCount:      u32;
    pViewOffsets:         *s32;
    correlationMaskCount: u32;
    pCorrelationMasks:    *u32;
}

VkPhysicalDeviceMultiviewFeatures :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    multiview:                   VkBool32;
    multiviewGeometryShader:     VkBool32;
    multiviewTessellationShader: VkBool32;
}

VkPhysicalDeviceMultiviewProperties :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    maxMultiviewViewCount:     u32;
    maxMultiviewInstanceIndex: u32;
}

VkPhysicalDeviceVariablePointersFeatures :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    variablePointersStorageBuffer: VkBool32;
    variablePointers:              VkBool32;
}

VkPhysicalDeviceVariablePointerFeatures :: VkPhysicalDeviceVariablePointersFeatures;

VkPhysicalDeviceProtectedMemoryFeatures :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    protectedMemory: VkBool32;
}

VkPhysicalDeviceProtectedMemoryProperties :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    protectedNoFault: VkBool32;
}

VkDeviceQueueInfo2 :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    flags:            VkDeviceQueueCreateFlags;
    queueFamilyIndex: u32;
    queueIndex:       u32;
}

VkProtectedSubmitInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    protectedSubmit: VkBool32;
}

VkSamplerYcbcrConversionCreateInfo :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    format:                      VkFormat;
    ycbcrModel:                  VkSamplerYcbcrModelConversion;
    ycbcrRange:                  VkSamplerYcbcrRange;
    components:                  VkComponentMapping;
    xChromaOffset:               VkChromaLocation;
    yChromaOffset:               VkChromaLocation;
    chromaFilter:                VkFilter;
    forceExplicitReconstruction: VkBool32;
}

VkSamplerYcbcrConversionInfo :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    conversion: VkSamplerYcbcrConversion;
}

VkBindImagePlaneMemoryInfo :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    planeAspect: VkImageAspectFlagBits;
}

VkImagePlaneMemoryRequirementsInfo :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    planeAspect: VkImageAspectFlagBits;
}

VkPhysicalDeviceSamplerYcbcrConversionFeatures :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    samplerYcbcrConversion: VkBool32;
}

VkSamplerYcbcrConversionImageFormatProperties :: struct {
    sType:                               VkStructureType;
    pNext:                               *void;
    combinedImageSamplerDescriptorCount: u32;
}

VkDescriptorUpdateTemplateEntry :: struct {
    dstBinding:      u32;
    dstArrayElement: u32;
    descriptorCount: u32;
    descriptorType:  VkDescriptorType;
    offset:          u64;
    stride:          u64;
}

VkDescriptorUpdateTemplateCreateInfo :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    flags:                      VkDescriptorUpdateTemplateCreateFlags;
    descriptorUpdateEntryCount: u32;
    pDescriptorUpdateEntries:   *VkDescriptorUpdateTemplateEntry;
    templateType:               VkDescriptorUpdateTemplateType;
    descriptorSetLayout:        VkDescriptorSetLayout;
    pipelineBindPoint:          VkPipelineBindPoint;
    pipelineLayout:             VkPipelineLayout;
    set:                        u32;
}

VkExternalMemoryProperties :: struct {
    externalMemoryFeatures:        VkExternalMemoryFeatureFlags;
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags;
    compatibleHandleTypes:         VkExternalMemoryHandleTypeFlags;
}

VkPhysicalDeviceExternalImageFormatInfo :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    handleType: VkExternalMemoryHandleTypeFlagBits;
}

VkExternalImageFormatProperties :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    externalMemoryProperties: VkExternalMemoryProperties;
}

VkPhysicalDeviceExternalBufferInfo :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    flags:      VkBufferCreateFlags;
    usage:      VkBufferUsageFlags;
    handleType: VkExternalMemoryHandleTypeFlagBits;
}

VkExternalBufferProperties :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    externalMemoryProperties: VkExternalMemoryProperties;
}

VkPhysicalDeviceIDProperties :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    deviceUUID:      [16] u8;
    driverUUID:      [16] u8;
    deviceLUID:      [8] u8;
    deviceNodeMask:  u32;
    deviceLUIDValid: VkBool32;
}

VkExternalMemoryImageCreateInfo :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    handleTypes: VkExternalMemoryHandleTypeFlags;
}

VkExternalMemoryBufferCreateInfo :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    handleTypes: VkExternalMemoryHandleTypeFlags;
}

VkExportMemoryAllocateInfo :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    handleTypes: VkExternalMemoryHandleTypeFlags;
}

VkPhysicalDeviceExternalFenceInfo :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    handleType: VkExternalFenceHandleTypeFlagBits;
}

VkExternalFenceProperties :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags;
    compatibleHandleTypes:         VkExternalFenceHandleTypeFlags;
    externalFenceFeatures:         VkExternalFenceFeatureFlags;
}

VkExportFenceCreateInfo :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    handleTypes: VkExternalFenceHandleTypeFlags;
}

VkExportSemaphoreCreateInfo :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    handleTypes: VkExternalSemaphoreHandleTypeFlags;
}

VkPhysicalDeviceExternalSemaphoreInfo :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
}

VkExternalSemaphoreProperties :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags;
    compatibleHandleTypes:         VkExternalSemaphoreHandleTypeFlags;
    externalSemaphoreFeatures:     VkExternalSemaphoreFeatureFlags;
}

VkPhysicalDeviceMaintenance3Properties :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    maxPerSetDescriptors:    u32;
    maxMemoryAllocationSize: VkDeviceSize;
}

VkDescriptorSetLayoutSupport :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    supported: VkBool32;
}

VkPhysicalDeviceShaderDrawParametersFeatures :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    shaderDrawParameters: VkBool32;
}

VkPhysicalDeviceShaderDrawParameterFeatures :: VkPhysicalDeviceShaderDrawParametersFeatures;

PFN_vkEnumerateInstanceVersion :: #type (pApiVersion: *u32) -> VkResult #c_call;
PFN_vkBindBufferMemory2 :: #type (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindBufferMemoryInfo) -> VkResult #c_call;
PFN_vkBindImageMemory2 :: #type (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindImageMemoryInfo) -> VkResult #c_call;
PFN_vkGetDeviceGroupPeerMemoryFeatures :: #type (device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags) -> void #c_call;
PFN_vkCmdSetDeviceMask :: #type (commandBuffer: VkCommandBuffer, deviceMask: u32) -> void #c_call;
PFN_vkCmdDispatchBase :: #type (commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;
PFN_vkEnumeratePhysicalDeviceGroups :: #type (instance: VkInstance, pPhysicalDeviceGroupCount: *u32, pPhysicalDeviceGroupProperties: *VkPhysicalDeviceGroupProperties) -> VkResult #c_call;
PFN_vkGetImageMemoryRequirements2 :: #type (device: VkDevice, pInfo: *VkImageMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetBufferMemoryRequirements2 :: #type (device: VkDevice, pInfo: *VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetImageSparseMemoryRequirements2 :: #type (device: VkDevice, pInfo: *VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) -> void #c_call;
PFN_vkGetPhysicalDeviceFeatures2 :: #type (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures2) -> void #c_call;
PFN_vkGetPhysicalDeviceProperties2 :: #type (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceFormatProperties2 :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceImageFormatProperties2 :: #type (physicalDevice: VkPhysicalDevice, pImageFormatInfo: *VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *VkImageFormatProperties2) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceQueueFamilyProperties2 :: #type (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceMemoryProperties2 :: #type (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 :: #type (physicalDevice: VkPhysicalDevice, pFormatInfo: *VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties2) -> void #c_call;
PFN_vkTrimCommandPool :: #type (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> void #c_call;
PFN_vkGetDeviceQueue2 :: #type (device: VkDevice, pQueueInfo: *VkDeviceQueueInfo2, pQueue: *VkQueue) -> void #c_call;
PFN_vkCreateSamplerYcbcrConversion :: #type (device: VkDevice, pCreateInfo: *VkSamplerYcbcrConversionCreateInfo, pAllocator: *VkAllocationCallbacks, pYcbcrConversion: *VkSamplerYcbcrConversion) -> VkResult #c_call;
PFN_vkDestroySamplerYcbcrConversion :: #type (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateDescriptorUpdateTemplate :: #type (device: VkDevice, pCreateInfo: *VkDescriptorUpdateTemplateCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate) -> VkResult #c_call;
PFN_vkDestroyDescriptorUpdateTemplate :: #type (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkUpdateDescriptorSetWithTemplate :: #type (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *void) -> void #c_call;
PFN_vkGetPhysicalDeviceExternalBufferProperties :: #type (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *VkExternalBufferProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceExternalFenceProperties :: #type (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *VkExternalFenceProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceExternalSemaphoreProperties :: #type (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *VkExternalSemaphoreProperties) -> void #c_call;
PFN_vkGetDescriptorSetLayoutSupport :: #type (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pSupport: *VkDescriptorSetLayoutSupport) -> void #c_call;

VkDriverId :: enum s32 {
    AMD_PROPRIETARY               :: 1;
    AMD_OPEN_SOURCE               :: 2;
    MESA_RADV                     :: 3;
    NVIDIA_PROPRIETARY            :: 4;
    INTEL_PROPRIETARY_WINDOWS     :: 5;
    INTEL_OPEN_SOURCE_MESA        :: 6;
    IMAGINATION_PROPRIETARY       :: 7;
    QUALCOMM_PROPRIETARY          :: 8;
    ARM_PROPRIETARY               :: 9;
    GOOGLE_SWIFTSHADER            :: 10;
    GGP_PROPRIETARY               :: 11;
    BROADCOM_PROPRIETARY          :: 12;
    MESA_LLVMPIPE                 :: 13;
    MOLTENVK                      :: 14;
    COREAVI_PROPRIETARY           :: 15;
    JUICE_PROPRIETARY             :: 16;
    VERISILICON_PROPRIETARY       :: 17;
    MESA_TURNIP                   :: 18;
    MESA_V3DV                     :: 19;
    MESA_PANVK                    :: 20;
    SAMSUNG_PROPRIETARY           :: 21;
    MESA_VENUS                    :: 22;
    MESA_DOZEN                    :: 23;
    MESA_NVK                      :: 24;
    IMAGINATION_OPEN_SOURCE_MESA  :: 25;
    MESA_AGXV                     :: 26;
    AMD_PROPRIETARY_KHR           :: 1;
    AMD_OPEN_SOURCE_KHR           :: 2;
    MESA_RADV_KHR                 :: 3;
    NVIDIA_PROPRIETARY_KHR        :: 4;
    INTEL_PROPRIETARY_WINDOWS_KHR :: 5;
    INTEL_OPEN_SOURCE_MESA_KHR    :: 6;
    IMAGINATION_PROPRIETARY_KHR   :: 7;
    QUALCOMM_PROPRIETARY_KHR      :: 8;
    ARM_PROPRIETARY_KHR           :: 9;
    GOOGLE_SWIFTSHADER_KHR        :: 10;
    GGP_PROPRIETARY_KHR           :: 11;
    BROADCOM_PROPRIETARY_KHR      :: 12;
    MAX_ENUM                      :: 2147483647;
}

VkShaderFloatControlsIndependence :: enum s32 {
    _32_BIT_ONLY     :: 0;
    ALL              :: 1;
    NONE             :: 2;
    _32_BIT_ONLY_KHR :: 0;
    ALL_KHR          :: 1;
    NONE_KHR         :: 2;
    MAX_ENUM         :: 2147483647;
}

VkSamplerReductionMode :: enum s32 {
    WEIGHTED_AVERAGE                 :: 0;
    MIN                              :: 1;
    MAX                              :: 2;
    WEIGHTED_AVERAGE_RANGECLAMP_QCOM :: 1000521000;
    WEIGHTED_AVERAGE_EXT             :: 0;
    MIN_EXT                          :: 1;
    MAX_EXT                          :: 2;
    MAX_ENUM                         :: 2147483647;
}

VkSemaphoreType :: enum s32 {
    BINARY       :: 0;
    TIMELINE     :: 1;
    BINARY_KHR   :: 0;
    TIMELINE_KHR :: 1;
    MAX_ENUM     :: 2147483647;
}

VkResolveModeFlagBits :: enum s32 {
    NONE                               :: 0;
    SAMPLE_ZERO_BIT                    :: 1;
    AVERAGE_BIT                        :: 2;
    MIN_BIT                            :: 4;
    MAX_BIT                            :: 8;
    EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID :: 16;
    NONE_KHR                           :: 0;
    SAMPLE_ZERO_BIT_KHR                :: 1;
    AVERAGE_BIT_KHR                    :: 2;
    MIN_BIT_KHR                        :: 4;
    MAX_BIT_KHR                        :: 8;
    FLAG_BITS_MAX_ENUM                 :: 2147483647;
}

VkResolveModeFlags :: VkFlags;

VkDescriptorBindingFlagBits :: enum s32 {
    UPDATE_AFTER_BIND_BIT               :: 1;
    UPDATE_UNUSED_WHILE_PENDING_BIT     :: 2;
    PARTIALLY_BOUND_BIT                 :: 4;
    VARIABLE_DESCRIPTOR_COUNT_BIT       :: 8;
    UPDATE_AFTER_BIND_BIT_EXT           :: 1;
    UPDATE_UNUSED_WHILE_PENDING_BIT_EXT :: 2;
    PARTIALLY_BOUND_BIT_EXT             :: 4;
    VARIABLE_DESCRIPTOR_COUNT_BIT_EXT   :: 8;
    FLAG_BITS_MAX_ENUM                  :: 2147483647;
}

VkDescriptorBindingFlags :: VkFlags;

VkSemaphoreWaitFlagBits :: enum s32 {
    ANY_BIT            :: 1;
    ANY_BIT_KHR        :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkSemaphoreWaitFlags :: VkFlags;
VkPhysicalDeviceVulkan11Features :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    storageBuffer16BitAccess:           VkBool32;
    uniformAndStorageBuffer16BitAccess: VkBool32;
    storagePushConstant16:              VkBool32;
    storageInputOutput16:               VkBool32;
    multiview:                          VkBool32;
    multiviewGeometryShader:            VkBool32;
    multiviewTessellationShader:        VkBool32;
    variablePointersStorageBuffer:      VkBool32;
    variablePointers:                   VkBool32;
    protectedMemory:                    VkBool32;
    samplerYcbcrConversion:             VkBool32;
    shaderDrawParameters:               VkBool32;
}

VkPhysicalDeviceVulkan11Properties :: struct {
    sType:                             VkStructureType;
    pNext:                             *void;
    deviceUUID:                        [16] u8;
    driverUUID:                        [16] u8;
    deviceLUID:                        [8] u8;
    deviceNodeMask:                    u32;
    deviceLUIDValid:                   VkBool32;
    subgroupSize:                      u32;
    subgroupSupportedStages:           VkShaderStageFlags;
    subgroupSupportedOperations:       VkSubgroupFeatureFlags;
    subgroupQuadOperationsInAllStages: VkBool32;
    pointClippingBehavior:             VkPointClippingBehavior;
    maxMultiviewViewCount:             u32;
    maxMultiviewInstanceIndex:         u32;
    protectedNoFault:                  VkBool32;
    maxPerSetDescriptors:              u32;
    maxMemoryAllocationSize:           VkDeviceSize;
}

VkPhysicalDeviceVulkan12Features :: struct {
    sType:                                              VkStructureType;
    pNext:                                              *void;
    samplerMirrorClampToEdge:                           VkBool32;
    drawIndirectCount:                                  VkBool32;
    storageBuffer8BitAccess:                            VkBool32;
    uniformAndStorageBuffer8BitAccess:                  VkBool32;
    storagePushConstant8:                               VkBool32;
    shaderBufferInt64Atomics:                           VkBool32;
    shaderSharedInt64Atomics:                           VkBool32;
    shaderFloat16:                                      VkBool32;
    shaderInt8:                                         VkBool32;
    descriptorIndexing:                                 VkBool32;
    shaderInputAttachmentArrayDynamicIndexing:          VkBool32;
    shaderUniformTexelBufferArrayDynamicIndexing:       VkBool32;
    shaderStorageTexelBufferArrayDynamicIndexing:       VkBool32;
    shaderUniformBufferArrayNonUniformIndexing:         VkBool32;
    shaderSampledImageArrayNonUniformIndexing:          VkBool32;
    shaderStorageBufferArrayNonUniformIndexing:         VkBool32;
    shaderStorageImageArrayNonUniformIndexing:          VkBool32;
    shaderInputAttachmentArrayNonUniformIndexing:       VkBool32;
    shaderUniformTexelBufferArrayNonUniformIndexing:    VkBool32;
    shaderStorageTexelBufferArrayNonUniformIndexing:    VkBool32;
    descriptorBindingUniformBufferUpdateAfterBind:      VkBool32;
    descriptorBindingSampledImageUpdateAfterBind:       VkBool32;
    descriptorBindingStorageImageUpdateAfterBind:       VkBool32;
    descriptorBindingStorageBufferUpdateAfterBind:      VkBool32;
    descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingUpdateUnusedWhilePending:          VkBool32;
    descriptorBindingPartiallyBound:                    VkBool32;
    descriptorBindingVariableDescriptorCount:           VkBool32;
    runtimeDescriptorArray:                             VkBool32;
    samplerFilterMinmax:                                VkBool32;
    scalarBlockLayout:                                  VkBool32;
    imagelessFramebuffer:                               VkBool32;
    uniformBufferStandardLayout:                        VkBool32;
    shaderSubgroupExtendedTypes:                        VkBool32;
    separateDepthStencilLayouts:                        VkBool32;
    hostQueryReset:                                     VkBool32;
    timelineSemaphore:                                  VkBool32;
    bufferDeviceAddress:                                VkBool32;
    bufferDeviceAddressCaptureReplay:                   VkBool32;
    bufferDeviceAddressMultiDevice:                     VkBool32;
    vulkanMemoryModel:                                  VkBool32;
    vulkanMemoryModelDeviceScope:                       VkBool32;
    vulkanMemoryModelAvailabilityVisibilityChains:      VkBool32;
    shaderOutputViewportIndex:                          VkBool32;
    shaderOutputLayer:                                  VkBool32;
    subgroupBroadcastDynamicId:                         VkBool32;
}

VkConformanceVersion :: struct {
    major:    u8;
    minor:    u8;
    subminor: u8;
    patch:    u8;
}

VkPhysicalDeviceVulkan12Properties :: struct {
    sType:                                                VkStructureType;
    pNext:                                                *void;
    driverID:                                             VkDriverId;
    driverName:                                           [256] u8;
    driverInfo:                                           [256] u8;
    conformanceVersion:                                   VkConformanceVersion;
    denormBehaviorIndependence:                           VkShaderFloatControlsIndependence;
    roundingModeIndependence:                             VkShaderFloatControlsIndependence;
    shaderSignedZeroInfNanPreserveFloat16:                VkBool32;
    shaderSignedZeroInfNanPreserveFloat32:                VkBool32;
    shaderSignedZeroInfNanPreserveFloat64:                VkBool32;
    shaderDenormPreserveFloat16:                          VkBool32;
    shaderDenormPreserveFloat32:                          VkBool32;
    shaderDenormPreserveFloat64:                          VkBool32;
    shaderDenormFlushToZeroFloat16:                       VkBool32;
    shaderDenormFlushToZeroFloat32:                       VkBool32;
    shaderDenormFlushToZeroFloat64:                       VkBool32;
    shaderRoundingModeRTEFloat16:                         VkBool32;
    shaderRoundingModeRTEFloat32:                         VkBool32;
    shaderRoundingModeRTEFloat64:                         VkBool32;
    shaderRoundingModeRTZFloat16:                         VkBool32;
    shaderRoundingModeRTZFloat32:                         VkBool32;
    shaderRoundingModeRTZFloat64:                         VkBool32;
    maxUpdateAfterBindDescriptorsInAllPools:              u32;
    shaderUniformBufferArrayNonUniformIndexingNative:     VkBool32;
    shaderSampledImageArrayNonUniformIndexingNative:      VkBool32;
    shaderStorageBufferArrayNonUniformIndexingNative:     VkBool32;
    shaderStorageImageArrayNonUniformIndexingNative:      VkBool32;
    shaderInputAttachmentArrayNonUniformIndexingNative:   VkBool32;
    robustBufferAccessUpdateAfterBind:                    VkBool32;
    quadDivergentImplicitLod:                             VkBool32;
    maxPerStageDescriptorUpdateAfterBindSamplers:         u32;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers:   u32;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers:   u32;
    maxPerStageDescriptorUpdateAfterBindSampledImages:    u32;
    maxPerStageDescriptorUpdateAfterBindStorageImages:    u32;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32;
    maxPerStageUpdateAfterBindResources:                  u32;
    maxDescriptorSetUpdateAfterBindSamplers:              u32;
    maxDescriptorSetUpdateAfterBindUniformBuffers:        u32;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32;
    maxDescriptorSetUpdateAfterBindStorageBuffers:        u32;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32;
    maxDescriptorSetUpdateAfterBindSampledImages:         u32;
    maxDescriptorSetUpdateAfterBindStorageImages:         u32;
    maxDescriptorSetUpdateAfterBindInputAttachments:      u32;
    supportedDepthResolveModes:                           VkResolveModeFlags;
    supportedStencilResolveModes:                         VkResolveModeFlags;
    independentResolveNone:                               VkBool32;
    independentResolve:                                   VkBool32;
    filterMinmaxSingleComponentFormats:                   VkBool32;
    filterMinmaxImageComponentMapping:                    VkBool32;
    maxTimelineSemaphoreValueDifference:                  u64;
    framebufferIntegerColorSampleCounts:                  VkSampleCountFlags;
}

VkImageFormatListCreateInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    viewFormatCount: u32;
    pViewFormats:    *VkFormat;
}

VkAttachmentDescription2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    flags:          VkAttachmentDescriptionFlags;
    format:         VkFormat;
    samples:        VkSampleCountFlagBits;
    loadOp:         VkAttachmentLoadOp;
    storeOp:        VkAttachmentStoreOp;
    stencilLoadOp:  VkAttachmentLoadOp;
    stencilStoreOp: VkAttachmentStoreOp;
    initialLayout:  VkImageLayout;
    finalLayout:    VkImageLayout;
}

VkAttachmentReference2 :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    attachment: u32;
    layout:     VkImageLayout;
    aspectMask: VkImageAspectFlags;
}

VkSubpassDescription2 :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    flags:                   VkSubpassDescriptionFlags;
    pipelineBindPoint:       VkPipelineBindPoint;
    viewMask:                u32;
    inputAttachmentCount:    u32;
    pInputAttachments:       *VkAttachmentReference2;
    colorAttachmentCount:    u32;
    pColorAttachments:       *VkAttachmentReference2;
    pResolveAttachments:     *VkAttachmentReference2;
    pDepthStencilAttachment: *VkAttachmentReference2;
    preserveAttachmentCount: u32;
    pPreserveAttachments:    *u32;
}

VkSubpassDependency2 :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    srcSubpass:      u32;
    dstSubpass:      u32;
    srcStageMask:    VkPipelineStageFlags;
    dstStageMask:    VkPipelineStageFlags;
    srcAccessMask:   VkAccessFlags;
    dstAccessMask:   VkAccessFlags;
    dependencyFlags: VkDependencyFlags;
    viewOffset:      s32;
}

VkRenderPassCreateInfo2 :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    flags:                   VkRenderPassCreateFlags;
    attachmentCount:         u32;
    pAttachments:            *VkAttachmentDescription2;
    subpassCount:            u32;
    pSubpasses:              *VkSubpassDescription2;
    dependencyCount:         u32;
    pDependencies:           *VkSubpassDependency2;
    correlatedViewMaskCount: u32;
    pCorrelatedViewMasks:    *u32;
}

VkSubpassBeginInfo :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    contents: VkSubpassContents;
}

VkSubpassEndInfo :: struct {
    sType: VkStructureType;
    pNext: *void;
}

VkPhysicalDevice8BitStorageFeatures :: struct {
    sType:                             VkStructureType;
    pNext:                             *void;
    storageBuffer8BitAccess:           VkBool32;
    uniformAndStorageBuffer8BitAccess: VkBool32;
    storagePushConstant8:              VkBool32;
}

VkPhysicalDeviceDriverProperties :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    driverID:           VkDriverId;
    driverName:         [256] u8;
    driverInfo:         [256] u8;
    conformanceVersion: VkConformanceVersion;
}

VkPhysicalDeviceShaderAtomicInt64Features :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    shaderBufferInt64Atomics: VkBool32;
    shaderSharedInt64Atomics: VkBool32;
}

VkPhysicalDeviceShaderFloat16Int8Features :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    shaderFloat16: VkBool32;
    shaderInt8:    VkBool32;
}

VkPhysicalDeviceFloatControlsProperties :: struct {
    sType:                                 VkStructureType;
    pNext:                                 *void;
    denormBehaviorIndependence:            VkShaderFloatControlsIndependence;
    roundingModeIndependence:              VkShaderFloatControlsIndependence;
    shaderSignedZeroInfNanPreserveFloat16: VkBool32;
    shaderSignedZeroInfNanPreserveFloat32: VkBool32;
    shaderSignedZeroInfNanPreserveFloat64: VkBool32;
    shaderDenormPreserveFloat16:           VkBool32;
    shaderDenormPreserveFloat32:           VkBool32;
    shaderDenormPreserveFloat64:           VkBool32;
    shaderDenormFlushToZeroFloat16:        VkBool32;
    shaderDenormFlushToZeroFloat32:        VkBool32;
    shaderDenormFlushToZeroFloat64:        VkBool32;
    shaderRoundingModeRTEFloat16:          VkBool32;
    shaderRoundingModeRTEFloat32:          VkBool32;
    shaderRoundingModeRTEFloat64:          VkBool32;
    shaderRoundingModeRTZFloat16:          VkBool32;
    shaderRoundingModeRTZFloat32:          VkBool32;
    shaderRoundingModeRTZFloat64:          VkBool32;
}

VkDescriptorSetLayoutBindingFlagsCreateInfo :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    bindingCount:  u32;
    pBindingFlags: *VkDescriptorBindingFlags;
}

VkPhysicalDeviceDescriptorIndexingFeatures :: struct {
    sType:                                              VkStructureType;
    pNext:                                              *void;
    shaderInputAttachmentArrayDynamicIndexing:          VkBool32;
    shaderUniformTexelBufferArrayDynamicIndexing:       VkBool32;
    shaderStorageTexelBufferArrayDynamicIndexing:       VkBool32;
    shaderUniformBufferArrayNonUniformIndexing:         VkBool32;
    shaderSampledImageArrayNonUniformIndexing:          VkBool32;
    shaderStorageBufferArrayNonUniformIndexing:         VkBool32;
    shaderStorageImageArrayNonUniformIndexing:          VkBool32;
    shaderInputAttachmentArrayNonUniformIndexing:       VkBool32;
    shaderUniformTexelBufferArrayNonUniformIndexing:    VkBool32;
    shaderStorageTexelBufferArrayNonUniformIndexing:    VkBool32;
    descriptorBindingUniformBufferUpdateAfterBind:      VkBool32;
    descriptorBindingSampledImageUpdateAfterBind:       VkBool32;
    descriptorBindingStorageImageUpdateAfterBind:       VkBool32;
    descriptorBindingStorageBufferUpdateAfterBind:      VkBool32;
    descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingUpdateUnusedWhilePending:          VkBool32;
    descriptorBindingPartiallyBound:                    VkBool32;
    descriptorBindingVariableDescriptorCount:           VkBool32;
    runtimeDescriptorArray:                             VkBool32;
}

VkPhysicalDeviceDescriptorIndexingProperties :: struct {
    sType:                                                VkStructureType;
    pNext:                                                *void;
    maxUpdateAfterBindDescriptorsInAllPools:              u32;
    shaderUniformBufferArrayNonUniformIndexingNative:     VkBool32;
    shaderSampledImageArrayNonUniformIndexingNative:      VkBool32;
    shaderStorageBufferArrayNonUniformIndexingNative:     VkBool32;
    shaderStorageImageArrayNonUniformIndexingNative:      VkBool32;
    shaderInputAttachmentArrayNonUniformIndexingNative:   VkBool32;
    robustBufferAccessUpdateAfterBind:                    VkBool32;
    quadDivergentImplicitLod:                             VkBool32;
    maxPerStageDescriptorUpdateAfterBindSamplers:         u32;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers:   u32;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers:   u32;
    maxPerStageDescriptorUpdateAfterBindSampledImages:    u32;
    maxPerStageDescriptorUpdateAfterBindStorageImages:    u32;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32;
    maxPerStageUpdateAfterBindResources:                  u32;
    maxDescriptorSetUpdateAfterBindSamplers:              u32;
    maxDescriptorSetUpdateAfterBindUniformBuffers:        u32;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32;
    maxDescriptorSetUpdateAfterBindStorageBuffers:        u32;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32;
    maxDescriptorSetUpdateAfterBindSampledImages:         u32;
    maxDescriptorSetUpdateAfterBindStorageImages:         u32;
    maxDescriptorSetUpdateAfterBindInputAttachments:      u32;
}

VkDescriptorSetVariableDescriptorCountAllocateInfo :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    descriptorSetCount: u32;
    pDescriptorCounts:  *u32;
}

VkDescriptorSetVariableDescriptorCountLayoutSupport :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    maxVariableDescriptorCount: u32;
}

VkSubpassDescriptionDepthStencilResolve :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    depthResolveMode:               VkResolveModeFlagBits;
    stencilResolveMode:             VkResolveModeFlagBits;
    pDepthStencilResolveAttachment: *VkAttachmentReference2;
}

VkPhysicalDeviceDepthStencilResolveProperties :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    supportedDepthResolveModes:   VkResolveModeFlags;
    supportedStencilResolveModes: VkResolveModeFlags;
    independentResolveNone:       VkBool32;
    independentResolve:           VkBool32;
}

VkPhysicalDeviceScalarBlockLayoutFeatures :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    scalarBlockLayout: VkBool32;
}

VkImageStencilUsageCreateInfo :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    stencilUsage: VkImageUsageFlags;
}

VkSamplerReductionModeCreateInfo :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    reductionMode: VkSamplerReductionMode;
}

VkPhysicalDeviceSamplerFilterMinmaxProperties :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    filterMinmaxSingleComponentFormats: VkBool32;
    filterMinmaxImageComponentMapping:  VkBool32;
}

VkPhysicalDeviceVulkanMemoryModelFeatures :: struct {
    sType:                                         VkStructureType;
    pNext:                                         *void;
    vulkanMemoryModel:                             VkBool32;
    vulkanMemoryModelDeviceScope:                  VkBool32;
    vulkanMemoryModelAvailabilityVisibilityChains: VkBool32;
}

VkPhysicalDeviceImagelessFramebufferFeatures :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    imagelessFramebuffer: VkBool32;
}

VkFramebufferAttachmentImageInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkImageCreateFlags;
    usage:           VkImageUsageFlags;
    width:           u32;
    height:          u32;
    layerCount:      u32;
    viewFormatCount: u32;
    pViewFormats:    *VkFormat;
}

VkFramebufferAttachmentsCreateInfo :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    attachmentImageInfoCount: u32;
    pAttachmentImageInfos:    *VkFramebufferAttachmentImageInfo;
}

VkRenderPassAttachmentBeginInfo :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    attachmentCount: u32;
    pAttachments:    *VkImageView;
}

VkPhysicalDeviceUniformBufferStandardLayoutFeatures :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    uniformBufferStandardLayout: VkBool32;
}

VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    shaderSubgroupExtendedTypes: VkBool32;
}

VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    separateDepthStencilLayouts: VkBool32;
}

VkAttachmentReferenceStencilLayout :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    stencilLayout: VkImageLayout;
}

VkAttachmentDescriptionStencilLayout :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    stencilInitialLayout: VkImageLayout;
    stencilFinalLayout:   VkImageLayout;
}

VkPhysicalDeviceHostQueryResetFeatures :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    hostQueryReset: VkBool32;
}

VkPhysicalDeviceTimelineSemaphoreFeatures :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    timelineSemaphore: VkBool32;
}

VkPhysicalDeviceTimelineSemaphoreProperties :: struct {
    sType:                               VkStructureType;
    pNext:                               *void;
    maxTimelineSemaphoreValueDifference: u64;
}

VkSemaphoreTypeCreateInfo :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    semaphoreType: VkSemaphoreType;
    initialValue:  u64;
}

VkTimelineSemaphoreSubmitInfo :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    waitSemaphoreValueCount:   u32;
    pWaitSemaphoreValues:      *u64;
    signalSemaphoreValueCount: u32;
    pSignalSemaphoreValues:    *u64;
}

VkSemaphoreWaitInfo :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    flags:          VkSemaphoreWaitFlags;
    semaphoreCount: u32;
    pSemaphores:    *VkSemaphore;
    pValues:        *u64;
}

VkSemaphoreSignalInfo :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    semaphore: VkSemaphore;
    value:     u64;
}

VkPhysicalDeviceBufferDeviceAddressFeatures :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    bufferDeviceAddress:              VkBool32;
    bufferDeviceAddressCaptureReplay: VkBool32;
    bufferDeviceAddressMultiDevice:   VkBool32;
}

VkBufferDeviceAddressInfo :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    buffer: VkBuffer;
}

VkBufferOpaqueCaptureAddressCreateInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    opaqueCaptureAddress: u64;
}

VkMemoryOpaqueCaptureAddressAllocateInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    opaqueCaptureAddress: u64;
}

VkDeviceMemoryOpaqueCaptureAddressInfo :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    memory: VkDeviceMemory;
}

PFN_vkCmdDrawIndirectCount :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawIndexedIndirectCount :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;
PFN_vkCreateRenderPass2 :: #type (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo2, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) -> VkResult #c_call;
PFN_vkCmdBeginRenderPass2 :: #type (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, pSubpassBeginInfo: *VkSubpassBeginInfo) -> void #c_call;
PFN_vkCmdNextSubpass2 :: #type (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *VkSubpassBeginInfo, pSubpassEndInfo: *VkSubpassEndInfo) -> void #c_call;
PFN_vkCmdEndRenderPass2 :: #type (commandBuffer: VkCommandBuffer, pSubpassEndInfo: *VkSubpassEndInfo) -> void #c_call;
PFN_vkResetQueryPool :: #type (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> void #c_call;
PFN_vkGetSemaphoreCounterValue :: #type (device: VkDevice, semaphore: VkSemaphore, pValue: *u64) -> VkResult #c_call;
PFN_vkWaitSemaphores :: #type (device: VkDevice, pWaitInfo: *VkSemaphoreWaitInfo, timeout: u64) -> VkResult #c_call;
PFN_vkSignalSemaphore :: #type (device: VkDevice, pSignalInfo: *VkSemaphoreSignalInfo) -> VkResult #c_call;
PFN_vkGetBufferDeviceAddress :: #type (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) -> VkDeviceAddress #c_call;
PFN_vkGetBufferOpaqueCaptureAddress :: #type (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) -> u64 #c_call;
PFN_vkGetDeviceMemoryOpaqueCaptureAddress :: #type (device: VkDevice, pInfo: *VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64 #c_call;

VkFlags64 :: u64;
VkPrivateDataSlot_T :: struct {}
VkPrivateDataSlot :: *VkPrivateDataSlot_T;

VkPipelineCreationFeedbackFlagBits :: enum s32 {
    VALID_BIT                              :: 1;
    APPLICATION_PIPELINE_CACHE_HIT_BIT     :: 2;
    BASE_PIPELINE_ACCELERATION_BIT         :: 4;
    VALID_BIT_EXT                          :: 1;
    APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT :: 2;
    BASE_PIPELINE_ACCELERATION_BIT_EXT     :: 4;
    FLAG_BITS_MAX_ENUM                     :: 2147483647;
}

VkPipelineCreationFeedbackFlags :: VkFlags;

VkToolPurposeFlagBits :: enum s32 {
    VALIDATION_BIT              :: 1;
    PROFILING_BIT               :: 2;
    TRACING_BIT                 :: 4;
    ADDITIONAL_FEATURES_BIT     :: 8;
    MODIFYING_FEATURES_BIT      :: 16;
    DEBUG_REPORTING_BIT_EXT     :: 32;
    DEBUG_MARKERS_BIT_EXT       :: 64;
    VALIDATION_BIT_EXT          :: 1;
    PROFILING_BIT_EXT           :: 2;
    TRACING_BIT_EXT             :: 4;
    ADDITIONAL_FEATURES_BIT_EXT :: 8;
    MODIFYING_FEATURES_BIT_EXT  :: 16;
    FLAG_BITS_MAX_ENUM          :: 2147483647;
}

VkToolPurposeFlags :: VkFlags;
VkPrivateDataSlotCreateFlags :: VkFlags;
VkPipelineStageFlags2 :: VkFlags64;

// Flag bits for VkPipelineStageFlagBits2
VkPipelineStageFlagBits2 :: VkFlags64;
VK_PIPELINE_STAGE_2_NONE: VkPipelineStageFlagBits2 : 0;
VK_PIPELINE_STAGE_2_NONE_KHR: VkPipelineStageFlagBits2 : 0;
VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT: VkPipelineStageFlagBits2 : 1;
VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR: VkPipelineStageFlagBits2 : 1;
VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT: VkPipelineStageFlagBits2 : 2;
VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR: VkPipelineStageFlagBits2 : 2;
VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT: VkPipelineStageFlagBits2 : 4;
VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR: VkPipelineStageFlagBits2 : 4;
VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT: VkPipelineStageFlagBits2 : 8;
VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR: VkPipelineStageFlagBits2 : 8;
VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT: VkPipelineStageFlagBits2 : 16;
VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR: VkPipelineStageFlagBits2 : 16;
VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT: VkPipelineStageFlagBits2 : 32;
VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR: VkPipelineStageFlagBits2 : 32;
VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT: VkPipelineStageFlagBits2 : 64;
VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR: VkPipelineStageFlagBits2 : 64;
VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT: VkPipelineStageFlagBits2 : 128;
VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR: VkPipelineStageFlagBits2 : 128;
VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits2 : 256;
VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR: VkPipelineStageFlagBits2 : 256;
VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits2 : 512;
VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR: VkPipelineStageFlagBits2 : 512;
VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT: VkPipelineStageFlagBits2 : 1024;
VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR: VkPipelineStageFlagBits2 : 1024;
VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT: VkPipelineStageFlagBits2 : 2048;
VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR: VkPipelineStageFlagBits2 : 2048;
VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT: VkPipelineStageFlagBits2 : 4096;
VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR: VkPipelineStageFlagBits2 : 4096;
VK_PIPELINE_STAGE_2_TRANSFER_BIT: VkPipelineStageFlagBits2 : 4096;
VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR: VkPipelineStageFlagBits2 : 4096;
VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT: VkPipelineStageFlagBits2 : 8192;
VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR: VkPipelineStageFlagBits2 : 8192;
VK_PIPELINE_STAGE_2_HOST_BIT: VkPipelineStageFlagBits2 : 16384;
VK_PIPELINE_STAGE_2_HOST_BIT_KHR: VkPipelineStageFlagBits2 : 16384;
VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT: VkPipelineStageFlagBits2 : 32768;
VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR: VkPipelineStageFlagBits2 : 32768;
VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT: VkPipelineStageFlagBits2 : 65536;
VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR: VkPipelineStageFlagBits2 : 65536;
VK_PIPELINE_STAGE_2_COPY_BIT: VkPipelineStageFlagBits2 : 4294967296;
VK_PIPELINE_STAGE_2_COPY_BIT_KHR: VkPipelineStageFlagBits2 : 4294967296;
VK_PIPELINE_STAGE_2_RESOLVE_BIT: VkPipelineStageFlagBits2 : 8589934592;
VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR: VkPipelineStageFlagBits2 : 8589934592;
VK_PIPELINE_STAGE_2_BLIT_BIT: VkPipelineStageFlagBits2 : 17179869184;
VK_PIPELINE_STAGE_2_BLIT_BIT_KHR: VkPipelineStageFlagBits2 : 17179869184;
VK_PIPELINE_STAGE_2_CLEAR_BIT: VkPipelineStageFlagBits2 : 34359738368;
VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR: VkPipelineStageFlagBits2 : 34359738368;
VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT: VkPipelineStageFlagBits2 : 68719476736;
VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR: VkPipelineStageFlagBits2 : 68719476736;
VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT: VkPipelineStageFlagBits2 : 137438953472;
VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR: VkPipelineStageFlagBits2 : 137438953472;
VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT: VkPipelineStageFlagBits2 : 274877906944;
VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR: VkPipelineStageFlagBits2 : 274877906944;
VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR: VkPipelineStageFlagBits2 : 67108864;

VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT: VkPipelineStageFlagBits2 : 16777216;
VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT: VkPipelineStageFlagBits2 : 262144;
VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV: VkPipelineStageFlagBits2 : 131072;
VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkPipelineStageFlagBits2 : 4194304;
VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV: VkPipelineStageFlagBits2 : 4194304;
VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR: VkPipelineStageFlagBits2 : 33554432;
VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR: VkPipelineStageFlagBits2 : 2097152;
VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV: VkPipelineStageFlagBits2 : 2097152;
VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV: VkPipelineStageFlagBits2 : 33554432;
VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT: VkPipelineStageFlagBits2 : 8388608;
VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV: VkPipelineStageFlagBits2 : 524288;
VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV: VkPipelineStageFlagBits2 : 1048576;
VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT: VkPipelineStageFlagBits2 : 524288;
VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT: VkPipelineStageFlagBits2 : 1048576;
VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI: VkPipelineStageFlagBits2 : 549755813888;
VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI: VkPipelineStageFlagBits2 : 549755813888;
VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI: VkPipelineStageFlagBits2 : 1099511627776;
VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR: VkPipelineStageFlagBits2 : 268435456;
VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT: VkPipelineStageFlagBits2 : 1073741824;
VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI: VkPipelineStageFlagBits2 : 2199023255552;
VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV: VkPipelineStageFlagBits2 : 536870912;

VkAccessFlags2 :: VkFlags64;

// Flag bits for VkAccessFlagBits2
VkAccessFlagBits2 :: VkFlags64;
VK_ACCESS_2_NONE: VkAccessFlagBits2 : 0;
VK_ACCESS_2_NONE_KHR: VkAccessFlagBits2 : 0;
VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT: VkAccessFlagBits2 : 1;
VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR: VkAccessFlagBits2 : 1;
VK_ACCESS_2_INDEX_READ_BIT: VkAccessFlagBits2 : 2;
VK_ACCESS_2_INDEX_READ_BIT_KHR: VkAccessFlagBits2 : 2;
VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT: VkAccessFlagBits2 : 4;
VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR: VkAccessFlagBits2 : 4;
VK_ACCESS_2_UNIFORM_READ_BIT: VkAccessFlagBits2 : 8;
VK_ACCESS_2_UNIFORM_READ_BIT_KHR: VkAccessFlagBits2 : 8;
VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT: VkAccessFlagBits2 : 16;
VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits2 : 16;
VK_ACCESS_2_SHADER_READ_BIT: VkAccessFlagBits2 : 32;
VK_ACCESS_2_SHADER_READ_BIT_KHR: VkAccessFlagBits2 : 32;
VK_ACCESS_2_SHADER_WRITE_BIT: VkAccessFlagBits2 : 64;
VK_ACCESS_2_SHADER_WRITE_BIT_KHR: VkAccessFlagBits2 : 64;
VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT: VkAccessFlagBits2 : 128;
VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits2 : 128;
VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT: VkAccessFlagBits2 : 256;
VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR: VkAccessFlagBits2 : 256;
VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT: VkAccessFlagBits2 : 512;
VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits2 : 512;
VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: VkAccessFlagBits2 : 1024;
VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR: VkAccessFlagBits2 : 1024;
VK_ACCESS_2_TRANSFER_READ_BIT: VkAccessFlagBits2 : 2048;
VK_ACCESS_2_TRANSFER_READ_BIT_KHR: VkAccessFlagBits2 : 2048;
VK_ACCESS_2_TRANSFER_WRITE_BIT: VkAccessFlagBits2 : 4096;
VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR: VkAccessFlagBits2 : 4096;
VK_ACCESS_2_HOST_READ_BIT: VkAccessFlagBits2 : 8192;
VK_ACCESS_2_HOST_READ_BIT_KHR: VkAccessFlagBits2 : 8192;
VK_ACCESS_2_HOST_WRITE_BIT: VkAccessFlagBits2 : 16384;
VK_ACCESS_2_HOST_WRITE_BIT_KHR: VkAccessFlagBits2 : 16384;
VK_ACCESS_2_MEMORY_READ_BIT: VkAccessFlagBits2 : 32768;
VK_ACCESS_2_MEMORY_READ_BIT_KHR: VkAccessFlagBits2 : 32768;
VK_ACCESS_2_MEMORY_WRITE_BIT: VkAccessFlagBits2 : 65536;
VK_ACCESS_2_MEMORY_WRITE_BIT_KHR: VkAccessFlagBits2 : 65536;
VK_ACCESS_2_SHADER_SAMPLED_READ_BIT: VkAccessFlagBits2 : 4294967296;
VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR: VkAccessFlagBits2 : 4294967296;
VK_ACCESS_2_SHADER_STORAGE_READ_BIT: VkAccessFlagBits2 : 8589934592;
VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR: VkAccessFlagBits2 : 8589934592;
VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT: VkAccessFlagBits2 : 17179869184;
VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR: VkAccessFlagBits2 : 17179869184;
VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR: VkAccessFlagBits2 : 34359738368;
VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR: VkAccessFlagBits2 : 68719476736;

VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: VkAccessFlagBits2 : 33554432;
VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: VkAccessFlagBits2 : 67108864;
VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: VkAccessFlagBits2 : 134217728;
VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT: VkAccessFlagBits2 : 1048576;
VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV: VkAccessFlagBits2 : 131072;
VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV: VkAccessFlagBits2 : 262144;
VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits2 : 8388608;
VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV: VkAccessFlagBits2 : 8388608;
VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR: VkAccessFlagBits2 : 2097152;
VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR: VkAccessFlagBits2 : 4194304;
VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV: VkAccessFlagBits2 : 2097152;
VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV: VkAccessFlagBits2 : 4194304;
VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: VkAccessFlagBits2 : 16777216;
VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: VkAccessFlagBits2 : 524288;
VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT: VkAccessFlagBits2 : 2199023255552;
VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI: VkAccessFlagBits2 : 549755813888;
VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR: VkAccessFlagBits2 : 1099511627776;
VK_ACCESS_2_MICROMAP_READ_BIT_EXT: VkAccessFlagBits2 : 17592186044416;
VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT: VkAccessFlagBits2 : 35184372088832;
VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV: VkAccessFlagBits2 : 4398046511104;
VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV: VkAccessFlagBits2 : 8796093022208;

VkSubmitFlagBits :: enum s32 {
    PROTECTED_BIT      :: 1;
    PROTECTED_BIT_KHR  :: 1;
    FLAG_BITS_MAX_ENUM :: 2147483647;
}

VkSubmitFlags :: VkFlags;

VkRenderingFlagBits :: enum s32 {
    CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT     :: 1;
    SUSPENDING_BIT                             :: 2;
    RESUMING_BIT                               :: 4;
    CONTENTS_INLINE_BIT_EXT                    :: 16;
    ENABLE_LEGACY_DITHERING_BIT_EXT            :: 8;
    CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR :: 1;
    SUSPENDING_BIT_KHR                         :: 2;
    RESUMING_BIT_KHR                           :: 4;
    FLAG_BITS_MAX_ENUM                         :: 2147483647;
}

VkRenderingFlags :: VkFlags;
VkFormatFeatureFlags2 :: VkFlags64;

// Flag bits for VkFormatFeatureFlagBits2
VkFormatFeatureFlagBits2 :: VkFlags64;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT: VkFormatFeatureFlagBits2 : 1;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR: VkFormatFeatureFlagBits2 : 1;
VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT: VkFormatFeatureFlagBits2 : 2;
VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR: VkFormatFeatureFlagBits2 : 2;
VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT: VkFormatFeatureFlagBits2 : 4;
VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR: VkFormatFeatureFlagBits2 : 4;
VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits2 : 8;
VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR: VkFormatFeatureFlagBits2 : 8;
VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits2 : 16;
VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR: VkFormatFeatureFlagBits2 : 16;
VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: VkFormatFeatureFlagBits2 : 32;
VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR: VkFormatFeatureFlagBits2 : 32;
VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT: VkFormatFeatureFlagBits2 : 64;
VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR: VkFormatFeatureFlagBits2 : 64;
VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT: VkFormatFeatureFlagBits2 : 128;
VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR: VkFormatFeatureFlagBits2 : 128;
VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT: VkFormatFeatureFlagBits2 : 256;
VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR: VkFormatFeatureFlagBits2 : 256;
VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT: VkFormatFeatureFlagBits2 : 512;
VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR: VkFormatFeatureFlagBits2 : 512;
VK_FORMAT_FEATURE_2_BLIT_SRC_BIT: VkFormatFeatureFlagBits2 : 1024;
VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR: VkFormatFeatureFlagBits2 : 1024;
VK_FORMAT_FEATURE_2_BLIT_DST_BIT: VkFormatFeatureFlagBits2 : 2048;
VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR: VkFormatFeatureFlagBits2 : 2048;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT: VkFormatFeatureFlagBits2 : 4096;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR: VkFormatFeatureFlagBits2 : 4096;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT: VkFormatFeatureFlagBits2 : 8192;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT: VkFormatFeatureFlagBits2 : 8192;
VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT: VkFormatFeatureFlagBits2 : 16384;
VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR: VkFormatFeatureFlagBits2 : 16384;
VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT: VkFormatFeatureFlagBits2 : 32768;
VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR: VkFormatFeatureFlagBits2 : 32768;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT: VkFormatFeatureFlagBits2 : 65536;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR: VkFormatFeatureFlagBits2 : 65536;
VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits2 : 131072;
VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits2 : 131072;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: VkFormatFeatureFlagBits2 : 262144;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR: VkFormatFeatureFlagBits2 : 262144;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: VkFormatFeatureFlagBits2 : 524288;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR: VkFormatFeatureFlagBits2 : 524288;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: VkFormatFeatureFlagBits2 : 1048576;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR: VkFormatFeatureFlagBits2 : 1048576;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: VkFormatFeatureFlagBits2 : 2097152;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR: VkFormatFeatureFlagBits2 : 2097152;
VK_FORMAT_FEATURE_2_DISJOINT_BIT: VkFormatFeatureFlagBits2 : 4194304;
VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR: VkFormatFeatureFlagBits2 : 4194304;
VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits2 : 8388608;
VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits2 : 8388608;
VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT: VkFormatFeatureFlagBits2 : 2147483648;
VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR: VkFormatFeatureFlagBits2 : 2147483648;
VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT: VkFormatFeatureFlagBits2 : 4294967296;
VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR: VkFormatFeatureFlagBits2 : 4294967296;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT: VkFormatFeatureFlagBits2 : 8589934592;
VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR: VkFormatFeatureFlagBits2 : 8589934592;
VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR: VkFormatFeatureFlagBits2 : 33554432;
VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR: VkFormatFeatureFlagBits2 : 67108864;
VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR: VkFormatFeatureFlagBits2 : 536870912;
VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT: VkFormatFeatureFlagBits2 : 16777216;
VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkFormatFeatureFlagBits2 : 1073741824;
VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT: VkFormatFeatureFlagBits2 : 70368744177664;

VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV: VkFormatFeatureFlagBits2 : 274877906944;
VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM: VkFormatFeatureFlagBits2 : 17179869184;
VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM: VkFormatFeatureFlagBits2 : 34359738368;
VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM: VkFormatFeatureFlagBits2 : 68719476736;
VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM: VkFormatFeatureFlagBits2 : 137438953472;
VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV: VkFormatFeatureFlagBits2 : 1099511627776;
VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV: VkFormatFeatureFlagBits2 : 2199023255552;
VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV: VkFormatFeatureFlagBits2 : 4398046511104;

VkPhysicalDeviceVulkan13Features :: struct {
    sType:                                              VkStructureType;
    pNext:                                              *void;
    robustImageAccess:                                  VkBool32;
    inlineUniformBlock:                                 VkBool32;
    descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32;
    pipelineCreationCacheControl:                       VkBool32;
    privateData:                                        VkBool32;
    shaderDemoteToHelperInvocation:                     VkBool32;
    shaderTerminateInvocation:                          VkBool32;
    subgroupSizeControl:                                VkBool32;
    computeFullSubgroups:                               VkBool32;
    synchronization2:                                   VkBool32;
    textureCompressionASTC_HDR:                         VkBool32;
    shaderZeroInitializeWorkgroupMemory:                VkBool32;
    dynamicRendering:                                   VkBool32;
    shaderIntegerDotProduct:                            VkBool32;
    maintenance4:                                       VkBool32;
}

VkPhysicalDeviceVulkan13Properties :: struct {
    sType:                                                                         VkStructureType;
    pNext:                                                                         *void;
    minSubgroupSize:                                                               u32;
    maxSubgroupSize:                                                               u32;
    maxComputeWorkgroupSubgroups:                                                  u32;
    requiredSubgroupSizeStages:                                                    VkShaderStageFlags;
    maxInlineUniformBlockSize:                                                     u32;
    maxPerStageDescriptorInlineUniformBlocks:                                      u32;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks:                       u32;
    maxDescriptorSetInlineUniformBlocks:                                           u32;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks:                            u32;
    maxInlineUniformTotalSize:                                                     u32;
    integerDotProduct8BitUnsignedAccelerated:                                      VkBool32;
    integerDotProduct8BitSignedAccelerated:                                        VkBool32;
    integerDotProduct8BitMixedSignednessAccelerated:                               VkBool32;
    integerDotProduct4x8BitPackedUnsignedAccelerated:                              VkBool32;
    integerDotProduct4x8BitPackedSignedAccelerated:                                VkBool32;
    integerDotProduct4x8BitPackedMixedSignednessAccelerated:                       VkBool32;
    integerDotProduct16BitUnsignedAccelerated:                                     VkBool32;
    integerDotProduct16BitSignedAccelerated:                                       VkBool32;
    integerDotProduct16BitMixedSignednessAccelerated:                              VkBool32;
    integerDotProduct32BitUnsignedAccelerated:                                     VkBool32;
    integerDotProduct32BitSignedAccelerated:                                       VkBool32;
    integerDotProduct32BitMixedSignednessAccelerated:                              VkBool32;
    integerDotProduct64BitUnsignedAccelerated:                                     VkBool32;
    integerDotProduct64BitSignedAccelerated:                                       VkBool32;
    integerDotProduct64BitMixedSignednessAccelerated:                              VkBool32;
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated:                VkBool32;
    integerDotProductAccumulatingSaturating8BitSignedAccelerated:                  VkBool32;
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated:         VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated:        VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated:          VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated:               VkBool32;
    integerDotProductAccumulatingSaturating16BitSignedAccelerated:                 VkBool32;
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated:        VkBool32;
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated:               VkBool32;
    integerDotProductAccumulatingSaturating32BitSignedAccelerated:                 VkBool32;
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated:        VkBool32;
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated:               VkBool32;
    integerDotProductAccumulatingSaturating64BitSignedAccelerated:                 VkBool32;
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated:        VkBool32;
    storageTexelBufferOffsetAlignmentBytes:                                        VkDeviceSize;
    storageTexelBufferOffsetSingleTexelAlignment:                                  VkBool32;
    uniformTexelBufferOffsetAlignmentBytes:                                        VkDeviceSize;
    uniformTexelBufferOffsetSingleTexelAlignment:                                  VkBool32;
    maxBufferSize:                                                                 VkDeviceSize;
}

VkPipelineCreationFeedback :: struct {
    flags:    VkPipelineCreationFeedbackFlags;
    duration: u64;
}

VkPipelineCreationFeedbackCreateInfo :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    pPipelineCreationFeedback:          *VkPipelineCreationFeedback;
    pipelineStageCreationFeedbackCount: u32;
    pPipelineStageCreationFeedbacks:    *VkPipelineCreationFeedback;
}

VkPhysicalDeviceShaderTerminateInvocationFeatures :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    shaderTerminateInvocation: VkBool32;
}

VkPhysicalDeviceToolProperties :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    name:        [256] u8;
    version:     [256] u8;
    purposes:    VkToolPurposeFlags;
    description: [256] u8;
    layer:       [256] u8;
}

VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    shaderDemoteToHelperInvocation: VkBool32;
}

VkPhysicalDevicePrivateDataFeatures :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    privateData: VkBool32;
}

VkDevicePrivateDataCreateInfo :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    privateDataSlotRequestCount: u32;
}

VkPrivateDataSlotCreateInfo :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkPrivateDataSlotCreateFlags;
}

VkPhysicalDevicePipelineCreationCacheControlFeatures :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    pipelineCreationCacheControl: VkBool32;
}

VkMemoryBarrier2 :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    srcStageMask:  VkPipelineStageFlags2;
    srcAccessMask: VkAccessFlags2;
    dstStageMask:  VkPipelineStageFlags2;
    dstAccessMask: VkAccessFlags2;
}

VkBufferMemoryBarrier2 :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    srcStageMask:        VkPipelineStageFlags2;
    srcAccessMask:       VkAccessFlags2;
    dstStageMask:        VkPipelineStageFlags2;
    dstAccessMask:       VkAccessFlags2;
    srcQueueFamilyIndex: u32;
    dstQueueFamilyIndex: u32;
    buffer:              VkBuffer;
    offset:              VkDeviceSize;
    size:                VkDeviceSize;
}

VkImageMemoryBarrier2 :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    srcStageMask:        VkPipelineStageFlags2;
    srcAccessMask:       VkAccessFlags2;
    dstStageMask:        VkPipelineStageFlags2;
    dstAccessMask:       VkAccessFlags2;
    oldLayout:           VkImageLayout;
    newLayout:           VkImageLayout;
    srcQueueFamilyIndex: u32;
    dstQueueFamilyIndex: u32;
    image:               VkImage;
    subresourceRange:    VkImageSubresourceRange;
}

VkDependencyInfo :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    dependencyFlags:          VkDependencyFlags;
    memoryBarrierCount:       u32;
    pMemoryBarriers:          *VkMemoryBarrier2;
    bufferMemoryBarrierCount: u32;
    pBufferMemoryBarriers:    *VkBufferMemoryBarrier2;
    imageMemoryBarrierCount:  u32;
    pImageMemoryBarriers:     *VkImageMemoryBarrier2;
}

VkSemaphoreSubmitInfo :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    semaphore:   VkSemaphore;
    value:       u64;
    stageMask:   VkPipelineStageFlags2;
    deviceIndex: u32;
}

VkCommandBufferSubmitInfo :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    commandBuffer: VkCommandBuffer;
    deviceMask:    u32;
}

VkSubmitInfo2 :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    flags:                    VkSubmitFlags;
    waitSemaphoreInfoCount:   u32;
    pWaitSemaphoreInfos:      *VkSemaphoreSubmitInfo;
    commandBufferInfoCount:   u32;
    pCommandBufferInfos:      *VkCommandBufferSubmitInfo;
    signalSemaphoreInfoCount: u32;
    pSignalSemaphoreInfos:    *VkSemaphoreSubmitInfo;
}

VkPhysicalDeviceSynchronization2Features :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    synchronization2: VkBool32;
}

VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures :: struct {
    sType:                               VkStructureType;
    pNext:                               *void;
    shaderZeroInitializeWorkgroupMemory: VkBool32;
}

VkPhysicalDeviceImageRobustnessFeatures :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    robustImageAccess: VkBool32;
}

VkBufferCopy2 :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    srcOffset: VkDeviceSize;
    dstOffset: VkDeviceSize;
    size:      VkDeviceSize;
}

VkCopyBufferInfo2 :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    srcBuffer:   VkBuffer;
    dstBuffer:   VkBuffer;
    regionCount: u32;
    pRegions:    *VkBufferCopy2;
}

VkImageCopy2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    srcSubresource: VkImageSubresourceLayers;
    srcOffset:      VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset:      VkOffset3D;
    extent:         VkExtent3D;
}

VkCopyImageInfo2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    srcImage:       VkImage;
    srcImageLayout: VkImageLayout;
    dstImage:       VkImage;
    dstImageLayout: VkImageLayout;
    regionCount:    u32;
    pRegions:       *VkImageCopy2;
}

VkBufferImageCopy2 :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    bufferOffset:      VkDeviceSize;
    bufferRowLength:   u32;
    bufferImageHeight: u32;
    imageSubresource:  VkImageSubresourceLayers;
    imageOffset:       VkOffset3D;
    imageExtent:       VkExtent3D;
}

VkCopyBufferToImageInfo2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    srcBuffer:      VkBuffer;
    dstImage:       VkImage;
    dstImageLayout: VkImageLayout;
    regionCount:    u32;
    pRegions:       *VkBufferImageCopy2;
}

VkCopyImageToBufferInfo2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    srcImage:       VkImage;
    srcImageLayout: VkImageLayout;
    dstBuffer:      VkBuffer;
    regionCount:    u32;
    pRegions:       *VkBufferImageCopy2;
}

VkImageBlit2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    srcSubresource: VkImageSubresourceLayers;
    srcOffsets:     [2] VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffsets:     [2] VkOffset3D;
}

VkBlitImageInfo2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    srcImage:       VkImage;
    srcImageLayout: VkImageLayout;
    dstImage:       VkImage;
    dstImageLayout: VkImageLayout;
    regionCount:    u32;
    pRegions:       *VkImageBlit2;
    filter:         VkFilter;
}

VkImageResolve2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    srcSubresource: VkImageSubresourceLayers;
    srcOffset:      VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset:      VkOffset3D;
    extent:         VkExtent3D;
}

VkResolveImageInfo2 :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    srcImage:       VkImage;
    srcImageLayout: VkImageLayout;
    dstImage:       VkImage;
    dstImageLayout: VkImageLayout;
    regionCount:    u32;
    pRegions:       *VkImageResolve2;
}

VkPhysicalDeviceSubgroupSizeControlFeatures :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    subgroupSizeControl:  VkBool32;
    computeFullSubgroups: VkBool32;
}

VkPhysicalDeviceSubgroupSizeControlProperties :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    minSubgroupSize:              u32;
    maxSubgroupSize:              u32;
    maxComputeWorkgroupSubgroups: u32;
    requiredSubgroupSizeStages:   VkShaderStageFlags;
}

VkPipelineShaderStageRequiredSubgroupSizeCreateInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    requiredSubgroupSize: u32;
}

VkPhysicalDeviceInlineUniformBlockFeatures :: struct {
    sType:                                              VkStructureType;
    pNext:                                              *void;
    inlineUniformBlock:                                 VkBool32;
    descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32;
}

VkPhysicalDeviceInlineUniformBlockProperties :: struct {
    sType:                                                   VkStructureType;
    pNext:                                                   *void;
    maxInlineUniformBlockSize:                               u32;
    maxPerStageDescriptorInlineUniformBlocks:                u32;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32;
    maxDescriptorSetInlineUniformBlocks:                     u32;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks:      u32;
}

VkWriteDescriptorSetInlineUniformBlock :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    dataSize: u32;
    pData:    *void;
}

VkDescriptorPoolInlineUniformBlockCreateInfo :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    maxInlineUniformBlockBindings: u32;
}

VkPhysicalDeviceTextureCompressionASTCHDRFeatures :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    textureCompressionASTC_HDR: VkBool32;
}

VkRenderingAttachmentInfo :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    imageView:          VkImageView;
    imageLayout:        VkImageLayout;
    resolveMode:        VkResolveModeFlagBits;
    resolveImageView:   VkImageView;
    resolveImageLayout: VkImageLayout;
    loadOp:             VkAttachmentLoadOp;
    storeOp:            VkAttachmentStoreOp;
    clearValue:         VkClearValue;
}

VkRenderingInfo :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    flags:                VkRenderingFlags;
    renderArea:           VkRect2D;
    layerCount:           u32;
    viewMask:             u32;
    colorAttachmentCount: u32;
    pColorAttachments:    *VkRenderingAttachmentInfo;
    pDepthAttachment:     *VkRenderingAttachmentInfo;
    pStencilAttachment:   *VkRenderingAttachmentInfo;
}

VkPipelineRenderingCreateInfo :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    viewMask:                u32;
    colorAttachmentCount:    u32;
    pColorAttachmentFormats: *VkFormat;
    depthAttachmentFormat:   VkFormat;
    stencilAttachmentFormat: VkFormat;
}

VkPhysicalDeviceDynamicRenderingFeatures :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    dynamicRendering: VkBool32;
}

VkCommandBufferInheritanceRenderingInfo :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    flags:                   VkRenderingFlags;
    viewMask:                u32;
    colorAttachmentCount:    u32;
    pColorAttachmentFormats: *VkFormat;
    depthAttachmentFormat:   VkFormat;
    stencilAttachmentFormat: VkFormat;
    rasterizationSamples:    VkSampleCountFlagBits;
}

VkPhysicalDeviceShaderIntegerDotProductFeatures :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    shaderIntegerDotProduct: VkBool32;
}

VkPhysicalDeviceShaderIntegerDotProductProperties :: struct {
    sType:                                                                         VkStructureType;
    pNext:                                                                         *void;
    integerDotProduct8BitUnsignedAccelerated:                                      VkBool32;
    integerDotProduct8BitSignedAccelerated:                                        VkBool32;
    integerDotProduct8BitMixedSignednessAccelerated:                               VkBool32;
    integerDotProduct4x8BitPackedUnsignedAccelerated:                              VkBool32;
    integerDotProduct4x8BitPackedSignedAccelerated:                                VkBool32;
    integerDotProduct4x8BitPackedMixedSignednessAccelerated:                       VkBool32;
    integerDotProduct16BitUnsignedAccelerated:                                     VkBool32;
    integerDotProduct16BitSignedAccelerated:                                       VkBool32;
    integerDotProduct16BitMixedSignednessAccelerated:                              VkBool32;
    integerDotProduct32BitUnsignedAccelerated:                                     VkBool32;
    integerDotProduct32BitSignedAccelerated:                                       VkBool32;
    integerDotProduct32BitMixedSignednessAccelerated:                              VkBool32;
    integerDotProduct64BitUnsignedAccelerated:                                     VkBool32;
    integerDotProduct64BitSignedAccelerated:                                       VkBool32;
    integerDotProduct64BitMixedSignednessAccelerated:                              VkBool32;
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated:                VkBool32;
    integerDotProductAccumulatingSaturating8BitSignedAccelerated:                  VkBool32;
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated:         VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated:        VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated:          VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated:               VkBool32;
    integerDotProductAccumulatingSaturating16BitSignedAccelerated:                 VkBool32;
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated:        VkBool32;
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated:               VkBool32;
    integerDotProductAccumulatingSaturating32BitSignedAccelerated:                 VkBool32;
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated:        VkBool32;
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated:               VkBool32;
    integerDotProductAccumulatingSaturating64BitSignedAccelerated:                 VkBool32;
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated:        VkBool32;
}

VkPhysicalDeviceTexelBufferAlignmentProperties :: struct {
    sType:                                        VkStructureType;
    pNext:                                        *void;
    storageTexelBufferOffsetAlignmentBytes:       VkDeviceSize;
    storageTexelBufferOffsetSingleTexelAlignment: VkBool32;
    uniformTexelBufferOffsetAlignmentBytes:       VkDeviceSize;
    uniformTexelBufferOffsetSingleTexelAlignment: VkBool32;
}

VkFormatProperties3 :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    linearTilingFeatures:  VkFormatFeatureFlags2;
    optimalTilingFeatures: VkFormatFeatureFlags2;
    bufferFeatures:        VkFormatFeatureFlags2;
}

VkPhysicalDeviceMaintenance4Features :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    maintenance4: VkBool32;
}

VkPhysicalDeviceMaintenance4Properties :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    maxBufferSize: VkDeviceSize;
}

VkDeviceBufferMemoryRequirements :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    pCreateInfo: *VkBufferCreateInfo;
}

VkDeviceImageMemoryRequirements :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    pCreateInfo: *VkImageCreateInfo;
    planeAspect: VkImageAspectFlagBits;
}

PFN_vkGetPhysicalDeviceToolProperties :: #type (physicalDevice: VkPhysicalDevice, pToolCount: *u32, pToolProperties: *VkPhysicalDeviceToolProperties) -> VkResult #c_call;
PFN_vkCreatePrivateDataSlot :: #type (device: VkDevice, pCreateInfo: *VkPrivateDataSlotCreateInfo, pAllocator: *VkAllocationCallbacks, pPrivateDataSlot: *VkPrivateDataSlot) -> VkResult #c_call;
PFN_vkDestroyPrivateDataSlot :: #type (device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkSetPrivateData :: #type (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult #c_call;
PFN_vkGetPrivateData :: #type (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *u64) -> void #c_call;
PFN_vkCmdSetEvent2 :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdResetEvent2 :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) -> void #c_call;
PFN_vkCmdWaitEvents2 :: #type (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, pDependencyInfos: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdPipelineBarrier2 :: #type (commandBuffer: VkCommandBuffer, pDependencyInfo: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdWriteTimestamp2 :: #type (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) -> void #c_call;
PFN_vkQueueSubmit2 :: #type (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo2, fence: VkFence) -> VkResult #c_call;
PFN_vkCmdCopyBuffer2 :: #type (commandBuffer: VkCommandBuffer, pCopyBufferInfo: *VkCopyBufferInfo2) -> void #c_call;
PFN_vkCmdCopyImage2 :: #type (commandBuffer: VkCommandBuffer, pCopyImageInfo: *VkCopyImageInfo2) -> void #c_call;
PFN_vkCmdCopyBufferToImage2 :: #type (commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *VkCopyBufferToImageInfo2) -> void #c_call;
PFN_vkCmdCopyImageToBuffer2 :: #type (commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *VkCopyImageToBufferInfo2) -> void #c_call;
PFN_vkCmdBlitImage2 :: #type (commandBuffer: VkCommandBuffer, pBlitImageInfo: *VkBlitImageInfo2) -> void #c_call;
PFN_vkCmdResolveImage2 :: #type (commandBuffer: VkCommandBuffer, pResolveImageInfo: *VkResolveImageInfo2) -> void #c_call;
PFN_vkCmdBeginRendering :: #type (commandBuffer: VkCommandBuffer, pRenderingInfo: *VkRenderingInfo) -> void #c_call;
PFN_vkCmdEndRendering :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdSetCullMode :: #type (commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> void #c_call;
PFN_vkCmdSetFrontFace :: #type (commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) -> void #c_call;
PFN_vkCmdSetPrimitiveTopology :: #type (commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) -> void #c_call;
PFN_vkCmdSetViewportWithCount :: #type (commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *VkViewport) -> void #c_call;
PFN_vkCmdSetScissorWithCount :: #type (commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *VkRect2D) -> void #c_call;
PFN_vkCmdBindVertexBuffers2 :: #type (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize, pStrides: *VkDeviceSize) -> void #c_call;
PFN_vkCmdSetDepthTestEnable :: #type (commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthWriteEnable :: #type (commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthCompareOp :: #type (commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) -> void #c_call;
PFN_vkCmdSetDepthBoundsTestEnable :: #type (commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetStencilTestEnable :: #type (commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetStencilOp :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) -> void #c_call;
PFN_vkCmdSetRasterizerDiscardEnable :: #type (commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthBiasEnable :: #type (commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetPrimitiveRestartEnable :: #type (commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) -> void #c_call;
PFN_vkGetDeviceBufferMemoryRequirements :: #type (device: VkDevice, pInfo: *VkDeviceBufferMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetDeviceImageMemoryRequirements :: #type (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetDeviceImageSparseMemoryRequirements :: #type (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) -> void #c_call;

VkSurfaceKHR_T :: struct {}
VkSurfaceKHR :: *VkSurfaceKHR_T;

VkPresentModeKHR :: enum s32 {
    IMMEDIATE_KHR                 :: 0;
    MAILBOX_KHR                   :: 1;
    FIFO_KHR                      :: 2;
    FIFO_RELAXED_KHR              :: 3;
    SHARED_DEMAND_REFRESH_KHR     :: 1000111000;
    SHARED_CONTINUOUS_REFRESH_KHR :: 1000111001;
    MAX_ENUM_KHR                  :: 2147483647;
}

VkColorSpaceKHR :: enum s32 {
    COLOR_SPACE_SRGB_NONLINEAR_KHR          :: 0;
    COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT    :: 1000104001;
    COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT    :: 1000104002;
    COLOR_SPACE_DISPLAY_P3_LINEAR_EXT       :: 1000104003;
    COLOR_SPACE_DCI_P3_NONLINEAR_EXT        :: 1000104004;
    COLOR_SPACE_BT709_LINEAR_EXT            :: 1000104005;
    COLOR_SPACE_BT709_NONLINEAR_EXT         :: 1000104006;
    COLOR_SPACE_BT2020_LINEAR_EXT           :: 1000104007;
    COLOR_SPACE_HDR10_ST2084_EXT            :: 1000104008;
    COLOR_SPACE_DOLBYVISION_EXT             :: 1000104009;
    COLOR_SPACE_HDR10_HLG_EXT               :: 1000104010;
    COLOR_SPACE_ADOBERGB_LINEAR_EXT         :: 1000104011;
    COLOR_SPACE_ADOBERGB_NONLINEAR_EXT      :: 1000104012;
    COLOR_SPACE_PASS_THROUGH_EXT            :: 1000104013;
    COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT :: 1000104014;
    COLOR_SPACE_DISPLAY_NATIVE_AMD          :: 1000213000;
    COLORSPACE_SRGB_NONLINEAR_KHR           :: 0;
    COLOR_SPACE_DCI_P3_LINEAR_EXT           :: 1000104003;
    COLOR_SPACE_MAX_ENUM_KHR                :: 2147483647;
}

VkSurfaceTransformFlagBitsKHR :: enum s32 {
    IDENTITY_BIT_KHR                     :: 1;
    ROTATE_90_BIT_KHR                    :: 2;
    ROTATE_180_BIT_KHR                   :: 4;
    ROTATE_270_BIT_KHR                   :: 8;
    HORIZONTAL_MIRROR_BIT_KHR            :: 16;
    HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR  :: 32;
    HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR :: 64;
    HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR :: 128;
    INHERIT_BIT_KHR                      :: 256;
    FLAG_BITS_MAX_ENUM_KHR               :: 2147483647;
}

VkCompositeAlphaFlagBitsKHR :: enum s32 {
    OPAQUE_BIT_KHR          :: 1;
    PRE_MULTIPLIED_BIT_KHR  :: 2;
    POST_MULTIPLIED_BIT_KHR :: 4;
    INHERIT_BIT_KHR         :: 8;
    FLAG_BITS_MAX_ENUM_KHR  :: 2147483647;
}

VkCompositeAlphaFlagsKHR :: VkFlags;
VkSurfaceTransformFlagsKHR :: VkFlags;
VkSurfaceCapabilitiesKHR :: struct {
    minImageCount:           u32;
    maxImageCount:           u32;
    currentExtent:           VkExtent2D;
    minImageExtent:          VkExtent2D;
    maxImageExtent:          VkExtent2D;
    maxImageArrayLayers:     u32;
    supportedTransforms:     VkSurfaceTransformFlagsKHR;
    currentTransform:        VkSurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR;
    supportedUsageFlags:     VkImageUsageFlags;
}

VkSurfaceFormatKHR :: struct {
    format:     VkFormat;
    colorSpace: VkColorSpaceKHR;
}

PFN_vkDestroySurfaceKHR :: #type (instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetPhysicalDeviceSurfaceSupportKHR :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, surface: VkSurfaceKHR, pSupported: *VkBool32) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *VkSurfaceCapabilitiesKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfaceFormatsKHR :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceFormatCount: *u32, pSurfaceFormats: *VkSurfaceFormatKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfacePresentModesKHR :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pPresentModeCount: *u32, pPresentModes: *VkPresentModeKHR) -> VkResult #c_call;

VkSwapchainKHR_T :: struct {}
VkSwapchainKHR :: *VkSwapchainKHR_T;

VkSwapchainCreateFlagBitsKHR :: enum s32 {
    SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR :: 1;
    PROTECTED_BIT_KHR                   :: 2;
    MUTABLE_FORMAT_BIT_KHR              :: 4;
    DEFERRED_MEMORY_ALLOCATION_BIT_EXT  :: 8;
    FLAG_BITS_MAX_ENUM_KHR              :: 2147483647;
}

VkSwapchainCreateFlagsKHR :: VkFlags;

VkDeviceGroupPresentModeFlagBitsKHR :: enum s32 {
    LOCAL_BIT_KHR              :: 1;
    REMOTE_BIT_KHR             :: 2;
    SUM_BIT_KHR                :: 4;
    LOCAL_MULTI_DEVICE_BIT_KHR :: 8;
    FLAG_BITS_MAX_ENUM_KHR     :: 2147483647;
}

VkDeviceGroupPresentModeFlagsKHR :: VkFlags;
VkSwapchainCreateInfoKHR :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    flags:                 VkSwapchainCreateFlagsKHR;
    surface:               VkSurfaceKHR;
    minImageCount:         u32;
    imageFormat:           VkFormat;
    imageColorSpace:       VkColorSpaceKHR;
    imageExtent:           VkExtent2D;
    imageArrayLayers:      u32;
    imageUsage:            VkImageUsageFlags;
    imageSharingMode:      VkSharingMode;
    queueFamilyIndexCount: u32;
    pQueueFamilyIndices:   *u32;
    preTransform:          VkSurfaceTransformFlagBitsKHR;
    compositeAlpha:        VkCompositeAlphaFlagBitsKHR;
    presentMode:           VkPresentModeKHR;
    clipped:               VkBool32;
    oldSwapchain:          VkSwapchainKHR;
}

VkPresentInfoKHR :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    waitSemaphoreCount: u32;
    pWaitSemaphores:    *VkSemaphore;
    swapchainCount:     u32;
    pSwapchains:        *VkSwapchainKHR;
    pImageIndices:      *u32;
    pResults:           *VkResult;
}

VkImageSwapchainCreateInfoKHR :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    swapchain: VkSwapchainKHR;
}

VkBindImageMemorySwapchainInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    swapchain:  VkSwapchainKHR;
    imageIndex: u32;
}

VkAcquireNextImageInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    swapchain:  VkSwapchainKHR;
    timeout:    u64;
    semaphore:  VkSemaphore;
    fence:      VkFence;
    deviceMask: u32;
}

VkDeviceGroupPresentCapabilitiesKHR :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    presentMask: [32] u32;
    modes:       VkDeviceGroupPresentModeFlagsKHR;
}

VkDeviceGroupPresentInfoKHR :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    swapchainCount: u32;
    pDeviceMasks:   *u32;
    mode:           VkDeviceGroupPresentModeFlagBitsKHR;
}

VkDeviceGroupSwapchainCreateInfoKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    modes: VkDeviceGroupPresentModeFlagsKHR;
}

PFN_vkCreateSwapchainKHR :: #type (device: VkDevice, pCreateInfo: *VkSwapchainCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSwapchain: *VkSwapchainKHR) -> VkResult #c_call;
PFN_vkDestroySwapchainKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetSwapchainImagesKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainImageCount: *u32, pSwapchainImages: *VkImage) -> VkResult #c_call;
PFN_vkAcquireNextImageKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR, timeout: u64, semaphore: VkSemaphore, fence: VkFence, pImageIndex: *u32) -> VkResult #c_call;
PFN_vkQueuePresentKHR :: #type (queue: VkQueue, pPresentInfo: *VkPresentInfoKHR) -> VkResult #c_call;
PFN_vkGetDeviceGroupPresentCapabilitiesKHR :: #type (device: VkDevice, pDeviceGroupPresentCapabilities: *VkDeviceGroupPresentCapabilitiesKHR) -> VkResult #c_call;
PFN_vkGetDeviceGroupSurfacePresentModesKHR :: #type (device: VkDevice, surface: VkSurfaceKHR, pModes: *VkDeviceGroupPresentModeFlagsKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDevicePresentRectanglesKHR :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: *u32, pRects: *VkRect2D) -> VkResult #c_call;
PFN_vkAcquireNextImage2KHR :: #type (device: VkDevice, pAcquireInfo: *VkAcquireNextImageInfoKHR, pImageIndex: *u32) -> VkResult #c_call;

VkDisplayKHR_T :: struct {}
VkDisplayKHR :: *VkDisplayKHR_T;
VkDisplayModeKHR_T :: struct {}
VkDisplayModeKHR :: *VkDisplayModeKHR_T;

VkDisplayModeCreateFlagsKHR :: VkFlags;

VkDisplayPlaneAlphaFlagBitsKHR :: enum s32 {
    OPAQUE_BIT_KHR                  :: 1;
    GLOBAL_BIT_KHR                  :: 2;
    PER_PIXEL_BIT_KHR               :: 4;
    PER_PIXEL_PREMULTIPLIED_BIT_KHR :: 8;
    FLAG_BITS_MAX_ENUM_KHR          :: 2147483647;
}

VkDisplayPlaneAlphaFlagsKHR :: VkFlags;
VkDisplaySurfaceCreateFlagsKHR :: VkFlags;
VkDisplayModeParametersKHR :: struct {
    visibleRegion: VkExtent2D;
    refreshRate:   u32;
}

VkDisplayModeCreateInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    flags:      VkDisplayModeCreateFlagsKHR;
    parameters: VkDisplayModeParametersKHR;
}

VkDisplayModePropertiesKHR :: struct {
    displayMode: VkDisplayModeKHR;
    parameters:  VkDisplayModeParametersKHR;
}

VkDisplayPlaneCapabilitiesKHR :: struct {
    supportedAlpha: VkDisplayPlaneAlphaFlagsKHR;
    minSrcPosition: VkOffset2D;
    maxSrcPosition: VkOffset2D;
    minSrcExtent:   VkExtent2D;
    maxSrcExtent:   VkExtent2D;
    minDstPosition: VkOffset2D;
    maxDstPosition: VkOffset2D;
    minDstExtent:   VkExtent2D;
    maxDstExtent:   VkExtent2D;
}

VkDisplayPlanePropertiesKHR :: struct {
    currentDisplay:    VkDisplayKHR;
    currentStackIndex: u32;
}

VkDisplayPropertiesKHR :: struct {
    display:              VkDisplayKHR;
    displayName:          *u8;
    physicalDimensions:   VkExtent2D;
    physicalResolution:   VkExtent2D;
    supportedTransforms:  VkSurfaceTransformFlagsKHR;
    planeReorderPossible: VkBool32;
    persistentContent:    VkBool32;
}

VkDisplaySurfaceCreateInfoKHR :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkDisplaySurfaceCreateFlagsKHR;
    displayMode:     VkDisplayModeKHR;
    planeIndex:      u32;
    planeStackIndex: u32;
    transform:       VkSurfaceTransformFlagBitsKHR;
    globalAlpha:     float;
    alphaMode:       VkDisplayPlaneAlphaFlagBitsKHR;
    imageExtent:     VkExtent2D;
}

PFN_vkGetPhysicalDeviceDisplayPropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPropertiesKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPlanePropertiesKHR) -> VkResult #c_call;
PFN_vkGetDisplayPlaneSupportedDisplaysKHR :: #type (physicalDevice: VkPhysicalDevice, planeIndex: u32, pDisplayCount: *u32, pDisplays: *VkDisplayKHR) -> VkResult #c_call;
PFN_vkGetDisplayModePropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *u32, pProperties: *VkDisplayModePropertiesKHR) -> VkResult #c_call;
PFN_vkCreateDisplayModeKHR :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pCreateInfo: *VkDisplayModeCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pMode: *VkDisplayModeKHR) -> VkResult #c_call;
PFN_vkGetDisplayPlaneCapabilitiesKHR :: #type (physicalDevice: VkPhysicalDevice, mode: VkDisplayModeKHR, planeIndex: u32, pCapabilities: *VkDisplayPlaneCapabilitiesKHR) -> VkResult #c_call;
PFN_vkCreateDisplayPlaneSurfaceKHR :: #type (instance: VkInstance, pCreateInfo: *VkDisplaySurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;

VkDisplayPresentInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    srcRect:    VkRect2D;
    dstRect:    VkRect2D;
    persistent: VkBool32;
}

PFN_vkCreateSharedSwapchainsKHR :: #type (device: VkDevice, swapchainCount: u32, pCreateInfos: *VkSwapchainCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSwapchains: *VkSwapchainKHR) -> VkResult #c_call;

VkVideoSessionKHR_T :: struct {}
VkVideoSessionKHR :: *VkVideoSessionKHR_T;
VkVideoSessionParametersKHR_T :: struct {}
VkVideoSessionParametersKHR :: *VkVideoSessionParametersKHR_T;

VkQueryResultStatusKHR :: enum s32 {
    ERROR_KHR                               :: -1;
    NOT_READY_KHR                           :: 0;
    COMPLETE_KHR                            :: 1;
    INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR :: -1000299000;
    MAX_ENUM_KHR                            :: 2147483647;
}

VkVideoCodecOperationFlagBitsKHR :: enum s32 {
    NONE_KHR               :: 0;

    DECODE_H264_BIT_KHR    :: 1;
    DECODE_H265_BIT_KHR    :: 2;
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647;
}

VkVideoCodecOperationFlagsKHR :: VkFlags;

VkVideoChromaSubsamplingFlagBitsKHR :: enum s32 {
    INVALID_KHR            :: 0;
    MONOCHROME_BIT_KHR     :: 1;
    _420_BIT_KHR           :: 2;
    _422_BIT_KHR           :: 4;
    _444_BIT_KHR           :: 8;
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647;
}

VkVideoChromaSubsamplingFlagsKHR :: VkFlags;

VkVideoComponentBitDepthFlagBitsKHR :: enum s32 {
    INVALID_KHR            :: 0;
    _8_BIT_KHR             :: 1;
    _10_BIT_KHR            :: 4;
    _12_BIT_KHR            :: 16;
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647;
}

VkVideoComponentBitDepthFlagsKHR :: VkFlags;

VkVideoCapabilityFlagBitsKHR :: enum s32 {
    PROTECTED_CONTENT_BIT_KHR         :: 1;
    SEPARATE_REFERENCE_IMAGES_BIT_KHR :: 2;
    FLAG_BITS_MAX_ENUM_KHR            :: 2147483647;
}

VkVideoCapabilityFlagsKHR :: VkFlags;

VkVideoSessionCreateFlagBitsKHR :: enum s32 {
    PROTECTED_CONTENT_BIT_KHR :: 1;

    FLAG_BITS_MAX_ENUM_KHR    :: 2147483647;
}

VkVideoSessionCreateFlagsKHR :: VkFlags;
VkVideoSessionParametersCreateFlagsKHR :: VkFlags;
VkVideoBeginCodingFlagsKHR :: VkFlags;
VkVideoEndCodingFlagsKHR :: VkFlags;

VkVideoCodingControlFlagBitsKHR :: enum s32 {
    RESET_BIT_KHR          :: 1;

    FLAG_BITS_MAX_ENUM_KHR :: 2147483647;
}

VkVideoCodingControlFlagsKHR :: VkFlags;
VkQueueFamilyQueryResultStatusPropertiesKHR :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    queryResultStatusSupport: VkBool32;
}

VkQueueFamilyVideoPropertiesKHR :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    videoCodecOperations: VkVideoCodecOperationFlagsKHR;
}

VkVideoProfileInfoKHR :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    videoCodecOperation: VkVideoCodecOperationFlagBitsKHR;
    chromaSubsampling:   VkVideoChromaSubsamplingFlagsKHR;
    lumaBitDepth:        VkVideoComponentBitDepthFlagsKHR;
    chromaBitDepth:      VkVideoComponentBitDepthFlagsKHR;
}

VkVideoProfileListInfoKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    profileCount: u32;
    pProfiles:    *VkVideoProfileInfoKHR;
}

VkVideoCapabilitiesKHR :: struct {
    sType:                             VkStructureType;
    pNext:                             *void;
    flags:                             VkVideoCapabilityFlagsKHR;
    minBitstreamBufferOffsetAlignment: VkDeviceSize;
    minBitstreamBufferSizeAlignment:   VkDeviceSize;
    pictureAccessGranularity:          VkExtent2D;
    minCodedExtent:                    VkExtent2D;
    maxCodedExtent:                    VkExtent2D;
    maxDpbSlots:                       u32;
    maxActiveReferencePictures:        u32;
    stdHeaderVersion:                  VkExtensionProperties;
}

VkPhysicalDeviceVideoFormatInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    imageUsage: VkImageUsageFlags;
}

VkVideoFormatPropertiesKHR :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    format:           VkFormat;
    componentMapping: VkComponentMapping;
    imageCreateFlags: VkImageCreateFlags;
    imageType:        VkImageType;
    imageTiling:      VkImageTiling;
    imageUsageFlags:  VkImageUsageFlags;
}

VkVideoPictureResourceInfoKHR :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    codedOffset:      VkOffset2D;
    codedExtent:      VkExtent2D;
    baseArrayLayer:   u32;
    imageViewBinding: VkImageView;
}

VkVideoReferenceSlotInfoKHR :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    slotIndex:        s32;
    pPictureResource: *VkVideoPictureResourceInfoKHR;
}

VkVideoSessionMemoryRequirementsKHR :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    memoryBindIndex:    u32;
    memoryRequirements: VkMemoryRequirements;
}

VkBindVideoSessionMemoryInfoKHR :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    memoryBindIndex: u32;
    memory:          VkDeviceMemory;
    memoryOffset:    VkDeviceSize;
    memorySize:      VkDeviceSize;
}

VkVideoSessionCreateInfoKHR :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    queueFamilyIndex:           u32;
    flags:                      VkVideoSessionCreateFlagsKHR;
    pVideoProfile:              *VkVideoProfileInfoKHR;
    pictureFormat:              VkFormat;
    maxCodedExtent:             VkExtent2D;
    referencePictureFormat:     VkFormat;
    maxDpbSlots:                u32;
    maxActiveReferencePictures: u32;
    pStdHeaderVersion:          *VkExtensionProperties;
}

VkVideoSessionParametersCreateInfoKHR :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    flags:                          VkVideoSessionParametersCreateFlagsKHR;
    videoSessionParametersTemplate: VkVideoSessionParametersKHR;
    videoSession:                   VkVideoSessionKHR;
}

VkVideoSessionParametersUpdateInfoKHR :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    updateSequenceCount: u32;
}

VkVideoBeginCodingInfoKHR :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    flags:                  VkVideoBeginCodingFlagsKHR;
    videoSession:           VkVideoSessionKHR;
    videoSessionParameters: VkVideoSessionParametersKHR;
    referenceSlotCount:     u32;
    pReferenceSlots:        *VkVideoReferenceSlotInfoKHR;
}

VkVideoEndCodingInfoKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkVideoEndCodingFlagsKHR;
}

VkVideoCodingControlInfoKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkVideoCodingControlFlagsKHR;
}

PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR :: #type (physicalDevice: VkPhysicalDevice, pVideoProfile: *VkVideoProfileInfoKHR, pCapabilities: *VkVideoCapabilitiesKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pVideoFormatInfo: *VkPhysicalDeviceVideoFormatInfoKHR, pVideoFormatPropertyCount: *u32, pVideoFormatProperties: *VkVideoFormatPropertiesKHR) -> VkResult #c_call;
PFN_vkCreateVideoSessionKHR :: #type (device: VkDevice, pCreateInfo: *VkVideoSessionCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pVideoSession: *VkVideoSessionKHR) -> VkResult #c_call;
PFN_vkDestroyVideoSessionKHR :: #type (device: VkDevice, videoSession: VkVideoSessionKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetVideoSessionMemoryRequirementsKHR :: #type (device: VkDevice, videoSession: VkVideoSessionKHR, pMemoryRequirementsCount: *u32, pMemoryRequirements: *VkVideoSessionMemoryRequirementsKHR) -> VkResult #c_call;
PFN_vkBindVideoSessionMemoryKHR :: #type (device: VkDevice, videoSession: VkVideoSessionKHR, bindSessionMemoryInfoCount: u32, pBindSessionMemoryInfos: *VkBindVideoSessionMemoryInfoKHR) -> VkResult #c_call;
PFN_vkCreateVideoSessionParametersKHR :: #type (device: VkDevice, pCreateInfo: *VkVideoSessionParametersCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pVideoSessionParameters: *VkVideoSessionParametersKHR) -> VkResult #c_call;
PFN_vkUpdateVideoSessionParametersKHR :: #type (device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pUpdateInfo: *VkVideoSessionParametersUpdateInfoKHR) -> VkResult #c_call;
PFN_vkDestroyVideoSessionParametersKHR :: #type (device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCmdBeginVideoCodingKHR :: #type (commandBuffer: VkCommandBuffer, pBeginInfo: *VkVideoBeginCodingInfoKHR) -> void #c_call;
PFN_vkCmdEndVideoCodingKHR :: #type (commandBuffer: VkCommandBuffer, pEndCodingInfo: *VkVideoEndCodingInfoKHR) -> void #c_call;
PFN_vkCmdControlVideoCodingKHR :: #type (commandBuffer: VkCommandBuffer, pCodingControlInfo: *VkVideoCodingControlInfoKHR) -> void #c_call;

VkVideoDecodeCapabilityFlagBitsKHR :: enum s32 {
    DPB_AND_OUTPUT_COINCIDE_BIT_KHR :: 1;
    DPB_AND_OUTPUT_DISTINCT_BIT_KHR :: 2;
    FLAG_BITS_MAX_ENUM_KHR          :: 2147483647;
}

VkVideoDecodeCapabilityFlagsKHR :: VkFlags;

VkVideoDecodeUsageFlagBitsKHR :: enum s32 {
    DEFAULT_KHR            :: 0;
    TRANSCODING_BIT_KHR    :: 1;
    OFFLINE_BIT_KHR        :: 2;
    STREAMING_BIT_KHR      :: 4;
    FLAG_BITS_MAX_ENUM_KHR :: 2147483647;
}

VkVideoDecodeUsageFlagsKHR :: VkFlags;
VkVideoDecodeFlagsKHR :: VkFlags;
VkVideoDecodeCapabilitiesKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkVideoDecodeCapabilityFlagsKHR;
}

VkVideoDecodeUsageInfoKHR :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    videoUsageHints: VkVideoDecodeUsageFlagsKHR;
}

VkVideoDecodeInfoKHR :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    flags:               VkVideoDecodeFlagsKHR;
    srcBuffer:           VkBuffer;
    srcBufferOffset:     VkDeviceSize;
    srcBufferRange:      VkDeviceSize;
    dstPictureResource:  VkVideoPictureResourceInfoKHR;
    pSetupReferenceSlot: *VkVideoReferenceSlotInfoKHR;
    referenceSlotCount:  u32;
    pReferenceSlots:     *VkVideoReferenceSlotInfoKHR;
}

PFN_vkCmdDecodeVideoKHR :: #type (commandBuffer: VkCommandBuffer, pDecodeInfo: *VkVideoDecodeInfoKHR) -> void #c_call;

StdVideoH264ChromaFormatIdc :: enum s32 {
    MONOCHROME :: 0;
    _420       :: 1;
    _422       :: 2;
    _444       :: 3;
    INVALID    :: 2147483647;
    MAX_ENUM   :: 2147483647;
}

StdVideoH264ProfileIdc :: enum s32 {
    BASELINE            :: 66;
    MAIN                :: 77;
    HIGH                :: 100;
    HIGH_444_PREDICTIVE :: 244;
    INVALID             :: 2147483647;
    MAX_ENUM            :: 2147483647;
}

StdVideoH264LevelIdc :: enum s32 {
    _1_0     :: 0;
    _1_1     :: 1;
    _1_2     :: 2;
    _1_3     :: 3;
    _2_0     :: 4;
    _2_1     :: 5;
    _2_2     :: 6;
    _3_0     :: 7;
    _3_1     :: 8;
    _3_2     :: 9;
    _4_0     :: 10;
    _4_1     :: 11;
    _4_2     :: 12;
    _5_0     :: 13;
    _5_1     :: 14;
    _5_2     :: 15;
    _6_0     :: 16;
    _6_1     :: 17;
    _6_2     :: 18;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH264PocType :: enum s32 {
    _0       :: 0;
    _1       :: 1;
    _2       :: 2;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH264AspectRatioIdc :: enum s32 {
    UNSPECIFIED  :: 0;
    SQUARE       :: 1;
    _12_11       :: 2;
    _10_11       :: 3;
    _16_11       :: 4;
    _40_33       :: 5;
    _24_11       :: 6;
    _20_11       :: 7;
    _32_11       :: 8;
    _80_33       :: 9;
    _18_11       :: 10;
    _15_11       :: 11;
    _64_33       :: 12;
    _160_99      :: 13;
    _4_3         :: 14;
    _3_2         :: 15;
    _2_1         :: 16;
    EXTENDED_SAR :: 255;
    INVALID      :: 2147483647;
    MAX_ENUM     :: 2147483647;
}

StdVideoH264WeightedBipredIdc :: enum s32 {
    DEFAULT  :: 0;
    EXPLICIT :: 1;
    IMPLICIT :: 2;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH264ModificationOfPicNumsIdc :: enum s32 {
    SHORT_TERM_SUBTRACT :: 0;
    SHORT_TERM_ADD      :: 1;
    LONG_TERM           :: 2;
    END                 :: 3;
    INVALID             :: 2147483647;
    MAX_ENUM            :: 2147483647;
}

StdVideoH264MemMgmtControlOp :: enum s32 {
    END                       :: 0;
    UNMARK_SHORT_TERM         :: 1;
    UNMARK_LONG_TERM          :: 2;
    MARK_LONG_TERM            :: 3;
    SET_MAX_LONG_TERM_INDEX   :: 4;
    UNMARK_ALL                :: 5;
    MARK_CURRENT_AS_LONG_TERM :: 6;
    INVALID                   :: 2147483647;
    MAX_ENUM                  :: 2147483647;
}

StdVideoH264CabacInitIdc :: enum s32 {
    _0       :: 0;
    _1       :: 1;
    _2       :: 2;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH264DisableDeblockingFilterIdc :: enum s32 {
    DISABLED :: 0;
    ENABLED  :: 1;
    PARTIAL  :: 2;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH264SliceType :: enum s32 {
    P        :: 0;
    B        :: 1;
    I        :: 2;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH264PictureType :: enum s32 {
    P        :: 0;
    B        :: 1;
    I        :: 2;
    IDR      :: 5;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH264NonVclNaluType :: enum s32 {
    SPS             :: 0;
    PPS             :: 1;
    AUD             :: 2;
    PREFIX          :: 3;
    END_OF_SEQUENCE :: 4;
    END_OF_STREAM   :: 5;
    PRECODED        :: 6;
    INVALID         :: 2147483647;
    MAX_ENUM        :: 2147483647;
}

StdVideoH264SpsVuiFlags :: struct {
    __bitfield: u32;
    /* 
        aspect_ratio_info_present_flag: u32; /* 1 bits */
        overscan_info_present_flag: u32; /* 1 bits */
        overscan_appropriate_flag: u32; /* 1 bits */
        video_signal_type_present_flag: u32; /* 1 bits */
        video_full_range_flag: u32; /* 1 bits */
        color_description_present_flag: u32; /* 1 bits */
        chroma_loc_info_present_flag: u32; /* 1 bits */
        timing_info_present_flag: u32; /* 1 bits */
        fixed_frame_rate_flag: u32; /* 1 bits */
        bitstream_restriction_flag: u32; /* 1 bits */
        nal_hrd_parameters_present_flag: u32; /* 1 bits */
        vcl_hrd_parameters_present_flag: u32; /* 1 bits */;
    */
}

StdVideoH264HrdParameters :: struct {
    cpb_cnt_minus1:                          u8;
    bit_rate_scale:                          u8;
    cpb_size_scale:                          u8;
    reserved1:                               u8;
    bit_rate_value_minus1:                   [32] u32;
    cpb_size_value_minus1:                   [32] u32;
    cbr_flag:                                [32] u8;
    initial_cpb_removal_delay_length_minus1: u32;
    cpb_removal_delay_length_minus1:         u32;
    dpb_output_delay_length_minus1:          u32;
    time_offset_length:                      u32;
}

StdVideoH264SequenceParameterSetVui :: struct {
    flags:                               StdVideoH264SpsVuiFlags;
    aspect_ratio_idc:                    StdVideoH264AspectRatioIdc;
    sar_width:                           u16;
    sar_height:                          u16;
    video_format:                        u8;
    colour_primaries:                    u8;
    transfer_characteristics:            u8;
    matrix_coefficients:                 u8;
    num_units_in_tick:                   u32;
    time_scale:                          u32;
    max_num_reorder_frames:              u8;
    max_dec_frame_buffering:             u8;
    chroma_sample_loc_type_top_field:    u8;
    chroma_sample_loc_type_bottom_field: u8;
    reserved1:                           u32;
    pHrdParameters:                      *StdVideoH264HrdParameters;
}

StdVideoH264SpsFlags :: struct {
    __bitfield: u32;
    /* 
        constraint_set0_flag: u32; /* 1 bits */
        constraint_set1_flag: u32; /* 1 bits */
        constraint_set2_flag: u32; /* 1 bits */
        constraint_set3_flag: u32; /* 1 bits */
        constraint_set4_flag: u32; /* 1 bits */
        constraint_set5_flag: u32; /* 1 bits */
        direct_8x8_inference_flag: u32; /* 1 bits */
        mb_adaptive_frame_field_flag: u32; /* 1 bits */
        frame_mbs_only_flag: u32; /* 1 bits */
        delta_pic_order_always_zero_flag: u32; /* 1 bits */
        separate_colour_plane_flag: u32; /* 1 bits */
        gaps_in_frame_num_value_allowed_flag: u32; /* 1 bits */
        qpprime_y_zero_transform_bypass_flag: u32; /* 1 bits */
        frame_cropping_flag: u32; /* 1 bits */
        seq_scaling_matrix_present_flag: u32; /* 1 bits */
        vui_parameters_present_flag: u32; /* 1 bits */;
    */
}

StdVideoH264ScalingLists :: struct {
    scaling_list_present_mask:       u16;
    use_default_scaling_matrix_mask: u16;
    ScalingList4x4:                  [6] [16] u8;
    ScalingList8x8:                  [6] [64] u8;
}

StdVideoH264SequenceParameterSet :: struct {
    flags:                                 StdVideoH264SpsFlags;
    profile_idc:                           StdVideoH264ProfileIdc;
    level_idc:                             StdVideoH264LevelIdc;
    chroma_format_idc:                     StdVideoH264ChromaFormatIdc;
    seq_parameter_set_id:                  u8;
    bit_depth_luma_minus8:                 u8;
    bit_depth_chroma_minus8:               u8;
    log2_max_frame_num_minus4:             u8;
    pic_order_cnt_type:                    StdVideoH264PocType;
    offset_for_non_ref_pic:                s32;
    offset_for_top_to_bottom_field:        s32;
    log2_max_pic_order_cnt_lsb_minus4:     u8;
    num_ref_frames_in_pic_order_cnt_cycle: u8;
    max_num_ref_frames:                    u8;
    reserved1:                             u8;
    pic_width_in_mbs_minus1:               u32;
    pic_height_in_map_units_minus1:        u32;
    frame_crop_left_offset:                u32;
    frame_crop_right_offset:               u32;
    frame_crop_top_offset:                 u32;
    frame_crop_bottom_offset:              u32;
    reserved2:                             u32;
    pOffsetForRefFrame:                    *s32;
    pScalingLists:                         *StdVideoH264ScalingLists;
    pSequenceParameterSetVui:              *StdVideoH264SequenceParameterSetVui;
}

StdVideoH264PpsFlags :: struct {
    __bitfield: u32;
    /* 
        transform_8x8_mode_flag: u32; /* 1 bits */
        redundant_pic_cnt_present_flag: u32; /* 1 bits */
        constrained_intra_pred_flag: u32; /* 1 bits */
        deblocking_filter_control_present_flag: u32; /* 1 bits */
        weighted_pred_flag: u32; /* 1 bits */
        bottom_field_pic_order_in_frame_present_flag: u32; /* 1 bits */
        entropy_coding_mode_flag: u32; /* 1 bits */
        pic_scaling_matrix_present_flag: u32; /* 1 bits */;
    */
}

StdVideoH264PictureParameterSet :: struct {
    flags:                                StdVideoH264PpsFlags;
    seq_parameter_set_id:                 u8;
    pic_parameter_set_id:                 u8;
    num_ref_idx_l0_default_active_minus1: u8;
    num_ref_idx_l1_default_active_minus1: u8;
    weighted_bipred_idc:                  StdVideoH264WeightedBipredIdc;
    pic_init_qp_minus26:                  s8;
    pic_init_qs_minus26:                  s8;
    chroma_qp_index_offset:               s8;
    second_chroma_qp_index_offset:        s8;
    pScalingLists:                        *StdVideoH264ScalingLists;
}

StdVideoDecodeH264FieldOrderCount :: enum s32 {
    TOP      :: 0;
    BOTTOM   :: 1;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoDecodeH264PictureInfoFlags :: struct {
    __bitfield: u32;
    /* 
        field_pic_flag: u32; /* 1 bits */
        is_intra: u32; /* 1 bits */
        IdrPicFlag: u32; /* 1 bits */
        bottom_field_flag: u32; /* 1 bits */
        is_reference: u32; /* 1 bits */
        complementary_field_pair: u32; /* 1 bits */;
    */
}

StdVideoDecodeH264PictureInfo :: struct {
    flags:                StdVideoDecodeH264PictureInfoFlags;
    seq_parameter_set_id: u8;
    pic_parameter_set_id: u8;
    reserved1:            u8;
    reserved2:            u8;
    frame_num:            u16;
    idr_pic_id:           u16;
    PicOrderCnt:          [2] s32;
}

StdVideoDecodeH264ReferenceInfoFlags :: struct {
    __bitfield: u32;
    /* 
        top_field_flag: u32; /* 1 bits */
        bottom_field_flag: u32; /* 1 bits */
        used_for_long_term_reference: u32; /* 1 bits */
        is_non_existing: u32; /* 1 bits */;
    */
}

StdVideoDecodeH264ReferenceInfo :: struct {
    flags:       StdVideoDecodeH264ReferenceInfoFlags;
    FrameNum:    u16;
    reserved:    u16;
    PicOrderCnt: [2] s32;
}

VkVideoDecodeH264PictureLayoutFlagBitsKHR :: enum s32 {
    PROGRESSIVE_KHR                      :: 0;
    INTERLACED_INTERLEAVED_LINES_BIT_KHR :: 1;
    INTERLACED_SEPARATE_PLANES_BIT_KHR   :: 2;
    FLAG_BITS_MAX_ENUM_KHR               :: 2147483647;
}

VkVideoDecodeH264PictureLayoutFlagsKHR :: VkFlags;
VkVideoDecodeH264ProfileInfoKHR :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    stdProfileIdc: StdVideoH264ProfileIdc;
    pictureLayout: VkVideoDecodeH264PictureLayoutFlagBitsKHR;
}

VkVideoDecodeH264CapabilitiesKHR :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    maxLevelIdc:            StdVideoH264LevelIdc;
    fieldOffsetGranularity: VkOffset2D;
}

VkVideoDecodeH264SessionParametersAddInfoKHR :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    stdSPSCount: u32;
    pStdSPSs:    *StdVideoH264SequenceParameterSet;
    stdPPSCount: u32;
    pStdPPSs:    *StdVideoH264PictureParameterSet;
}

VkVideoDecodeH264SessionParametersCreateInfoKHR :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    maxStdSPSCount:     u32;
    maxStdPPSCount:     u32;
    pParametersAddInfo: *VkVideoDecodeH264SessionParametersAddInfoKHR;
}

VkVideoDecodeH264PictureInfoKHR :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    pStdPictureInfo: *StdVideoDecodeH264PictureInfo;
    sliceCount:      u32;
    pSliceOffsets:   *u32;
}

VkVideoDecodeH264DpbSlotInfoKHR :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    pStdReferenceInfo: *StdVideoDecodeH264ReferenceInfo;
}

VkRenderingFlagsKHR :: VkRenderingFlags;

VkRenderingFlagBitsKHR :: VkRenderingFlagBits;

VkRenderingInfoKHR :: VkRenderingInfo;

VkRenderingAttachmentInfoKHR :: VkRenderingAttachmentInfo;

VkPipelineRenderingCreateInfoKHR :: VkPipelineRenderingCreateInfo;

VkPhysicalDeviceDynamicRenderingFeaturesKHR :: VkPhysicalDeviceDynamicRenderingFeatures;

VkCommandBufferInheritanceRenderingInfoKHR :: VkCommandBufferInheritanceRenderingInfo;

VkRenderingFragmentShadingRateAttachmentInfoKHR :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    imageView:                      VkImageView;
    imageLayout:                    VkImageLayout;
    shadingRateAttachmentTexelSize: VkExtent2D;
}

VkRenderingFragmentDensityMapAttachmentInfoEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    imageView:   VkImageView;
    imageLayout: VkImageLayout;
}

VkAttachmentSampleCountInfoAMD :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    colorAttachmentCount:          u32;
    pColorAttachmentSamples:       *VkSampleCountFlagBits;
    depthStencilAttachmentSamples: VkSampleCountFlagBits;
}

VkAttachmentSampleCountInfoNV :: VkAttachmentSampleCountInfoAMD;

VkMultiviewPerViewAttributesInfoNVX :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    perViewAttributes:              VkBool32;
    perViewAttributesPositionXOnly: VkBool32;
}

PFN_vkCmdBeginRenderingKHR :: #type (commandBuffer: VkCommandBuffer, pRenderingInfo: *VkRenderingInfo) -> void #c_call;
PFN_vkCmdEndRenderingKHR :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;

VkRenderPassMultiviewCreateInfoKHR :: VkRenderPassMultiviewCreateInfo;

VkPhysicalDeviceMultiviewFeaturesKHR :: VkPhysicalDeviceMultiviewFeatures;

VkPhysicalDeviceMultiviewPropertiesKHR :: VkPhysicalDeviceMultiviewProperties;

VkPhysicalDeviceFeatures2KHR :: VkPhysicalDeviceFeatures2;

VkPhysicalDeviceProperties2KHR :: VkPhysicalDeviceProperties2;

VkFormatProperties2KHR :: VkFormatProperties2;

VkImageFormatProperties2KHR :: VkImageFormatProperties2;

VkPhysicalDeviceImageFormatInfo2KHR :: VkPhysicalDeviceImageFormatInfo2;

VkQueueFamilyProperties2KHR :: VkQueueFamilyProperties2;

VkPhysicalDeviceMemoryProperties2KHR :: VkPhysicalDeviceMemoryProperties2;

VkSparseImageFormatProperties2KHR :: VkSparseImageFormatProperties2;

VkPhysicalDeviceSparseImageFormatInfo2KHR :: VkPhysicalDeviceSparseImageFormatInfo2;

PFN_vkGetPhysicalDeviceFeatures2KHR :: #type (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures2) -> void #c_call;
PFN_vkGetPhysicalDeviceProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceFormatProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceImageFormatProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pImageFormatInfo: *VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *VkImageFormatProperties2) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceMemoryProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pFormatInfo: *VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties2) -> void #c_call;

VkPeerMemoryFeatureFlagsKHR :: VkPeerMemoryFeatureFlags;

VkPeerMemoryFeatureFlagBitsKHR :: VkPeerMemoryFeatureFlagBits;

VkMemoryAllocateFlagsKHR :: VkMemoryAllocateFlags;

VkMemoryAllocateFlagBitsKHR :: VkMemoryAllocateFlagBits;

VkMemoryAllocateFlagsInfoKHR :: VkMemoryAllocateFlagsInfo;

VkDeviceGroupRenderPassBeginInfoKHR :: VkDeviceGroupRenderPassBeginInfo;

VkDeviceGroupCommandBufferBeginInfoKHR :: VkDeviceGroupCommandBufferBeginInfo;

VkDeviceGroupSubmitInfoKHR :: VkDeviceGroupSubmitInfo;

VkDeviceGroupBindSparseInfoKHR :: VkDeviceGroupBindSparseInfo;

VkBindBufferMemoryDeviceGroupInfoKHR :: VkBindBufferMemoryDeviceGroupInfo;

VkBindImageMemoryDeviceGroupInfoKHR :: VkBindImageMemoryDeviceGroupInfo;

PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR :: #type (device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags) -> void #c_call;
PFN_vkCmdSetDeviceMaskKHR :: #type (commandBuffer: VkCommandBuffer, deviceMask: u32) -> void #c_call;
PFN_vkCmdDispatchBaseKHR :: #type (commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;

VkCommandPoolTrimFlagsKHR :: VkCommandPoolTrimFlags;

PFN_vkTrimCommandPoolKHR :: #type (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> void #c_call;

VkPhysicalDeviceGroupPropertiesKHR :: VkPhysicalDeviceGroupProperties;

VkDeviceGroupDeviceCreateInfoKHR :: VkDeviceGroupDeviceCreateInfo;

PFN_vkEnumeratePhysicalDeviceGroupsKHR :: #type (instance: VkInstance, pPhysicalDeviceGroupCount: *u32, pPhysicalDeviceGroupProperties: *VkPhysicalDeviceGroupProperties) -> VkResult #c_call;

VkExternalMemoryHandleTypeFlagsKHR :: VkExternalMemoryHandleTypeFlags;

VkExternalMemoryHandleTypeFlagBitsKHR :: VkExternalMemoryHandleTypeFlagBits;

VkExternalMemoryFeatureFlagsKHR :: VkExternalMemoryFeatureFlags;

VkExternalMemoryFeatureFlagBitsKHR :: VkExternalMemoryFeatureFlagBits;

VkExternalMemoryPropertiesKHR :: VkExternalMemoryProperties;

VkPhysicalDeviceExternalImageFormatInfoKHR :: VkPhysicalDeviceExternalImageFormatInfo;

VkExternalImageFormatPropertiesKHR :: VkExternalImageFormatProperties;

VkPhysicalDeviceExternalBufferInfoKHR :: VkPhysicalDeviceExternalBufferInfo;

VkExternalBufferPropertiesKHR :: VkExternalBufferProperties;

VkPhysicalDeviceIDPropertiesKHR :: VkPhysicalDeviceIDProperties;

PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *VkExternalBufferProperties) -> void #c_call;

VkExternalMemoryImageCreateInfoKHR :: VkExternalMemoryImageCreateInfo;

VkExternalMemoryBufferCreateInfoKHR :: VkExternalMemoryBufferCreateInfo;

VkExportMemoryAllocateInfoKHR :: VkExportMemoryAllocateInfo;

VkImportMemoryFdInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    handleType: VkExternalMemoryHandleTypeFlagBits;
    fd:         s32;
}

VkMemoryFdPropertiesKHR :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    memoryTypeBits: u32;
}

VkMemoryGetFdInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    memory:     VkDeviceMemory;
    handleType: VkExternalMemoryHandleTypeFlagBits;
}

PFN_vkGetMemoryFdKHR :: #type (device: VkDevice, pGetFdInfo: *VkMemoryGetFdInfoKHR, pFd: *s32) -> VkResult #c_call;
PFN_vkGetMemoryFdPropertiesKHR :: #type (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, fd: s32, pMemoryFdProperties: *VkMemoryFdPropertiesKHR) -> VkResult #c_call;

VkExternalSemaphoreHandleTypeFlagsKHR :: VkExternalSemaphoreHandleTypeFlags;

VkExternalSemaphoreHandleTypeFlagBitsKHR :: VkExternalSemaphoreHandleTypeFlagBits;

VkExternalSemaphoreFeatureFlagsKHR :: VkExternalSemaphoreFeatureFlags;

VkExternalSemaphoreFeatureFlagBitsKHR :: VkExternalSemaphoreFeatureFlagBits;

VkPhysicalDeviceExternalSemaphoreInfoKHR :: VkPhysicalDeviceExternalSemaphoreInfo;

VkExternalSemaphorePropertiesKHR :: VkExternalSemaphoreProperties;

PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *VkExternalSemaphoreProperties) -> void #c_call;

VkSemaphoreImportFlagsKHR :: VkSemaphoreImportFlags;

VkSemaphoreImportFlagBitsKHR :: VkSemaphoreImportFlagBits;

VkExportSemaphoreCreateInfoKHR :: VkExportSemaphoreCreateInfo;

VkImportSemaphoreFdInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    semaphore:  VkSemaphore;
    flags:      VkSemaphoreImportFlags;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
    fd:         s32;
}

VkSemaphoreGetFdInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    semaphore:  VkSemaphore;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
}

PFN_vkImportSemaphoreFdKHR :: #type (device: VkDevice, pImportSemaphoreFdInfo: *VkImportSemaphoreFdInfoKHR) -> VkResult #c_call;
PFN_vkGetSemaphoreFdKHR :: #type (device: VkDevice, pGetFdInfo: *VkSemaphoreGetFdInfoKHR, pFd: *s32) -> VkResult #c_call;

VkPhysicalDevicePushDescriptorPropertiesKHR :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    maxPushDescriptors: u32;
}

PFN_vkCmdPushDescriptorSetKHR :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *VkWriteDescriptorSet) -> void #c_call;
PFN_vkCmdPushDescriptorSetWithTemplateKHR :: #type (commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *void) -> void #c_call;

VkPhysicalDeviceShaderFloat16Int8FeaturesKHR :: VkPhysicalDeviceShaderFloat16Int8Features;

VkPhysicalDeviceFloat16Int8FeaturesKHR :: VkPhysicalDeviceShaderFloat16Int8Features;

VkPhysicalDevice16BitStorageFeaturesKHR :: VkPhysicalDevice16BitStorageFeatures;

VkRectLayerKHR :: struct {
    offset: VkOffset2D;
    extent: VkExtent2D;
    layer:  u32;
}

VkPresentRegionKHR :: struct {
    rectangleCount: u32;
    pRectangles:    *VkRectLayerKHR;
}

VkPresentRegionsKHR :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    swapchainCount: u32;
    pRegions:       *VkPresentRegionKHR;
}

VkDescriptorUpdateTemplateKHR :: VkDescriptorUpdateTemplate;

VkDescriptorUpdateTemplateTypeKHR :: VkDescriptorUpdateTemplateType;

VkDescriptorUpdateTemplateCreateFlagsKHR :: VkDescriptorUpdateTemplateCreateFlags;

VkDescriptorUpdateTemplateEntryKHR :: VkDescriptorUpdateTemplateEntry;

VkDescriptorUpdateTemplateCreateInfoKHR :: VkDescriptorUpdateTemplateCreateInfo;

PFN_vkCreateDescriptorUpdateTemplateKHR :: #type (device: VkDevice, pCreateInfo: *VkDescriptorUpdateTemplateCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate) -> VkResult #c_call;
PFN_vkDestroyDescriptorUpdateTemplateKHR :: #type (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkUpdateDescriptorSetWithTemplateKHR :: #type (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *void) -> void #c_call;

VkPhysicalDeviceImagelessFramebufferFeaturesKHR :: VkPhysicalDeviceImagelessFramebufferFeatures;

VkFramebufferAttachmentsCreateInfoKHR :: VkFramebufferAttachmentsCreateInfo;

VkFramebufferAttachmentImageInfoKHR :: VkFramebufferAttachmentImageInfo;

VkRenderPassAttachmentBeginInfoKHR :: VkRenderPassAttachmentBeginInfo;

VkRenderPassCreateInfo2KHR :: VkRenderPassCreateInfo2;

VkAttachmentDescription2KHR :: VkAttachmentDescription2;

VkAttachmentReference2KHR :: VkAttachmentReference2;

VkSubpassDescription2KHR :: VkSubpassDescription2;

VkSubpassDependency2KHR :: VkSubpassDependency2;

VkSubpassBeginInfoKHR :: VkSubpassBeginInfo;

VkSubpassEndInfoKHR :: VkSubpassEndInfo;

PFN_vkCreateRenderPass2KHR :: #type (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo2, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) -> VkResult #c_call;
PFN_vkCmdBeginRenderPass2KHR :: #type (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, pSubpassBeginInfo: *VkSubpassBeginInfo) -> void #c_call;
PFN_vkCmdNextSubpass2KHR :: #type (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *VkSubpassBeginInfo, pSubpassEndInfo: *VkSubpassEndInfo) -> void #c_call;
PFN_vkCmdEndRenderPass2KHR :: #type (commandBuffer: VkCommandBuffer, pSubpassEndInfo: *VkSubpassEndInfo) -> void #c_call;

VkSharedPresentSurfaceCapabilitiesKHR :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    sharedPresentSupportedUsageFlags: VkImageUsageFlags;
}

PFN_vkGetSwapchainStatusKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult #c_call;

VkExternalFenceHandleTypeFlagsKHR :: VkExternalFenceHandleTypeFlags;

VkExternalFenceHandleTypeFlagBitsKHR :: VkExternalFenceHandleTypeFlagBits;

VkExternalFenceFeatureFlagsKHR :: VkExternalFenceFeatureFlags;

VkExternalFenceFeatureFlagBitsKHR :: VkExternalFenceFeatureFlagBits;

VkPhysicalDeviceExternalFenceInfoKHR :: VkPhysicalDeviceExternalFenceInfo;

VkExternalFencePropertiesKHR :: VkExternalFenceProperties;

PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *VkExternalFenceProperties) -> void #c_call;

VkFenceImportFlagsKHR :: VkFenceImportFlags;

VkFenceImportFlagBitsKHR :: VkFenceImportFlagBits;

VkExportFenceCreateInfoKHR :: VkExportFenceCreateInfo;

VkImportFenceFdInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    fence:      VkFence;
    flags:      VkFenceImportFlags;
    handleType: VkExternalFenceHandleTypeFlagBits;
    fd:         s32;
}

VkFenceGetFdInfoKHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    fence:      VkFence;
    handleType: VkExternalFenceHandleTypeFlagBits;
}

PFN_vkImportFenceFdKHR :: #type (device: VkDevice, pImportFenceFdInfo: *VkImportFenceFdInfoKHR) -> VkResult #c_call;
PFN_vkGetFenceFdKHR :: #type (device: VkDevice, pGetFdInfo: *VkFenceGetFdInfoKHR, pFd: *s32) -> VkResult #c_call;

VkPerformanceCounterUnitKHR :: enum s32 {
    GENERIC_KHR          :: 0;
    PERCENTAGE_KHR       :: 1;
    NANOSECONDS_KHR      :: 2;
    BYTES_KHR            :: 3;
    BYTES_PER_SECOND_KHR :: 4;
    KELVIN_KHR           :: 5;
    WATTS_KHR            :: 6;
    VOLTS_KHR            :: 7;
    AMPS_KHR             :: 8;
    HERTZ_KHR            :: 9;
    CYCLES_KHR           :: 10;
    MAX_ENUM_KHR         :: 2147483647;
}

VkPerformanceCounterScopeKHR :: enum s32 {
    PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR :: 0;
    PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR    :: 1;
    PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR        :: 2;
    QUERY_SCOPE_COMMAND_BUFFER_KHR               :: 0;
    QUERY_SCOPE_RENDER_PASS_KHR                  :: 1;
    QUERY_SCOPE_COMMAND_KHR                      :: 2;
    PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR       :: 2147483647;
}

VkPerformanceCounterStorageKHR :: enum s32 {
    INT32_KHR    :: 0;
    INT64_KHR    :: 1;
    UINT32_KHR   :: 2;
    UINT64_KHR   :: 3;
    FLOAT32_KHR  :: 4;
    FLOAT64_KHR  :: 5;
    MAX_ENUM_KHR :: 2147483647;
}

VkPerformanceCounterDescriptionFlagBitsKHR :: enum s32 {
    PERFORMANCE_IMPACTING_BIT_KHR :: 1;
    CONCURRENTLY_IMPACTED_BIT_KHR :: 2;
    PERFORMANCE_IMPACTING_KHR     :: 1;
    CONCURRENTLY_IMPACTED_KHR     :: 2;
    FLAG_BITS_MAX_ENUM_KHR        :: 2147483647;
}

VkPerformanceCounterDescriptionFlagsKHR :: VkFlags;

VkAcquireProfilingLockFlagBitsKHR :: enum s32 {
    VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR :: 2147483647;
}

VkAcquireProfilingLockFlagsKHR :: VkFlags;
VkPhysicalDevicePerformanceQueryFeaturesKHR :: struct {
    sType:                                VkStructureType;
    pNext:                                *void;
    performanceCounterQueryPools:         VkBool32;
    performanceCounterMultipleQueryPools: VkBool32;
}

VkPhysicalDevicePerformanceQueryPropertiesKHR :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    allowCommandBufferQueryCopies: VkBool32;
}

VkPerformanceCounterKHR :: struct {
    sType:   VkStructureType;
    pNext:   *void;
    unit:    VkPerformanceCounterUnitKHR;
    scope:   VkPerformanceCounterScopeKHR;
    storage: VkPerformanceCounterStorageKHR;
    uuid:    [16] u8;
}

VkPerformanceCounterDescriptionKHR :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    flags:       VkPerformanceCounterDescriptionFlagsKHR;
    name:        [256] u8;
    category:    [256] u8;
    description: [256] u8;
}

VkQueryPoolPerformanceCreateInfoKHR :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    queueFamilyIndex:  u32;
    counterIndexCount: u32;
    pCounterIndices:   *u32;
}

VkPerformanceCounterResultKHR :: union {
    int32:    s32;
    int64:    s64;
    uint32:   u32;
    uint64:   u64;
    _float32: float;
    _float64: float64;
}

VkAcquireProfilingLockInfoKHR :: struct {
    sType:   VkStructureType;
    pNext:   *void;
    flags:   VkAcquireProfilingLockFlagsKHR;
    timeout: u64;
}

VkPerformanceQuerySubmitInfoKHR :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    counterPassIndex: u32;
}

PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *u32, pCounters: *VkPerformanceCounterKHR, pCounterDescriptions: *VkPerformanceCounterDescriptionKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR :: #type (physicalDevice: VkPhysicalDevice, pPerformanceQueryCreateInfo: *VkQueryPoolPerformanceCreateInfoKHR, pNumPasses: *u32) -> void #c_call;
PFN_vkAcquireProfilingLockKHR :: #type (device: VkDevice, pInfo: *VkAcquireProfilingLockInfoKHR) -> VkResult #c_call;
PFN_vkReleaseProfilingLockKHR :: #type (device: VkDevice) -> void #c_call;

VkPointClippingBehaviorKHR :: VkPointClippingBehavior;

VkTessellationDomainOriginKHR :: VkTessellationDomainOrigin;

VkPhysicalDevicePointClippingPropertiesKHR :: VkPhysicalDevicePointClippingProperties;

VkRenderPassInputAttachmentAspectCreateInfoKHR :: VkRenderPassInputAttachmentAspectCreateInfo;

VkInputAttachmentAspectReferenceKHR :: VkInputAttachmentAspectReference;

VkImageViewUsageCreateInfoKHR :: VkImageViewUsageCreateInfo;

VkPipelineTessellationDomainOriginStateCreateInfoKHR :: VkPipelineTessellationDomainOriginStateCreateInfo;

VkPhysicalDeviceSurfaceInfo2KHR :: struct {
    sType:   VkStructureType;
    pNext:   *void;
    surface: VkSurfaceKHR;
}

VkSurfaceCapabilities2KHR :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    surfaceCapabilities: VkSurfaceCapabilitiesKHR;
}

VkSurfaceFormat2KHR :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    surfaceFormat: VkSurfaceFormatKHR;
}

PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR :: #type (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *VkSurfaceCapabilities2KHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfaceFormats2KHR :: #type (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *u32, pSurfaceFormats: *VkSurfaceFormat2KHR) -> VkResult #c_call;

VkPhysicalDeviceVariablePointerFeaturesKHR :: VkPhysicalDeviceVariablePointersFeatures;

VkPhysicalDeviceVariablePointersFeaturesKHR :: VkPhysicalDeviceVariablePointersFeatures;

VkDisplayProperties2KHR :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    displayProperties: VkDisplayPropertiesKHR;
}

VkDisplayPlaneProperties2KHR :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    displayPlaneProperties: VkDisplayPlanePropertiesKHR;
}

VkDisplayModeProperties2KHR :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    displayModeProperties: VkDisplayModePropertiesKHR;
}

VkDisplayPlaneInfo2KHR :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    mode:       VkDisplayModeKHR;
    planeIndex: u32;
}

VkDisplayPlaneCapabilities2KHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    capabilities: VkDisplayPlaneCapabilitiesKHR;
}

PFN_vkGetPhysicalDeviceDisplayProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayProperties2KHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPlaneProperties2KHR) -> VkResult #c_call;
PFN_vkGetDisplayModeProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *u32, pProperties: *VkDisplayModeProperties2KHR) -> VkResult #c_call;
PFN_vkGetDisplayPlaneCapabilities2KHR :: #type (physicalDevice: VkPhysicalDevice, pDisplayPlaneInfo: *VkDisplayPlaneInfo2KHR, pCapabilities: *VkDisplayPlaneCapabilities2KHR) -> VkResult #c_call;

VkMemoryDedicatedRequirementsKHR :: VkMemoryDedicatedRequirements;

VkMemoryDedicatedAllocateInfoKHR :: VkMemoryDedicatedAllocateInfo;

VkBufferMemoryRequirementsInfo2KHR :: VkBufferMemoryRequirementsInfo2;

VkImageMemoryRequirementsInfo2KHR :: VkImageMemoryRequirementsInfo2;

VkImageSparseMemoryRequirementsInfo2KHR :: VkImageSparseMemoryRequirementsInfo2;

VkMemoryRequirements2KHR :: VkMemoryRequirements2;

VkSparseImageMemoryRequirements2KHR :: VkSparseImageMemoryRequirements2;

PFN_vkGetImageMemoryRequirements2KHR :: #type (device: VkDevice, pInfo: *VkImageMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetBufferMemoryRequirements2KHR :: #type (device: VkDevice, pInfo: *VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetImageSparseMemoryRequirements2KHR :: #type (device: VkDevice, pInfo: *VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) -> void #c_call;

VkImageFormatListCreateInfoKHR :: VkImageFormatListCreateInfo;

VkSamplerYcbcrConversionKHR :: VkSamplerYcbcrConversion;

VkSamplerYcbcrModelConversionKHR :: VkSamplerYcbcrModelConversion;

VkSamplerYcbcrRangeKHR :: VkSamplerYcbcrRange;

VkChromaLocationKHR :: VkChromaLocation;

VkSamplerYcbcrConversionCreateInfoKHR :: VkSamplerYcbcrConversionCreateInfo;

VkSamplerYcbcrConversionInfoKHR :: VkSamplerYcbcrConversionInfo;

VkBindImagePlaneMemoryInfoKHR :: VkBindImagePlaneMemoryInfo;

VkImagePlaneMemoryRequirementsInfoKHR :: VkImagePlaneMemoryRequirementsInfo;

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR :: VkPhysicalDeviceSamplerYcbcrConversionFeatures;

VkSamplerYcbcrConversionImageFormatPropertiesKHR :: VkSamplerYcbcrConversionImageFormatProperties;

PFN_vkCreateSamplerYcbcrConversionKHR :: #type (device: VkDevice, pCreateInfo: *VkSamplerYcbcrConversionCreateInfo, pAllocator: *VkAllocationCallbacks, pYcbcrConversion: *VkSamplerYcbcrConversion) -> VkResult #c_call;
PFN_vkDestroySamplerYcbcrConversionKHR :: #type (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *VkAllocationCallbacks) -> void #c_call;

VkBindBufferMemoryInfoKHR :: VkBindBufferMemoryInfo;

VkBindImageMemoryInfoKHR :: VkBindImageMemoryInfo;

PFN_vkBindBufferMemory2KHR :: #type (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindBufferMemoryInfo) -> VkResult #c_call;
PFN_vkBindImageMemory2KHR :: #type (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindImageMemoryInfo) -> VkResult #c_call;

VkPhysicalDeviceMaintenance3PropertiesKHR :: VkPhysicalDeviceMaintenance3Properties;

VkDescriptorSetLayoutSupportKHR :: VkDescriptorSetLayoutSupport;

PFN_vkGetDescriptorSetLayoutSupportKHR :: #type (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pSupport: *VkDescriptorSetLayoutSupport) -> void #c_call;

PFN_vkCmdDrawIndirectCountKHR :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawIndexedIndirectCountKHR :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;

VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR :: VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;

VkPhysicalDevice8BitStorageFeaturesKHR :: VkPhysicalDevice8BitStorageFeatures;

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR :: VkPhysicalDeviceShaderAtomicInt64Features;

VkPhysicalDeviceShaderClockFeaturesKHR :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    shaderSubgroupClock: VkBool32;
    shaderDeviceClock:   VkBool32;
}

StdVideoH265ChromaFormatIdc :: enum s32 {
    MONOCHROME :: 0;
    _420       :: 1;
    _422       :: 2;
    _444       :: 3;
    INVALID    :: 2147483647;
    MAX_ENUM   :: 2147483647;
}

StdVideoH265ProfileIdc :: enum s32 {
    MAIN                    :: 1;
    MAIN_10                 :: 2;
    MAIN_STILL_PICTURE      :: 3;
    FORMAT_RANGE_EXTENSIONS :: 4;
    SCC_EXTENSIONS          :: 9;
    INVALID                 :: 2147483647;
    MAX_ENUM                :: 2147483647;
}

StdVideoH265LevelIdc :: enum s32 {
    _1_0     :: 0;
    _2_0     :: 1;
    _2_1     :: 2;
    _3_0     :: 3;
    _3_1     :: 4;
    _4_0     :: 5;
    _4_1     :: 6;
    _5_0     :: 7;
    _5_1     :: 8;
    _5_2     :: 9;
    _6_0     :: 10;
    _6_1     :: 11;
    _6_2     :: 12;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH265SliceType :: enum s32 {
    B        :: 0;
    P        :: 1;
    I        :: 2;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH265PictureType :: enum s32 {
    P        :: 0;
    B        :: 1;
    I        :: 2;
    IDR      :: 3;
    INVALID  :: 2147483647;
    MAX_ENUM :: 2147483647;
}

StdVideoH265AspectRatioIdc :: enum s32 {
    UNSPECIFIED  :: 0;
    SQUARE       :: 1;
    _12_11       :: 2;
    _10_11       :: 3;
    _16_11       :: 4;
    _40_33       :: 5;
    _24_11       :: 6;
    _20_11       :: 7;
    _32_11       :: 8;
    _80_33       :: 9;
    _18_11       :: 10;
    _15_11       :: 11;
    _64_33       :: 12;
    _160_99      :: 13;
    _4_3         :: 14;
    _3_2         :: 15;
    _2_1         :: 16;
    EXTENDED_SAR :: 255;
    INVALID      :: 2147483647;
    MAX_ENUM     :: 2147483647;
}

StdVideoH265DecPicBufMgr :: struct {
    max_latency_increase_plus1:   [7] u32;
    max_dec_pic_buffering_minus1: [7] u8;
    max_num_reorder_pics:         [7] u8;
}

StdVideoH265SubLayerHrdParameters :: struct {
    bit_rate_value_minus1:    [32] u32;
    cpb_size_value_minus1:    [32] u32;
    cpb_size_du_value_minus1: [32] u32;
    bit_rate_du_value_minus1: [32] u32;
    cbr_flag:                 u32;
}

StdVideoH265HrdFlags :: struct {
    __bitfield: u32;
    /* 
        nal_hrd_parameters_present_flag: u32; /* 1 bits */
        vcl_hrd_parameters_present_flag: u32; /* 1 bits */
        sub_pic_hrd_params_present_flag: u32; /* 1 bits */
        sub_pic_cpb_params_in_pic_timing_sei_flag: u32; /* 1 bits */
        fixed_pic_rate_general_flag: u32; /* 8 bits */
        fixed_pic_rate_within_cvs_flag: u32; /* 8 bits */
        low_delay_hrd_flag: u32; /* 8 bits */;
    */
}

StdVideoH265HrdParameters :: struct {
    flags:                                        StdVideoH265HrdFlags;
    tick_divisor_minus2:                          u8;
    du_cpb_removal_delay_increment_length_minus1: u8;
    dpb_output_delay_du_length_minus1:            u8;
    bit_rate_scale:                               u8;
    cpb_size_scale:                               u8;
    cpb_size_du_scale:                            u8;
    initial_cpb_removal_delay_length_minus1:      u8;
    au_cpb_removal_delay_length_minus1:           u8;
    dpb_output_delay_length_minus1:               u8;
    cpb_cnt_minus1:                               [7] u8;
    elemental_duration_in_tc_minus1:              [7] u16;
    reserved:                                     [3] u16;
    pSubLayerHrdParametersNal:                    *StdVideoH265SubLayerHrdParameters;
    pSubLayerHrdParametersVcl:                    *StdVideoH265SubLayerHrdParameters;
}

StdVideoH265VpsFlags :: struct {
    __bitfield: u32;
    /* 
        vps_temporal_id_nesting_flag: u32; /* 1 bits */
        vps_sub_layer_ordering_info_present_flag: u32; /* 1 bits */
        vps_timing_info_present_flag: u32; /* 1 bits */
        vps_poc_proportional_to_timing_flag: u32; /* 1 bits */;
    */
}

StdVideoH265ProfileTierLevelFlags :: struct {
    __bitfield: u32;
    /* 
        general_tier_flag: u32; /* 1 bits */
        general_progressive_source_flag: u32; /* 1 bits */
        general_interlaced_source_flag: u32; /* 1 bits */
        general_non_packed_constraint_flag: u32; /* 1 bits */
        general_frame_only_constraint_flag: u32; /* 1 bits */;
    */
}

StdVideoH265ProfileTierLevel :: struct {
    flags:               StdVideoH265ProfileTierLevelFlags;
    general_profile_idc: StdVideoH265ProfileIdc;
    general_level_idc:   StdVideoH265LevelIdc;
}

StdVideoH265VideoParameterSet :: struct {
    flags:                             StdVideoH265VpsFlags;
    vps_video_parameter_set_id:        u8;
    vps_max_sub_layers_minus1:         u8;
    reserved1:                         u8;
    reserved2:                         u8;
    vps_num_units_in_tick:             u32;
    vps_time_scale:                    u32;
    vps_num_ticks_poc_diff_one_minus1: u32;
    reserved3:                         u32;
    pDecPicBufMgr:                     *StdVideoH265DecPicBufMgr;
    pHrdParameters:                    *StdVideoH265HrdParameters;
    pProfileTierLevel:                 *StdVideoH265ProfileTierLevel;
}

StdVideoH265ScalingLists :: struct {
    ScalingList4x4:         [6] [16] u8;
    ScalingList8x8:         [6] [64] u8;
    ScalingList16x16:       [6] [64] u8;
    ScalingList32x32:       [2] [64] u8;
    ScalingListDCCoef16x16: [6] u8;
    ScalingListDCCoef32x32: [2] u8;
}

StdVideoH265SpsVuiFlags :: struct {
    __bitfield: u32;
    /* 
        aspect_ratio_info_present_flag: u32; /* 1 bits */
        overscan_info_present_flag: u32; /* 1 bits */
        overscan_appropriate_flag: u32; /* 1 bits */
        video_signal_type_present_flag: u32; /* 1 bits */
        video_full_range_flag: u32; /* 1 bits */
        colour_description_present_flag: u32; /* 1 bits */
        chroma_loc_info_present_flag: u32; /* 1 bits */
        neutral_chroma_indication_flag: u32; /* 1 bits */
        field_seq_flag: u32; /* 1 bits */
        frame_field_info_present_flag: u32; /* 1 bits */
        default_display_window_flag: u32; /* 1 bits */
        vui_timing_info_present_flag: u32; /* 1 bits */
        vui_poc_proportional_to_timing_flag: u32; /* 1 bits */
        vui_hrd_parameters_present_flag: u32; /* 1 bits */
        bitstream_restriction_flag: u32; /* 1 bits */
        tiles_fixed_structure_flag: u32; /* 1 bits */
        motion_vectors_over_pic_boundaries_flag: u32; /* 1 bits */
        restricted_ref_pic_lists_flag: u32; /* 1 bits */;
    */
}

StdVideoH265SequenceParameterSetVui :: struct {
    flags:                               StdVideoH265SpsVuiFlags;
    aspect_ratio_idc:                    StdVideoH265AspectRatioIdc;
    sar_width:                           u16;
    sar_height:                          u16;
    video_format:                        u8;
    colour_primaries:                    u8;
    transfer_characteristics:            u8;
    matrix_coeffs:                       u8;
    chroma_sample_loc_type_top_field:    u8;
    chroma_sample_loc_type_bottom_field: u8;
    reserved1:                           u8;
    reserved2:                           u8;
    def_disp_win_left_offset:            u16;
    def_disp_win_right_offset:           u16;
    def_disp_win_top_offset:             u16;
    def_disp_win_bottom_offset:          u16;
    vui_num_units_in_tick:               u32;
    vui_time_scale:                      u32;
    vui_num_ticks_poc_diff_one_minus1:   u32;
    min_spatial_segmentation_idc:        u16;
    reserved3:                           u16;
    max_bytes_per_pic_denom:             u8;
    max_bits_per_min_cu_denom:           u8;
    log2_max_mv_length_horizontal:       u8;
    log2_max_mv_length_vertical:         u8;
    pHrdParameters:                      *StdVideoH265HrdParameters;
}

StdVideoH265PredictorPaletteEntries :: struct {
    PredictorPaletteEntries: [3] [128] u16;
}

StdVideoH265SpsFlags :: struct {
    __bitfield: u32;
    /* 
        sps_temporal_id_nesting_flag: u32; /* 1 bits */
        separate_colour_plane_flag: u32; /* 1 bits */
        conformance_window_flag: u32; /* 1 bits */
        sps_sub_layer_ordering_info_present_flag: u32; /* 1 bits */
        scaling_list_enabled_flag: u32; /* 1 bits */
        sps_scaling_list_data_present_flag: u32; /* 1 bits */
        amp_enabled_flag: u32; /* 1 bits */
        sample_adaptive_offset_enabled_flag: u32; /* 1 bits */
        pcm_enabled_flag: u32; /* 1 bits */
        pcm_loop_filter_disabled_flag: u32; /* 1 bits */
        long_term_ref_pics_present_flag: u32; /* 1 bits */
        sps_temporal_mvp_enabled_flag: u32; /* 1 bits */
        strong_intra_smoothing_enabled_flag: u32; /* 1 bits */
        vui_parameters_present_flag: u32; /* 1 bits */
        sps_extension_present_flag: u32; /* 1 bits */
        sps_range_extension_flag: u32; /* 1 bits */
        transform_skip_rotation_enabled_flag: u32; /* 1 bits */
        transform_skip_context_enabled_flag: u32; /* 1 bits */
        implicit_rdpcm_enabled_flag: u32; /* 1 bits */
        explicit_rdpcm_enabled_flag: u32; /* 1 bits */
        extended_precision_processing_flag: u32; /* 1 bits */
        intra_smoothing_disabled_flag: u32; /* 1 bits */
        high_precision_offsets_enabled_flag: u32; /* 1 bits */
        persistent_rice_adaptation_enabled_flag: u32; /* 1 bits */
        cabac_bypass_alignment_enabled_flag: u32; /* 1 bits */
        sps_scc_extension_flag: u32; /* 1 bits */
        sps_curr_pic_ref_enabled_flag: u32; /* 1 bits */
        palette_mode_enabled_flag: u32; /* 1 bits */
        sps_palette_predictor_initializers_present_flag: u32; /* 1 bits */
        intra_boundary_filtering_disabled_flag: u32; /* 1 bits */;
    */
}

StdVideoH265ShortTermRefPicSetFlags :: struct {
    __bitfield: u32;
    /* 
        inter_ref_pic_set_prediction_flag: u32; /* 1 bits */
        delta_rps_sign: u32; /* 1 bits */;
    */
}

StdVideoH265ShortTermRefPicSet :: struct {
    flags:                    StdVideoH265ShortTermRefPicSetFlags;
    delta_idx_minus1:         u32;
    use_delta_flag:           u16;
    abs_delta_rps_minus1:     u16;
    used_by_curr_pic_flag:    u16;
    used_by_curr_pic_s0_flag: u16;
    used_by_curr_pic_s1_flag: u16;
    reserved1:                u16;
    reserved2:                u8;
    reserved3:                u8;
    num_negative_pics:        u8;
    num_positive_pics:        u8;
    delta_poc_s0_minus1:      [16] u16;
    delta_poc_s1_minus1:      [16] u16;
}

StdVideoH265LongTermRefPicsSps :: struct {
    used_by_curr_pic_lt_sps_flag: u32;
    lt_ref_pic_poc_lsb_sps:       [32] u32;
}

StdVideoH265SequenceParameterSet :: struct {
    flags:                                         StdVideoH265SpsFlags;
    chroma_format_idc:                             StdVideoH265ChromaFormatIdc;
    pic_width_in_luma_samples:                     u32;
    pic_height_in_luma_samples:                    u32;
    sps_video_parameter_set_id:                    u8;
    sps_max_sub_layers_minus1:                     u8;
    sps_seq_parameter_set_id:                      u8;
    bit_depth_luma_minus8:                         u8;
    bit_depth_chroma_minus8:                       u8;
    log2_max_pic_order_cnt_lsb_minus4:             u8;
    log2_min_luma_coding_block_size_minus3:        u8;
    log2_diff_max_min_luma_coding_block_size:      u8;
    log2_min_luma_transform_block_size_minus2:     u8;
    log2_diff_max_min_luma_transform_block_size:   u8;
    max_transform_hierarchy_depth_inter:           u8;
    max_transform_hierarchy_depth_intra:           u8;
    num_short_term_ref_pic_sets:                   u8;
    num_long_term_ref_pics_sps:                    u8;
    pcm_sample_bit_depth_luma_minus1:              u8;
    pcm_sample_bit_depth_chroma_minus1:            u8;
    log2_min_pcm_luma_coding_block_size_minus3:    u8;
    log2_diff_max_min_pcm_luma_coding_block_size:  u8;
    reserved1:                                     u8;
    reserved2:                                     u8;
    palette_max_size:                              u8;
    delta_palette_max_predictor_size:              u8;
    motion_vector_resolution_control_idc:          u8;
    sps_num_palette_predictor_initializers_minus1: u8;
    conf_win_left_offset:                          u32;
    conf_win_right_offset:                         u32;
    conf_win_top_offset:                           u32;
    conf_win_bottom_offset:                        u32;
    pProfileTierLevel:                             *StdVideoH265ProfileTierLevel;
    pDecPicBufMgr:                                 *StdVideoH265DecPicBufMgr;
    pScalingLists:                                 *StdVideoH265ScalingLists;
    pShortTermRefPicSet:                           *StdVideoH265ShortTermRefPicSet;
    pLongTermRefPicsSps:                           *StdVideoH265LongTermRefPicsSps;
    pSequenceParameterSetVui:                      *StdVideoH265SequenceParameterSetVui;
    pPredictorPaletteEntries:                      *StdVideoH265PredictorPaletteEntries;
}

StdVideoH265PpsFlags :: struct {
    __bitfield: u32;
    /* 
        dependent_slice_segments_enabled_flag: u32; /* 1 bits */
        output_flag_present_flag: u32; /* 1 bits */
        sign_data_hiding_enabled_flag: u32; /* 1 bits */
        cabac_init_present_flag: u32; /* 1 bits */
        constrained_intra_pred_flag: u32; /* 1 bits */
        transform_skip_enabled_flag: u32; /* 1 bits */
        cu_qp_delta_enabled_flag: u32; /* 1 bits */
        pps_slice_chroma_qp_offsets_present_flag: u32; /* 1 bits */
        weighted_pred_flag: u32; /* 1 bits */
        weighted_bipred_flag: u32; /* 1 bits */
        transquant_bypass_enabled_flag: u32; /* 1 bits */
        tiles_enabled_flag: u32; /* 1 bits */
        entropy_coding_sync_enabled_flag: u32; /* 1 bits */
        uniform_spacing_flag: u32; /* 1 bits */
        loop_filter_across_tiles_enabled_flag: u32; /* 1 bits */
        pps_loop_filter_across_slices_enabled_flag: u32; /* 1 bits */
        deblocking_filter_control_present_flag: u32; /* 1 bits */
        deblocking_filter_override_enabled_flag: u32; /* 1 bits */
        pps_deblocking_filter_disabled_flag: u32; /* 1 bits */
        pps_scaling_list_data_present_flag: u32; /* 1 bits */
        lists_modification_present_flag: u32; /* 1 bits */
        slice_segment_header_extension_present_flag: u32; /* 1 bits */
        pps_extension_present_flag: u32; /* 1 bits */
        cross_component_prediction_enabled_flag: u32; /* 1 bits */
        chroma_qp_offset_list_enabled_flag: u32; /* 1 bits */
        pps_curr_pic_ref_enabled_flag: u32; /* 1 bits */
        residual_adaptive_colour_transform_enabled_flag: u32; /* 1 bits */
        pps_slice_act_qp_offsets_present_flag: u32; /* 1 bits */
        pps_palette_predictor_initializers_present_flag: u32; /* 1 bits */
        monochrome_palette_flag: u32; /* 1 bits */
        pps_range_extension_flag: u32; /* 1 bits */;
    */
}

StdVideoH265PictureParameterSet :: struct {
    flags:                                     StdVideoH265PpsFlags;
    pps_pic_parameter_set_id:                  u8;
    pps_seq_parameter_set_id:                  u8;
    sps_video_parameter_set_id:                u8;
    num_extra_slice_header_bits:               u8;
    num_ref_idx_l0_default_active_minus1:      u8;
    num_ref_idx_l1_default_active_minus1:      u8;
    init_qp_minus26:                           s8;
    diff_cu_qp_delta_depth:                    u8;
    pps_cb_qp_offset:                          s8;
    pps_cr_qp_offset:                          s8;
    pps_beta_offset_div2:                      s8;
    pps_tc_offset_div2:                        s8;
    log2_parallel_merge_level_minus2:          u8;
    log2_max_transform_skip_block_size_minus2: u8;
    diff_cu_chroma_qp_offset_depth:            u8;
    chroma_qp_offset_list_len_minus1:          u8;
    cb_qp_offset_list:                         [6] s8;
    cr_qp_offset_list:                         [6] s8;
    log2_sao_offset_scale_luma:                u8;
    log2_sao_offset_scale_chroma:              u8;
    pps_act_y_qp_offset_plus5:                 s8;
    pps_act_cb_qp_offset_plus5:                s8;
    pps_act_cr_qp_offset_plus3:                s8;
    pps_num_palette_predictor_initializers:    u8;
    luma_bit_depth_entry_minus8:               u8;
    chroma_bit_depth_entry_minus8:             u8;
    num_tile_columns_minus1:                   u8;
    num_tile_rows_minus1:                      u8;
    reserved1:                                 u8;
    reserved2:                                 u8;
    column_width_minus1:                       [19] u16;
    row_height_minus1:                         [21] u16;
    reserved3:                                 u32;
    pScalingLists:                             *StdVideoH265ScalingLists;
    pPredictorPaletteEntries:                  *StdVideoH265PredictorPaletteEntries;
}

StdVideoDecodeH265PictureInfoFlags :: struct {
    __bitfield: u32;
    /* 
        IrapPicFlag: u32; /* 1 bits */
        IdrPicFlag: u32; /* 1 bits */
        IsReference: u32; /* 1 bits */
        short_term_ref_pic_set_sps_flag: u32; /* 1 bits */;
    */
}

StdVideoDecodeH265PictureInfo :: struct {
    flags:                        StdVideoDecodeH265PictureInfoFlags;
    sps_video_parameter_set_id:   u8;
    pps_seq_parameter_set_id:     u8;
    pps_pic_parameter_set_id:     u8;
    NumDeltaPocsOfRefRpsIdx:      u8;
    PicOrderCntVal:               s32;
    NumBitsForSTRefPicSetInSlice: u16;
    reserved:                     u16;
    RefPicSetStCurrBefore:        [8] u8;
    RefPicSetStCurrAfter:         [8] u8;
    RefPicSetLtCurr:              [8] u8;
}

StdVideoDecodeH265ReferenceInfoFlags :: struct {
    __bitfield: u32;
    /* 
        used_for_long_term_reference: u32; /* 1 bits */
        unused_for_reference: u32; /* 1 bits */;
    */
}

StdVideoDecodeH265ReferenceInfo :: struct {
    flags:          StdVideoDecodeH265ReferenceInfoFlags;
    PicOrderCntVal: s32;
}

VkVideoDecodeH265ProfileInfoKHR :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    stdProfileIdc: StdVideoH265ProfileIdc;
}

VkVideoDecodeH265CapabilitiesKHR :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    maxLevelIdc: StdVideoH265LevelIdc;
}

VkVideoDecodeH265SessionParametersAddInfoKHR :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    stdVPSCount: u32;
    pStdVPSs:    *StdVideoH265VideoParameterSet;
    stdSPSCount: u32;
    pStdSPSs:    *StdVideoH265SequenceParameterSet;
    stdPPSCount: u32;
    pStdPPSs:    *StdVideoH265PictureParameterSet;
}

VkVideoDecodeH265SessionParametersCreateInfoKHR :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    maxStdVPSCount:     u32;
    maxStdSPSCount:     u32;
    maxStdPPSCount:     u32;
    pParametersAddInfo: *VkVideoDecodeH265SessionParametersAddInfoKHR;
}

VkVideoDecodeH265PictureInfoKHR :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    pStdPictureInfo:      *StdVideoDecodeH265PictureInfo;
    sliceSegmentCount:    u32;
    pSliceSegmentOffsets: *u32;
}

VkVideoDecodeH265DpbSlotInfoKHR :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    pStdReferenceInfo: *StdVideoDecodeH265ReferenceInfo;
}

VkQueueGlobalPriorityKHR :: enum s32 {
    LOW_KHR      :: 128;
    MEDIUM_KHR   :: 256;
    HIGH_KHR     :: 512;
    REALTIME_KHR :: 1024;
    LOW_EXT      :: 128;
    MEDIUM_EXT   :: 256;
    HIGH_EXT     :: 512;
    REALTIME_EXT :: 1024;
    MAX_ENUM_KHR :: 2147483647;
}

VkDeviceQueueGlobalPriorityCreateInfoKHR :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    globalPriority: VkQueueGlobalPriorityKHR;
}

VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    globalPriorityQuery: VkBool32;
}

VkQueueFamilyGlobalPriorityPropertiesKHR :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    priorityCount: u32;
    priorities:    [16] VkQueueGlobalPriorityKHR;
}

VkDriverIdKHR :: VkDriverId;

VkConformanceVersionKHR :: VkConformanceVersion;

VkPhysicalDeviceDriverPropertiesKHR :: VkPhysicalDeviceDriverProperties;

VkShaderFloatControlsIndependenceKHR :: VkShaderFloatControlsIndependence;

VkPhysicalDeviceFloatControlsPropertiesKHR :: VkPhysicalDeviceFloatControlsProperties;

VkResolveModeFlagBitsKHR :: VkResolveModeFlagBits;

VkResolveModeFlagsKHR :: VkResolveModeFlags;

VkSubpassDescriptionDepthStencilResolveKHR :: VkSubpassDescriptionDepthStencilResolve;

VkPhysicalDeviceDepthStencilResolvePropertiesKHR :: VkPhysicalDeviceDepthStencilResolveProperties;

VkSemaphoreTypeKHR :: VkSemaphoreType;

VkSemaphoreWaitFlagBitsKHR :: VkSemaphoreWaitFlagBits;

VkSemaphoreWaitFlagsKHR :: VkSemaphoreWaitFlags;

VkPhysicalDeviceTimelineSemaphoreFeaturesKHR :: VkPhysicalDeviceTimelineSemaphoreFeatures;

VkPhysicalDeviceTimelineSemaphorePropertiesKHR :: VkPhysicalDeviceTimelineSemaphoreProperties;

VkSemaphoreTypeCreateInfoKHR :: VkSemaphoreTypeCreateInfo;

VkTimelineSemaphoreSubmitInfoKHR :: VkTimelineSemaphoreSubmitInfo;

VkSemaphoreWaitInfoKHR :: VkSemaphoreWaitInfo;

VkSemaphoreSignalInfoKHR :: VkSemaphoreSignalInfo;

PFN_vkGetSemaphoreCounterValueKHR :: #type (device: VkDevice, semaphore: VkSemaphore, pValue: *u64) -> VkResult #c_call;
PFN_vkWaitSemaphoresKHR :: #type (device: VkDevice, pWaitInfo: *VkSemaphoreWaitInfo, timeout: u64) -> VkResult #c_call;
PFN_vkSignalSemaphoreKHR :: #type (device: VkDevice, pSignalInfo: *VkSemaphoreSignalInfo) -> VkResult #c_call;

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR :: VkPhysicalDeviceVulkanMemoryModelFeatures;

VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR :: VkPhysicalDeviceShaderTerminateInvocationFeatures;

VkFragmentShadingRateCombinerOpKHR :: enum s32 {
    KEEP_KHR     :: 0;
    REPLACE_KHR  :: 1;
    MIN_KHR      :: 2;
    MAX_KHR      :: 3;
    MUL_KHR      :: 4;
    MAX_ENUM_KHR :: 2147483647;
}

VkFragmentShadingRateAttachmentInfoKHR :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    pFragmentShadingRateAttachment: *VkAttachmentReference2;
    shadingRateAttachmentTexelSize: VkExtent2D;
}

VkPipelineFragmentShadingRateStateCreateInfoKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    fragmentSize: VkExtent2D;
    combinerOps:  [2] VkFragmentShadingRateCombinerOpKHR;
}

VkPhysicalDeviceFragmentShadingRateFeaturesKHR :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    pipelineFragmentShadingRate:   VkBool32;
    primitiveFragmentShadingRate:  VkBool32;
    attachmentFragmentShadingRate: VkBool32;
}

VkPhysicalDeviceFragmentShadingRatePropertiesKHR :: struct {
    sType:                                                VkStructureType;
    pNext:                                                *void;
    minFragmentShadingRateAttachmentTexelSize:            VkExtent2D;
    maxFragmentShadingRateAttachmentTexelSize:            VkExtent2D;
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32;
    primitiveFragmentShadingRateWithMultipleViewports:    VkBool32;
    layeredShadingRateAttachments:                        VkBool32;
    fragmentShadingRateNonTrivialCombinerOps:             VkBool32;
    maxFragmentSize:                                      VkExtent2D;
    maxFragmentSizeAspectRatio:                           u32;
    maxFragmentShadingRateCoverageSamples:                u32;
    maxFragmentShadingRateRasterizationSamples:           VkSampleCountFlagBits;
    fragmentShadingRateWithShaderDepthStencilWrites:      VkBool32;
    fragmentShadingRateWithSampleMask:                    VkBool32;
    fragmentShadingRateWithShaderSampleMask:              VkBool32;
    fragmentShadingRateWithConservativeRasterization:     VkBool32;
    fragmentShadingRateWithFragmentShaderInterlock:       VkBool32;
    fragmentShadingRateWithCustomSampleLocations:         VkBool32;
    fragmentShadingRateStrictMultiplyCombiner:            VkBool32;
}

VkPhysicalDeviceFragmentShadingRateKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    sampleCounts: VkSampleCountFlags;
    fragmentSize: VkExtent2D;
}

PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR :: #type (physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *u32, pFragmentShadingRates: *VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult #c_call;
PFN_vkCmdSetFragmentShadingRateKHR :: #type (commandBuffer: VkCommandBuffer, pFragmentSize: *VkExtent2D, combinerOps: *[2] VkFragmentShadingRateCombinerOpKHR) -> void #c_call;

VkSurfaceProtectedCapabilitiesKHR :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    supportsProtected: VkBool32;
}

VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR :: VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;

VkAttachmentReferenceStencilLayoutKHR :: VkAttachmentReferenceStencilLayout;

VkAttachmentDescriptionStencilLayoutKHR :: VkAttachmentDescriptionStencilLayout;

VkPhysicalDevicePresentWaitFeaturesKHR :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    presentWait: VkBool32;
}

PFN_vkWaitForPresentKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> VkResult #c_call;

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR :: VkPhysicalDeviceUniformBufferStandardLayoutFeatures;

VkPhysicalDeviceBufferDeviceAddressFeaturesKHR :: VkPhysicalDeviceBufferDeviceAddressFeatures;

VkBufferDeviceAddressInfoKHR :: VkBufferDeviceAddressInfo;

VkBufferOpaqueCaptureAddressCreateInfoKHR :: VkBufferOpaqueCaptureAddressCreateInfo;

VkMemoryOpaqueCaptureAddressAllocateInfoKHR :: VkMemoryOpaqueCaptureAddressAllocateInfo;

VkDeviceMemoryOpaqueCaptureAddressInfoKHR :: VkDeviceMemoryOpaqueCaptureAddressInfo;

PFN_vkGetBufferDeviceAddressKHR :: #type (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) -> VkDeviceAddress #c_call;
PFN_vkGetBufferOpaqueCaptureAddressKHR :: #type (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) -> u64 #c_call;
PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR :: #type (device: VkDevice, pInfo: *VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64 #c_call;

VkDeferredOperationKHR_T :: struct {}
VkDeferredOperationKHR :: *VkDeferredOperationKHR_T;

PFN_vkCreateDeferredOperationKHR :: #type (device: VkDevice, pAllocator: *VkAllocationCallbacks, pDeferredOperation: *VkDeferredOperationKHR) -> VkResult #c_call;
PFN_vkDestroyDeferredOperationKHR :: #type (device: VkDevice, operation: VkDeferredOperationKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetDeferredOperationMaxConcurrencyKHR :: #type (device: VkDevice, operation: VkDeferredOperationKHR) -> u32 #c_call;
PFN_vkGetDeferredOperationResultKHR :: #type (device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult #c_call;
PFN_vkDeferredOperationJoinKHR :: #type (device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult #c_call;

VkPipelineExecutableStatisticFormatKHR :: enum s32 {
    BOOL32_KHR   :: 0;
    INT64_KHR    :: 1;
    UINT64_KHR   :: 2;
    FLOAT64_KHR  :: 3;
    MAX_ENUM_KHR :: 2147483647;
}

VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    pipelineExecutableInfo: VkBool32;
}

VkPipelineInfoKHR :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    pipeline: VkPipeline;
}

VkPipelineExecutablePropertiesKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    stages:       VkShaderStageFlags;
    name:         [256] u8;
    description:  [256] u8;
    subgroupSize: u32;
}

VkPipelineExecutableInfoKHR :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    pipeline:        VkPipeline;
    executableIndex: u32;
}

VkPipelineExecutableStatisticValueKHR :: union {
    b32:  VkBool32;
    i64:  s64;
    _u64: u64;
    f64:  float64;
}

VkPipelineExecutableStatisticKHR :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    name:        [256] u8;
    description: [256] u8;
    format:      VkPipelineExecutableStatisticFormatKHR;
    value:       VkPipelineExecutableStatisticValueKHR;
}

VkPipelineExecutableInternalRepresentationKHR :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    name:        [256] u8;
    description: [256] u8;
    isText:      VkBool32;
    dataSize:    u64;
    pData:       *void;
}

PFN_vkGetPipelineExecutablePropertiesKHR :: #type (device: VkDevice, pPipelineInfo: *VkPipelineInfoKHR, pExecutableCount: *u32, pProperties: *VkPipelineExecutablePropertiesKHR) -> VkResult #c_call;
PFN_vkGetPipelineExecutableStatisticsKHR :: #type (device: VkDevice, pExecutableInfo: *VkPipelineExecutableInfoKHR, pStatisticCount: *u32, pStatistics: *VkPipelineExecutableStatisticKHR) -> VkResult #c_call;
PFN_vkGetPipelineExecutableInternalRepresentationsKHR :: #type (device: VkDevice, pExecutableInfo: *VkPipelineExecutableInfoKHR, pInternalRepresentationCount: *u32, pInternalRepresentations: *VkPipelineExecutableInternalRepresentationKHR) -> VkResult #c_call;

VkMemoryUnmapFlagsKHR :: VkFlags;
VkMemoryMapInfoKHR :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    flags:  VkMemoryMapFlags;
    memory: VkDeviceMemory;
    offset: VkDeviceSize;
    size:   VkDeviceSize;
}

VkMemoryUnmapInfoKHR :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    flags:  VkMemoryUnmapFlagsKHR;
    memory: VkDeviceMemory;
}

PFN_vkMapMemory2KHR :: #type (device: VkDevice, pMemoryMapInfo: *VkMemoryMapInfoKHR, ppData: **void) -> VkResult #c_call;
PFN_vkUnmapMemory2KHR :: #type (device: VkDevice, pMemoryUnmapInfo: *VkMemoryUnmapInfoKHR) -> VkResult #c_call;

VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR :: VkPhysicalDeviceShaderIntegerDotProductFeatures;

VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR :: VkPhysicalDeviceShaderIntegerDotProductProperties;

VkPipelineLibraryCreateInfoKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    libraryCount: u32;
    pLibraries:   *VkPipeline;
}

VkPresentIdKHR :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    swapchainCount: u32;
    pPresentIds:    *u64;
}

VkPhysicalDevicePresentIdFeaturesKHR :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    presentId: VkBool32;
}

VkPipelineStageFlags2KHR :: VkPipelineStageFlags2;

VkPipelineStageFlagBits2KHR :: VkPipelineStageFlagBits2;

VkAccessFlags2KHR :: VkAccessFlags2;

VkAccessFlagBits2KHR :: VkAccessFlagBits2;

VkSubmitFlagBitsKHR :: VkSubmitFlagBits;

VkSubmitFlagsKHR :: VkSubmitFlags;

VkMemoryBarrier2KHR :: VkMemoryBarrier2;

VkBufferMemoryBarrier2KHR :: VkBufferMemoryBarrier2;

VkImageMemoryBarrier2KHR :: VkImageMemoryBarrier2;

VkDependencyInfoKHR :: VkDependencyInfo;

VkSubmitInfo2KHR :: VkSubmitInfo2;

VkSemaphoreSubmitInfoKHR :: VkSemaphoreSubmitInfo;

VkCommandBufferSubmitInfoKHR :: VkCommandBufferSubmitInfo;

VkPhysicalDeviceSynchronization2FeaturesKHR :: VkPhysicalDeviceSynchronization2Features;

VkQueueFamilyCheckpointProperties2NV :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    checkpointExecutionStageMask: VkPipelineStageFlags2;
}

VkCheckpointData2NV :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    stage:             VkPipelineStageFlags2;
    pCheckpointMarker: *void;
}

PFN_vkCmdSetEvent2KHR :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdResetEvent2KHR :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) -> void #c_call;
PFN_vkCmdWaitEvents2KHR :: #type (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, pDependencyInfos: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdPipelineBarrier2KHR :: #type (commandBuffer: VkCommandBuffer, pDependencyInfo: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdWriteTimestamp2KHR :: #type (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) -> void #c_call;
PFN_vkQueueSubmit2KHR :: #type (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo2, fence: VkFence) -> VkResult #c_call;
PFN_vkCmdWriteBufferMarker2AMD :: #type (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) -> void #c_call;
PFN_vkGetQueueCheckpointData2NV :: #type (queue: VkQueue, pCheckpointDataCount: *u32, pCheckpointData: *VkCheckpointData2NV) -> void #c_call;

VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    fragmentShaderBarycentric: VkBool32;
}

VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR :: struct {
    sType:                                           VkStructureType;
    pNext:                                           *void;
    triStripVertexOrderIndependentOfProvokingVertex: VkBool32;
}

VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    shaderSubgroupUniformControlFlow: VkBool32;
}

VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR :: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;

VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR :: struct {
    sType:                                          VkStructureType;
    pNext:                                          *void;
    workgroupMemoryExplicitLayout:                  VkBool32;
    workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32;
    workgroupMemoryExplicitLayout8BitAccess:        VkBool32;
    workgroupMemoryExplicitLayout16BitAccess:       VkBool32;
}

VkCopyBufferInfo2KHR :: VkCopyBufferInfo2;

VkCopyImageInfo2KHR :: VkCopyImageInfo2;

VkCopyBufferToImageInfo2KHR :: VkCopyBufferToImageInfo2;

VkCopyImageToBufferInfo2KHR :: VkCopyImageToBufferInfo2;

VkBlitImageInfo2KHR :: VkBlitImageInfo2;

VkResolveImageInfo2KHR :: VkResolveImageInfo2;

VkBufferCopy2KHR :: VkBufferCopy2;

VkImageCopy2KHR :: VkImageCopy2;

VkImageBlit2KHR :: VkImageBlit2;

VkBufferImageCopy2KHR :: VkBufferImageCopy2;

VkImageResolve2KHR :: VkImageResolve2;

PFN_vkCmdCopyBuffer2KHR :: #type (commandBuffer: VkCommandBuffer, pCopyBufferInfo: *VkCopyBufferInfo2) -> void #c_call;
PFN_vkCmdCopyImage2KHR :: #type (commandBuffer: VkCommandBuffer, pCopyImageInfo: *VkCopyImageInfo2) -> void #c_call;
PFN_vkCmdCopyBufferToImage2KHR :: #type (commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *VkCopyBufferToImageInfo2) -> void #c_call;
PFN_vkCmdCopyImageToBuffer2KHR :: #type (commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *VkCopyImageToBufferInfo2) -> void #c_call;
PFN_vkCmdBlitImage2KHR :: #type (commandBuffer: VkCommandBuffer, pBlitImageInfo: *VkBlitImageInfo2) -> void #c_call;
PFN_vkCmdResolveImage2KHR :: #type (commandBuffer: VkCommandBuffer, pResolveImageInfo: *VkResolveImageInfo2) -> void #c_call;

VkFormatFeatureFlags2KHR :: VkFormatFeatureFlags2;

VkFormatFeatureFlagBits2KHR :: VkFormatFeatureFlagBits2;

VkFormatProperties3KHR :: VkFormatProperties3;

VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR :: struct {
    sType:                                VkStructureType;
    pNext:                                *void;
    rayTracingMaintenance1:               VkBool32;
    rayTracingPipelineTraceRaysIndirect2: VkBool32;
}

VkTraceRaysIndirectCommand2KHR :: struct {
    raygenShaderRecordAddress:         VkDeviceAddress;
    raygenShaderRecordSize:            VkDeviceSize;
    missShaderBindingTableAddress:     VkDeviceAddress;
    missShaderBindingTableSize:        VkDeviceSize;
    missShaderBindingTableStride:      VkDeviceSize;
    hitShaderBindingTableAddress:      VkDeviceAddress;
    hitShaderBindingTableSize:         VkDeviceSize;
    hitShaderBindingTableStride:       VkDeviceSize;
    callableShaderBindingTableAddress: VkDeviceAddress;
    callableShaderBindingTableSize:    VkDeviceSize;
    callableShaderBindingTableStride:  VkDeviceSize;
    width:                             u32;
    height:                            u32;
    depth:                             u32;
}

PFN_vkCmdTraceRaysIndirect2KHR :: #type (commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) -> void #c_call;

VkPhysicalDeviceMaintenance4FeaturesKHR :: VkPhysicalDeviceMaintenance4Features;

VkPhysicalDeviceMaintenance4PropertiesKHR :: VkPhysicalDeviceMaintenance4Properties;

VkDeviceBufferMemoryRequirementsKHR :: VkDeviceBufferMemoryRequirements;

VkDeviceImageMemoryRequirementsKHR :: VkDeviceImageMemoryRequirements;

PFN_vkGetDeviceBufferMemoryRequirementsKHR :: #type (device: VkDevice, pInfo: *VkDeviceBufferMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetDeviceImageMemoryRequirementsKHR :: #type (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetDeviceImageSparseMemoryRequirementsKHR :: #type (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) -> void #c_call;

VkPipelineCreateFlags2KHR :: VkFlags64;

// Flag bits for VkPipelineCreateFlagBits2KHR
VkPipelineCreateFlagBits2KHR :: VkFlags64;
VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR: VkPipelineCreateFlagBits2KHR : 1;
VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR: VkPipelineCreateFlagBits2KHR : 2;
VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR: VkPipelineCreateFlagBits2KHR : 4;
VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR: VkPipelineCreateFlagBits2KHR : 8;
VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR: VkPipelineCreateFlagBits2KHR : 16;
VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV: VkPipelineCreateFlagBits2KHR : 32;
VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR: VkPipelineCreateFlagBits2KHR : 64;
VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: VkPipelineCreateFlagBits2KHR : 128;
VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR: VkPipelineCreateFlagBits2KHR : 256;
VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR: VkPipelineCreateFlagBits2KHR : 512;
VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT: VkPipelineCreateFlagBits2KHR : 1024;
VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT: VkPipelineCreateFlagBits2KHR : 8388608;
VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR: VkPipelineCreateFlagBits2KHR : 2048;
VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR: VkPipelineCreateFlagBits2KHR : 4096;
VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR: VkPipelineCreateFlagBits2KHR : 8192;
VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR: VkPipelineCreateFlagBits2KHR : 16384;
VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR: VkPipelineCreateFlagBits2KHR : 32768;
VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR: VkPipelineCreateFlagBits2KHR : 65536;
VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR: VkPipelineCreateFlagBits2KHR : 131072;
VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR: VkPipelineCreateFlagBits2KHR : 524288;
VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV: VkPipelineCreateFlagBits2KHR : 262144;
VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV: VkPipelineCreateFlagBits2KHR : 1048576;
VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkPipelineCreateFlagBits2KHR : 2097152;
VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: VkPipelineCreateFlagBits2KHR : 4194304;
VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT: VkPipelineCreateFlagBits2KHR : 16777216;
VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: VkPipelineCreateFlagBits2KHR : 33554432;
VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: VkPipelineCreateFlagBits2KHR : 67108864;
VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT: VkPipelineCreateFlagBits2KHR : 134217728;
VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT: VkPipelineCreateFlagBits2KHR : 1073741824;
VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV: VkPipelineCreateFlagBits2KHR : 268435456;
VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT: VkPipelineCreateFlagBits2KHR : 536870912;

VkBufferUsageFlags2KHR :: VkFlags64;

// Flag bits for VkBufferUsageFlagBits2KHR
VkBufferUsageFlagBits2KHR :: VkFlags64;
VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR: VkBufferUsageFlagBits2KHR : 1;
VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR: VkBufferUsageFlagBits2KHR : 2;
VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR: VkBufferUsageFlagBits2KHR : 4;
VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR: VkBufferUsageFlagBits2KHR : 8;
VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR: VkBufferUsageFlagBits2KHR : 16;
VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR: VkBufferUsageFlagBits2KHR : 32;
VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR: VkBufferUsageFlagBits2KHR : 64;
VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR: VkBufferUsageFlagBits2KHR : 128;
VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR: VkBufferUsageFlagBits2KHR : 256;
VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX: VkBufferUsageFlagBits2KHR : 33554432;
VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT: VkBufferUsageFlagBits2KHR : 512;
VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR: VkBufferUsageFlagBits2KHR : 1024;
VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV: VkBufferUsageFlagBits2KHR : 1024;
VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: VkBufferUsageFlagBits2KHR : 2048;
VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: VkBufferUsageFlagBits2KHR : 4096;
VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR: VkBufferUsageFlagBits2KHR : 8192;
VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR: VkBufferUsageFlagBits2KHR : 16384;

VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR: VkBufferUsageFlagBits2KHR : 131072;
VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR: VkBufferUsageFlagBits2KHR : 524288;
VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR: VkBufferUsageFlagBits2KHR : 1048576;
VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT: VkBufferUsageFlagBits2KHR : 2097152;
VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT: VkBufferUsageFlagBits2KHR : 4194304;
VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT: VkBufferUsageFlagBits2KHR : 67108864;
VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT: VkBufferUsageFlagBits2KHR : 8388608;
VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT: VkBufferUsageFlagBits2KHR : 16777216;

VkPhysicalDeviceMaintenance5FeaturesKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    maintenance5: VkBool32;
}

VkPhysicalDeviceMaintenance5PropertiesKHR :: struct {
    sType:                                               VkStructureType;
    pNext:                                               *void;
    earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32;
    earlyFragmentSampleMaskTestBeforeSampleCounting:     VkBool32;
    depthStencilSwizzleOneSupport:                       VkBool32;
    polygonModePointSize:                                VkBool32;
    nonStrictSinglePixelWideLinesUseParallelogram:       VkBool32;
    nonStrictWideLinesUseParallelogram:                  VkBool32;
}

VkRenderingAreaInfoKHR :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    viewMask:                u32;
    colorAttachmentCount:    u32;
    pColorAttachmentFormats: *VkFormat;
    depthAttachmentFormat:   VkFormat;
    stencilAttachmentFormat: VkFormat;
}

VkImageSubresource2KHR :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    imageSubresource: VkImageSubresource;
}

VkDeviceImageSubresourceInfoKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    pCreateInfo:  *VkImageCreateInfo;
    pSubresource: *VkImageSubresource2KHR;
}

VkSubresourceLayout2KHR :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    subresourceLayout: VkSubresourceLayout;
}

VkPipelineCreateFlags2CreateInfoKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkPipelineCreateFlags2KHR;
}

VkBufferUsageFlags2CreateInfoKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    usage: VkBufferUsageFlags2KHR;
}

PFN_vkCmdBindIndexBuffer2KHR :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) -> void #c_call;
PFN_vkGetRenderingAreaGranularityKHR :: #type (device: VkDevice, pRenderingAreaInfo: *VkRenderingAreaInfoKHR, pGranularity: *VkExtent2D) -> void #c_call;
PFN_vkGetDeviceImageSubresourceLayoutKHR :: #type (device: VkDevice, pInfo: *VkDeviceImageSubresourceInfoKHR, pLayout: *VkSubresourceLayout2KHR) -> void #c_call;
PFN_vkGetImageSubresourceLayout2KHR :: #type (device: VkDevice, image: VkImage, pSubresource: *VkImageSubresource2KHR, pLayout: *VkSubresourceLayout2KHR) -> void #c_call;

VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    rayTracingPositionFetch: VkBool32;
}

VkComponentTypeKHR :: enum s32 {
    FLOAT16_KHR  :: 0;
    FLOAT32_KHR  :: 1;
    FLOAT64_KHR  :: 2;
    SINT8_KHR    :: 3;
    SINT16_KHR   :: 4;
    SINT32_KHR   :: 5;
    SINT64_KHR   :: 6;
    UINT8_KHR    :: 7;
    UINT16_KHR   :: 8;
    UINT32_KHR   :: 9;
    UINT64_KHR   :: 10;
    FLOAT16_NV   :: 0;
    FLOAT32_NV   :: 1;
    FLOAT64_NV   :: 2;
    SINT8_NV     :: 3;
    SINT16_NV    :: 4;
    SINT32_NV    :: 5;
    SINT64_NV    :: 6;
    UINT8_NV     :: 7;
    UINT16_NV    :: 8;
    UINT32_NV    :: 9;
    UINT64_NV    :: 10;
    MAX_ENUM_KHR :: 2147483647;
}

VkScopeKHR :: enum s32 {
    DEVICE_KHR       :: 1;
    WORKGROUP_KHR    :: 2;
    SUBGROUP_KHR     :: 3;
    QUEUE_FAMILY_KHR :: 5;
    DEVICE_NV        :: 1;
    WORKGROUP_NV     :: 2;
    SUBGROUP_NV      :: 3;
    QUEUE_FAMILY_NV  :: 5;
    MAX_ENUM_KHR     :: 2147483647;
}

VkCooperativeMatrixPropertiesKHR :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    MSize:                  u32;
    NSize:                  u32;
    KSize:                  u32;
    AType:                  VkComponentTypeKHR;
    BType:                  VkComponentTypeKHR;
    CType:                  VkComponentTypeKHR;
    ResultType:             VkComponentTypeKHR;
    saturatingAccumulation: VkBool32;
    scope:                  VkScopeKHR;
}

VkPhysicalDeviceCooperativeMatrixFeaturesKHR :: struct {
    sType:                               VkStructureType;
    pNext:                               *void;
    cooperativeMatrix:                   VkBool32;
    cooperativeMatrixRobustBufferAccess: VkBool32;
}

VkPhysicalDeviceCooperativeMatrixPropertiesKHR :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    cooperativeMatrixSupportedStages: VkShaderStageFlags;
}

PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkCooperativeMatrixPropertiesKHR) -> VkResult #c_call;

VkDebugReportCallbackEXT_T :: struct {}
VkDebugReportCallbackEXT :: *VkDebugReportCallbackEXT_T;

VkDebugReportObjectTypeEXT :: enum s32 {
    UNKNOWN_EXT                        :: 0;
    INSTANCE_EXT                       :: 1;
    PHYSICAL_DEVICE_EXT                :: 2;
    DEVICE_EXT                         :: 3;
    QUEUE_EXT                          :: 4;
    SEMAPHORE_EXT                      :: 5;
    COMMAND_BUFFER_EXT                 :: 6;
    FENCE_EXT                          :: 7;
    DEVICE_MEMORY_EXT                  :: 8;
    BUFFER_EXT                         :: 9;
    IMAGE_EXT                          :: 10;
    EVENT_EXT                          :: 11;
    QUERY_POOL_EXT                     :: 12;
    BUFFER_VIEW_EXT                    :: 13;
    IMAGE_VIEW_EXT                     :: 14;
    SHADER_MODULE_EXT                  :: 15;
    PIPELINE_CACHE_EXT                 :: 16;
    PIPELINE_LAYOUT_EXT                :: 17;
    RENDER_PASS_EXT                    :: 18;
    PIPELINE_EXT                       :: 19;
    DESCRIPTOR_SET_LAYOUT_EXT          :: 20;
    SAMPLER_EXT                        :: 21;
    DESCRIPTOR_POOL_EXT                :: 22;
    DESCRIPTOR_SET_EXT                 :: 23;
    FRAMEBUFFER_EXT                    :: 24;
    COMMAND_POOL_EXT                   :: 25;
    SURFACE_KHR_EXT                    :: 26;
    SWAPCHAIN_KHR_EXT                  :: 27;
    DEBUG_REPORT_CALLBACK_EXT_EXT      :: 28;
    DISPLAY_KHR_EXT                    :: 29;
    DISPLAY_MODE_KHR_EXT               :: 30;
    VALIDATION_CACHE_EXT_EXT           :: 33;
    SAMPLER_YCBCR_CONVERSION_EXT       :: 1000156000;
    DESCRIPTOR_UPDATE_TEMPLATE_EXT     :: 1000085000;
    CU_MODULE_NVX_EXT                  :: 1000029000;
    CU_FUNCTION_NVX_EXT                :: 1000029001;
    ACCELERATION_STRUCTURE_KHR_EXT     :: 1000150000;
    ACCELERATION_STRUCTURE_NV_EXT      :: 1000165000;
    BUFFER_COLLECTION_FUCHSIA_EXT      :: 1000366000;
    DEBUG_REPORT_EXT                   :: 28;
    VALIDATION_CACHE_EXT               :: 33;
    DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT :: 1000085000;
    SAMPLER_YCBCR_CONVERSION_KHR_EXT   :: 1000156000;
    MAX_ENUM_EXT                       :: 2147483647;
}

VkDebugReportFlagBitsEXT :: enum s32 {
    INFORMATION_BIT_EXT         :: 1;
    WARNING_BIT_EXT             :: 2;
    PERFORMANCE_WARNING_BIT_EXT :: 4;
    ERROR_BIT_EXT               :: 8;
    DEBUG_BIT_EXT               :: 16;
    FLAG_BITS_MAX_ENUM_EXT      :: 2147483647;
}

VkDebugReportFlagsEXT :: VkFlags;
PFN_vkDebugReportCallbackEXT :: #type (flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: u64, messageCode: s32, pLayerPrefix: *u8, pMessage: *u8, pUserData: *void) -> VkBool32 #c_call;

VkDebugReportCallbackCreateInfoEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    flags:       VkDebugReportFlagsEXT;
    pfnCallback: PFN_vkDebugReportCallbackEXT;
    pUserData:   *void;
}

PFN_vkCreateDebugReportCallbackEXT :: #type (instance: VkInstance, pCreateInfo: *VkDebugReportCallbackCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pCallback: *VkDebugReportCallbackEXT) -> VkResult #c_call;
PFN_vkDestroyDebugReportCallbackEXT :: #type (instance: VkInstance, callback: VkDebugReportCallbackEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDebugReportMessageEXT :: #type (instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: u64, messageCode: s32, pLayerPrefix: *u8, pMessage: *u8) -> void #c_call;

VkRasterizationOrderAMD :: enum s32 {
    STRICT_AMD   :: 0;
    RELAXED_AMD  :: 1;
    MAX_ENUM_AMD :: 2147483647;
}

VkPipelineRasterizationStateRasterizationOrderAMD :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    rasterizationOrder: VkRasterizationOrderAMD;
}

VkDebugMarkerObjectNameInfoEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    objectType:  VkDebugReportObjectTypeEXT;
    object:      u64;
    pObjectName: *u8;
}

VkDebugMarkerObjectTagInfoEXT :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    objectType: VkDebugReportObjectTypeEXT;
    object:     u64;
    tagName:    u64;
    tagSize:    u64;
    pTag:       *void;
}

VkDebugMarkerMarkerInfoEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    pMarkerName: *u8;
    color:       [4] float;
}

PFN_vkDebugMarkerSetObjectTagEXT :: #type (device: VkDevice, pTagInfo: *VkDebugMarkerObjectTagInfoEXT) -> VkResult #c_call;
PFN_vkDebugMarkerSetObjectNameEXT :: #type (device: VkDevice, pNameInfo: *VkDebugMarkerObjectNameInfoEXT) -> VkResult #c_call;
PFN_vkCmdDebugMarkerBeginEXT :: #type (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkDebugMarkerMarkerInfoEXT) -> void #c_call;
PFN_vkCmdDebugMarkerEndEXT :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdDebugMarkerInsertEXT :: #type (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkDebugMarkerMarkerInfoEXT) -> void #c_call;

VkDedicatedAllocationImageCreateInfoNV :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    dedicatedAllocation: VkBool32;
}

VkDedicatedAllocationBufferCreateInfoNV :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    dedicatedAllocation: VkBool32;
}

VkDedicatedAllocationMemoryAllocateInfoNV :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    image:  VkImage;
    buffer: VkBuffer;
}

VkPipelineRasterizationStateStreamCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceTransformFeedbackFeaturesEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    transformFeedback: VkBool32;
    geometryStreams:   VkBool32;
}

VkPhysicalDeviceTransformFeedbackPropertiesEXT :: struct {
    sType:                                      VkStructureType;
    pNext:                                      *void;
    maxTransformFeedbackStreams:                u32;
    maxTransformFeedbackBuffers:                u32;
    maxTransformFeedbackBufferSize:             VkDeviceSize;
    maxTransformFeedbackStreamDataSize:         u32;
    maxTransformFeedbackBufferDataSize:         u32;
    maxTransformFeedbackBufferDataStride:       u32;
    transformFeedbackQueries:                   VkBool32;
    transformFeedbackStreamsLinesTriangles:     VkBool32;
    transformFeedbackRasterizationStreamSelect: VkBool32;
    transformFeedbackDraw:                      VkBool32;
}

VkPipelineRasterizationStateStreamCreateInfoEXT :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    flags:               VkPipelineRasterizationStateStreamCreateFlagsEXT;
    rasterizationStream: u32;
}

PFN_vkCmdBindTransformFeedbackBuffersEXT :: #type (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize) -> void #c_call;
PFN_vkCmdBeginTransformFeedbackEXT :: #type (commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *VkBuffer, pCounterBufferOffsets: *VkDeviceSize) -> void #c_call;
PFN_vkCmdEndTransformFeedbackEXT :: #type (commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *VkBuffer, pCounterBufferOffsets: *VkDeviceSize) -> void #c_call;
PFN_vkCmdBeginQueryIndexedEXT :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags, index: u32) -> void #c_call;
PFN_vkCmdEndQueryIndexedEXT :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, index: u32) -> void #c_call;
PFN_vkCmdDrawIndirectByteCountEXT :: #type (commandBuffer: VkCommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: VkBuffer, counterBufferOffset: VkDeviceSize, counterOffset: u32, vertexStride: u32) -> void #c_call;

VkCuModuleNVX_T :: struct {}
VkCuModuleNVX :: *VkCuModuleNVX_T;
VkCuFunctionNVX_T :: struct {}
VkCuFunctionNVX :: *VkCuFunctionNVX_T;

VkCuModuleCreateInfoNVX :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    dataSize: u64;
    pData:    *void;
}

VkCuFunctionCreateInfoNVX :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    module: VkCuModuleNVX;
    pName:  *u8;
}

VkCuLaunchInfoNVX :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    function:       VkCuFunctionNVX;
    gridDimX:       u32;
    gridDimY:       u32;
    gridDimZ:       u32;
    blockDimX:      u32;
    blockDimY:      u32;
    blockDimZ:      u32;
    sharedMemBytes: u32;
    paramCount:     u64;
    pParams:        **void;
    extraCount:     u64;
    pExtras:        **void;
}

PFN_vkCreateCuModuleNVX :: #type (device: VkDevice, pCreateInfo: *VkCuModuleCreateInfoNVX, pAllocator: *VkAllocationCallbacks, pModule: *VkCuModuleNVX) -> VkResult #c_call;
PFN_vkCreateCuFunctionNVX :: #type (device: VkDevice, pCreateInfo: *VkCuFunctionCreateInfoNVX, pAllocator: *VkAllocationCallbacks, pFunction: *VkCuFunctionNVX) -> VkResult #c_call;
PFN_vkDestroyCuModuleNVX :: #type (device: VkDevice, module: VkCuModuleNVX, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDestroyCuFunctionNVX :: #type (device: VkDevice, function: VkCuFunctionNVX, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCmdCuLaunchKernelNVX :: #type (commandBuffer: VkCommandBuffer, pLaunchInfo: *VkCuLaunchInfoNVX) -> void #c_call;

VkImageViewHandleInfoNVX :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    imageView:      VkImageView;
    descriptorType: VkDescriptorType;
    sampler:        VkSampler;
}

VkImageViewAddressPropertiesNVX :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    deviceAddress: VkDeviceAddress;
    size:          VkDeviceSize;
}

PFN_vkGetImageViewHandleNVX :: #type (device: VkDevice, pInfo: *VkImageViewHandleInfoNVX) -> u32 #c_call;
PFN_vkGetImageViewAddressNVX :: #type (device: VkDevice, imageView: VkImageView, pProperties: *VkImageViewAddressPropertiesNVX) -> VkResult #c_call;

PFN_vkCmdDrawIndirectCountAMD :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawIndexedIndirectCountAMD :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;

VkTextureLODGatherFormatPropertiesAMD :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    supportsTextureGatherLODBiasAMD: VkBool32;
}

VkShaderInfoTypeAMD :: enum s32 {
    STATISTICS_AMD  :: 0;
    BINARY_AMD      :: 1;
    DISASSEMBLY_AMD :: 2;
    MAX_ENUM_AMD    :: 2147483647;
}

VkShaderResourceUsageAMD :: struct {
    numUsedVgprs:             u32;
    numUsedSgprs:             u32;
    ldsSizePerLocalWorkGroup: u32;
    ldsUsageSizeInBytes:      u64;
    scratchMemUsageInBytes:   u64;
}

VkShaderStatisticsInfoAMD :: struct {
    shaderStageMask:      VkShaderStageFlags;
    resourceUsage:        VkShaderResourceUsageAMD;
    numPhysicalVgprs:     u32;
    numPhysicalSgprs:     u32;
    numAvailableVgprs:    u32;
    numAvailableSgprs:    u32;
    computeWorkGroupSize: [3] u32;
}

PFN_vkGetShaderInfoAMD :: #type (device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *u64, pInfo: *void) -> VkResult #c_call;

VkPhysicalDeviceCornerSampledImageFeaturesNV :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    cornerSampledImage: VkBool32;
}

VkExternalMemoryHandleTypeFlagBitsNV :: enum s32 {
    OPAQUE_WIN32_BIT_NV     :: 1;
    OPAQUE_WIN32_KMT_BIT_NV :: 2;
    D3D11_IMAGE_BIT_NV      :: 4;
    D3D11_IMAGE_KMT_BIT_NV  :: 8;
    FLAG_BITS_MAX_ENUM_NV   :: 2147483647;
}

VkExternalMemoryHandleTypeFlagsNV :: VkFlags;

VkExternalMemoryFeatureFlagBitsNV :: enum s32 {
    DEDICATED_ONLY_BIT_NV :: 1;
    EXPORTABLE_BIT_NV     :: 2;
    IMPORTABLE_BIT_NV     :: 4;
    FLAG_BITS_MAX_ENUM_NV :: 2147483647;
}

VkExternalMemoryFeatureFlagsNV :: VkFlags;
VkExternalImageFormatPropertiesNV :: struct {
    imageFormatProperties:         VkImageFormatProperties;
    externalMemoryFeatures:        VkExternalMemoryFeatureFlagsNV;
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV;
    compatibleHandleTypes:         VkExternalMemoryHandleTypeFlagsNV;
}

PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *VkExternalImageFormatPropertiesNV) -> VkResult #c_call;

VkExternalMemoryImageCreateInfoNV :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    handleTypes: VkExternalMemoryHandleTypeFlagsNV;
}

VkExportMemoryAllocateInfoNV :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    handleTypes: VkExternalMemoryHandleTypeFlagsNV;
}

VkValidationCheckEXT :: enum s32 {
    ALL_EXT      :: 0;
    SHADERS_EXT  :: 1;
    MAX_ENUM_EXT :: 2147483647;
}

VkValidationFlagsEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    disabledValidationCheckCount: u32;
    pDisabledValidationChecks:    *VkValidationCheckEXT;
}

VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT :: VkPhysicalDeviceTextureCompressionASTCHDRFeatures;

VkImageViewASTCDecodeModeEXT :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    decodeMode: VkFormat;
}

VkPhysicalDeviceASTCDecodeFeaturesEXT :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    decodeModeSharedExponent: VkBool32;
}

VkPipelineRobustnessBufferBehaviorEXT :: enum s32 {
    DEVICE_DEFAULT_EXT         :: 0;
    DISABLED_EXT               :: 1;
    ROBUST_BUFFER_ACCESS_EXT   :: 2;
    ROBUST_BUFFER_ACCESS_2_EXT :: 3;
    MAX_ENUM_EXT               :: 2147483647;
}

VkPipelineRobustnessImageBehaviorEXT :: enum s32 {
    DEVICE_DEFAULT_EXT        :: 0;
    DISABLED_EXT              :: 1;
    ROBUST_IMAGE_ACCESS_EXT   :: 2;
    ROBUST_IMAGE_ACCESS_2_EXT :: 3;
    MAX_ENUM_EXT              :: 2147483647;
}

VkPhysicalDevicePipelineRobustnessFeaturesEXT :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    pipelineRobustness: VkBool32;
}

VkPhysicalDevicePipelineRobustnessPropertiesEXT :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehaviorEXT;
    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehaviorEXT;
    defaultRobustnessVertexInputs:   VkPipelineRobustnessBufferBehaviorEXT;
    defaultRobustnessImages:         VkPipelineRobustnessImageBehaviorEXT;
}

VkPipelineRobustnessCreateInfoEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    storageBuffers: VkPipelineRobustnessBufferBehaviorEXT;
    uniformBuffers: VkPipelineRobustnessBufferBehaviorEXT;
    vertexInputs:   VkPipelineRobustnessBufferBehaviorEXT;
    images:         VkPipelineRobustnessImageBehaviorEXT;
}

VkConditionalRenderingFlagBitsEXT :: enum s32 {
    INVERTED_BIT_EXT       :: 1;
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647;
}

VkConditionalRenderingFlagsEXT :: VkFlags;
VkConditionalRenderingBeginInfoEXT :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    buffer: VkBuffer;
    offset: VkDeviceSize;
    flags:  VkConditionalRenderingFlagsEXT;
}

VkPhysicalDeviceConditionalRenderingFeaturesEXT :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    conditionalRendering:          VkBool32;
    inheritedConditionalRendering: VkBool32;
}

VkCommandBufferInheritanceConditionalRenderingInfoEXT :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    conditionalRenderingEnable: VkBool32;
}

PFN_vkCmdBeginConditionalRenderingEXT :: #type (commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *VkConditionalRenderingBeginInfoEXT) -> void #c_call;
PFN_vkCmdEndConditionalRenderingEXT :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;

VkViewportWScalingNV :: struct {
    xcoeff: float;
    ycoeff: float;
}

VkPipelineViewportWScalingStateCreateInfoNV :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    viewportWScalingEnable: VkBool32;
    viewportCount:          u32;
    pViewportWScalings:     *VkViewportWScalingNV;
}

PFN_vkCmdSetViewportWScalingNV :: #type (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *VkViewportWScalingNV) -> void #c_call;

PFN_vkReleaseDisplayEXT :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult #c_call;

VkSurfaceCounterFlagBitsEXT :: enum s32 {
    VBLANK_BIT_EXT         :: 1;
    VBLANK_EXT             :: 1;
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647;
}

VkSurfaceCounterFlagsEXT :: VkFlags;
VkSurfaceCapabilities2EXT :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    minImageCount:            u32;
    maxImageCount:            u32;
    currentExtent:            VkExtent2D;
    minImageExtent:           VkExtent2D;
    maxImageExtent:           VkExtent2D;
    maxImageArrayLayers:      u32;
    supportedTransforms:      VkSurfaceTransformFlagsKHR;
    currentTransform:         VkSurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha:  VkCompositeAlphaFlagsKHR;
    supportedUsageFlags:      VkImageUsageFlags;
    supportedSurfaceCounters: VkSurfaceCounterFlagsEXT;
}

PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *VkSurfaceCapabilities2EXT) -> VkResult #c_call;

VkDisplayPowerStateEXT :: enum s32 {
    OFF_EXT      :: 0;
    SUSPEND_EXT  :: 1;
    ON_EXT       :: 2;
    MAX_ENUM_EXT :: 2147483647;
}

VkDeviceEventTypeEXT :: enum s32 {
    DISPLAY_HOTPLUG_EXT :: 0;
    MAX_ENUM_EXT        :: 2147483647;
}

VkDisplayEventTypeEXT :: enum s32 {
    FIRST_PIXEL_OUT_EXT :: 0;
    MAX_ENUM_EXT        :: 2147483647;
}

VkDisplayPowerInfoEXT :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    powerState: VkDisplayPowerStateEXT;
}

VkDeviceEventInfoEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    deviceEvent: VkDeviceEventTypeEXT;
}

VkDisplayEventInfoEXT :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    displayEvent: VkDisplayEventTypeEXT;
}

VkSwapchainCounterCreateInfoEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    surfaceCounters: VkSurfaceCounterFlagsEXT;
}

PFN_vkDisplayPowerControlEXT :: #type (device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *VkDisplayPowerInfoEXT) -> VkResult #c_call;
PFN_vkRegisterDeviceEventEXT :: #type (device: VkDevice, pDeviceEventInfo: *VkDeviceEventInfoEXT, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) -> VkResult #c_call;
PFN_vkRegisterDisplayEventEXT :: #type (device: VkDevice, display: VkDisplayKHR, pDisplayEventInfo: *VkDisplayEventInfoEXT, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) -> VkResult #c_call;
PFN_vkGetSwapchainCounterEXT :: #type (device: VkDevice, swapchain: VkSwapchainKHR, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: *u64) -> VkResult #c_call;

VkRefreshCycleDurationGOOGLE :: struct {
    refreshDuration: u64;
}

VkPastPresentationTimingGOOGLE :: struct {
    presentID:           u32;
    desiredPresentTime:  u64;
    actualPresentTime:   u64;
    earliestPresentTime: u64;
    presentMargin:       u64;
}

VkPresentTimeGOOGLE :: struct {
    presentID:          u32;
    desiredPresentTime: u64;
}

VkPresentTimesInfoGOOGLE :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    swapchainCount: u32;
    pTimes:         *VkPresentTimeGOOGLE;
}

PFN_vkGetRefreshCycleDurationGOOGLE :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *VkRefreshCycleDurationGOOGLE) -> VkResult #c_call;
PFN_vkGetPastPresentationTimingGOOGLE :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pPresentationTimingCount: *u32, pPresentationTimings: *VkPastPresentationTimingGOOGLE) -> VkResult #c_call;

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    perViewPositionAllComponents: VkBool32;
}

VkViewportCoordinateSwizzleNV :: enum s32 {
    POSITIVE_X_NV :: 0;
    NEGATIVE_X_NV :: 1;
    POSITIVE_Y_NV :: 2;
    NEGATIVE_Y_NV :: 3;
    POSITIVE_Z_NV :: 4;
    NEGATIVE_Z_NV :: 5;
    POSITIVE_W_NV :: 6;
    NEGATIVE_W_NV :: 7;
    MAX_ENUM_NV   :: 2147483647;
}

VkPipelineViewportSwizzleStateCreateFlagsNV :: VkFlags;
VkViewportSwizzleNV :: struct {
    x: VkViewportCoordinateSwizzleNV;
    y: VkViewportCoordinateSwizzleNV;
    z: VkViewportCoordinateSwizzleNV;
    w: VkViewportCoordinateSwizzleNV;
}

VkPipelineViewportSwizzleStateCreateInfoNV :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    flags:             VkPipelineViewportSwizzleStateCreateFlagsNV;
    viewportCount:     u32;
    pViewportSwizzles: *VkViewportSwizzleNV;
}

VkDiscardRectangleModeEXT :: enum s32 {
    INCLUSIVE_EXT :: 0;
    EXCLUSIVE_EXT :: 1;
    MAX_ENUM_EXT  :: 2147483647;
}

VkPipelineDiscardRectangleStateCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceDiscardRectanglePropertiesEXT :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    maxDiscardRectangles: u32;
}

VkPipelineDiscardRectangleStateCreateInfoEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    flags:                 VkPipelineDiscardRectangleStateCreateFlagsEXT;
    discardRectangleMode:  VkDiscardRectangleModeEXT;
    discardRectangleCount: u32;
    pDiscardRectangles:    *VkRect2D;
}

PFN_vkCmdSetDiscardRectangleEXT :: #type (commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *VkRect2D) -> void #c_call;
PFN_vkCmdSetDiscardRectangleEnableEXT :: #type (commandBuffer: VkCommandBuffer, discardRectangleEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDiscardRectangleModeEXT :: #type (commandBuffer: VkCommandBuffer, discardRectangleMode: VkDiscardRectangleModeEXT) -> void #c_call;

VkConservativeRasterizationModeEXT :: enum s32 {
    DISABLED_EXT      :: 0;
    OVERESTIMATE_EXT  :: 1;
    UNDERESTIMATE_EXT :: 2;
    MAX_ENUM_EXT      :: 2147483647;
}

VkPipelineRasterizationConservativeStateCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceConservativeRasterizationPropertiesEXT :: struct {
    sType:                                       VkStructureType;
    pNext:                                       *void;
    primitiveOverestimationSize:                 float;
    maxExtraPrimitiveOverestimationSize:         float;
    extraPrimitiveOverestimationSizeGranularity: float;
    primitiveUnderestimation:                    VkBool32;
    conservativePointAndLineRasterization:       VkBool32;
    degenerateTrianglesRasterized:               VkBool32;
    degenerateLinesRasterized:                   VkBool32;
    fullyCoveredFragmentShaderInputVariable:     VkBool32;
    conservativeRasterizationPostDepthCoverage:  VkBool32;
}

VkPipelineRasterizationConservativeStateCreateInfoEXT :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    flags:                            VkPipelineRasterizationConservativeStateCreateFlagsEXT;
    conservativeRasterizationMode:    VkConservativeRasterizationModeEXT;
    extraPrimitiveOverestimationSize: float;
}

VkPipelineRasterizationDepthClipStateCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceDepthClipEnableFeaturesEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    depthClipEnable: VkBool32;
}

VkPipelineRasterizationDepthClipStateCreateInfoEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkPipelineRasterizationDepthClipStateCreateFlagsEXT;
    depthClipEnable: VkBool32;
}

VkXYColorEXT :: struct {
    x: float;
    y: float;
}

VkHdrMetadataEXT :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    displayPrimaryRed:         VkXYColorEXT;
    displayPrimaryGreen:       VkXYColorEXT;
    displayPrimaryBlue:        VkXYColorEXT;
    whitePoint:                VkXYColorEXT;
    maxLuminance:              float;
    minLuminance:              float;
    maxContentLightLevel:      float;
    maxFrameAverageLightLevel: float;
}

PFN_vkSetHdrMetadataEXT :: #type (device: VkDevice, swapchainCount: u32, pSwapchains: *VkSwapchainKHR, pMetadata: *VkHdrMetadataEXT) -> void #c_call;

VkDebugUtilsMessengerEXT_T :: struct {}
VkDebugUtilsMessengerEXT :: *VkDebugUtilsMessengerEXT_T;

VkDebugUtilsMessengerCallbackDataFlagsEXT :: VkFlags;

VkDebugUtilsMessageSeverityFlagBitsEXT :: enum s32 {
    VERBOSE_BIT_EXT        :: 1;
    INFO_BIT_EXT           :: 16;
    WARNING_BIT_EXT        :: 256;
    ERROR_BIT_EXT          :: 4096;
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647;
}

VkDebugUtilsMessageTypeFlagBitsEXT :: enum s32 {
    GENERAL_BIT_EXT                :: 1;
    VALIDATION_BIT_EXT             :: 2;
    PERFORMANCE_BIT_EXT            :: 4;
    DEVICE_ADDRESS_BINDING_BIT_EXT :: 8;
    FLAG_BITS_MAX_ENUM_EXT         :: 2147483647;
}

VkDebugUtilsMessageTypeFlagsEXT :: VkFlags;
VkDebugUtilsMessageSeverityFlagsEXT :: VkFlags;
VkDebugUtilsMessengerCreateFlagsEXT :: VkFlags;
VkDebugUtilsLabelEXT :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    pLabelName: *u8;
    color:      [4] float;
}

VkDebugUtilsObjectNameInfoEXT :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    objectType:   VkObjectType;
    objectHandle: u64;
    pObjectName:  *u8;
}

VkDebugUtilsMessengerCallbackDataEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    flags:            VkDebugUtilsMessengerCallbackDataFlagsEXT;
    pMessageIdName:   *u8;
    messageIdNumber:  s32;
    pMessage:         *u8;
    queueLabelCount:  u32;
    pQueueLabels:     *VkDebugUtilsLabelEXT;
    cmdBufLabelCount: u32;
    pCmdBufLabels:    *VkDebugUtilsLabelEXT;
    objectCount:      u32;
    pObjects:         *VkDebugUtilsObjectNameInfoEXT;
}

PFN_vkDebugUtilsMessengerCallbackEXT :: #type (messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *VkDebugUtilsMessengerCallbackDataEXT, pUserData: *void) -> VkBool32 #c_call;

VkDebugUtilsMessengerCreateInfoEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkDebugUtilsMessengerCreateFlagsEXT;
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT;
    messageType:     VkDebugUtilsMessageTypeFlagsEXT;
    pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT;
    pUserData:       *void;
}

VkDebugUtilsObjectTagInfoEXT :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    objectType:   VkObjectType;
    objectHandle: u64;
    tagName:      u64;
    tagSize:      u64;
    pTag:         *void;
}

PFN_vkSetDebugUtilsObjectNameEXT :: #type (device: VkDevice, pNameInfo: *VkDebugUtilsObjectNameInfoEXT) -> VkResult #c_call;
PFN_vkSetDebugUtilsObjectTagEXT :: #type (device: VkDevice, pTagInfo: *VkDebugUtilsObjectTagInfoEXT) -> VkResult #c_call;
PFN_vkQueueBeginDebugUtilsLabelEXT :: #type (queue: VkQueue, pLabelInfo: *VkDebugUtilsLabelEXT) -> void #c_call;
PFN_vkQueueEndDebugUtilsLabelEXT :: #type (queue: VkQueue) -> void #c_call;
PFN_vkQueueInsertDebugUtilsLabelEXT :: #type (queue: VkQueue, pLabelInfo: *VkDebugUtilsLabelEXT) -> void #c_call;
PFN_vkCmdBeginDebugUtilsLabelEXT :: #type (commandBuffer: VkCommandBuffer, pLabelInfo: *VkDebugUtilsLabelEXT) -> void #c_call;
PFN_vkCmdEndDebugUtilsLabelEXT :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdInsertDebugUtilsLabelEXT :: #type (commandBuffer: VkCommandBuffer, pLabelInfo: *VkDebugUtilsLabelEXT) -> void #c_call;
PFN_vkCreateDebugUtilsMessengerEXT :: #type (instance: VkInstance, pCreateInfo: *VkDebugUtilsMessengerCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pMessenger: *VkDebugUtilsMessengerEXT) -> VkResult #c_call;
PFN_vkDestroyDebugUtilsMessengerEXT :: #type (instance: VkInstance, messenger: VkDebugUtilsMessengerEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkSubmitDebugUtilsMessageEXT :: #type (instance: VkInstance, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *VkDebugUtilsMessengerCallbackDataEXT) -> void #c_call;

VkSamplerReductionModeEXT :: VkSamplerReductionMode;

VkSamplerReductionModeCreateInfoEXT :: VkSamplerReductionModeCreateInfo;

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT :: VkPhysicalDeviceSamplerFilterMinmaxProperties;

VkPhysicalDeviceInlineUniformBlockFeaturesEXT :: VkPhysicalDeviceInlineUniformBlockFeatures;

VkPhysicalDeviceInlineUniformBlockPropertiesEXT :: VkPhysicalDeviceInlineUniformBlockProperties;

VkWriteDescriptorSetInlineUniformBlockEXT :: VkWriteDescriptorSetInlineUniformBlock;

VkDescriptorPoolInlineUniformBlockCreateInfoEXT :: VkDescriptorPoolInlineUniformBlockCreateInfo;

VkSampleLocationEXT :: struct {
    x: float;
    y: float;
}

VkSampleLocationsInfoEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    sampleLocationsPerPixel: VkSampleCountFlagBits;
    sampleLocationGridSize:  VkExtent2D;
    sampleLocationsCount:    u32;
    pSampleLocations:        *VkSampleLocationEXT;
}

VkAttachmentSampleLocationsEXT :: struct {
    attachmentIndex:     u32;
    sampleLocationsInfo: VkSampleLocationsInfoEXT;
}

VkSubpassSampleLocationsEXT :: struct {
    subpassIndex:        u32;
    sampleLocationsInfo: VkSampleLocationsInfoEXT;
}

VkRenderPassSampleLocationsBeginInfoEXT :: struct {
    sType:                                 VkStructureType;
    pNext:                                 *void;
    attachmentInitialSampleLocationsCount: u32;
    pAttachmentInitialSampleLocations:     *VkAttachmentSampleLocationsEXT;
    postSubpassSampleLocationsCount:       u32;
    pPostSubpassSampleLocations:           *VkSubpassSampleLocationsEXT;
}

VkPipelineSampleLocationsStateCreateInfoEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    sampleLocationsEnable: VkBool32;
    sampleLocationsInfo:   VkSampleLocationsInfoEXT;
}

VkPhysicalDeviceSampleLocationsPropertiesEXT :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    sampleLocationSampleCounts:    VkSampleCountFlags;
    maxSampleLocationGridSize:     VkExtent2D;
    sampleLocationCoordinateRange: [2] float;
    sampleLocationSubPixelBits:    u32;
    variableSampleLocations:       VkBool32;
}

VkMultisamplePropertiesEXT :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    maxSampleLocationGridSize: VkExtent2D;
}

PFN_vkCmdSetSampleLocationsEXT :: #type (commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *VkSampleLocationsInfoEXT) -> void #c_call;
PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT :: #type (physicalDevice: VkPhysicalDevice, samples: VkSampleCountFlagBits, pMultisampleProperties: *VkMultisamplePropertiesEXT) -> void #c_call;

VkBlendOverlapEXT :: enum s32 {
    UNCORRELATED_EXT :: 0;
    DISJOINT_EXT     :: 1;
    CONJOINT_EXT     :: 2;
    MAX_ENUM_EXT     :: 2147483647;
}

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    advancedBlendCoherentOperations: VkBool32;
}

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT :: struct {
    sType:                                 VkStructureType;
    pNext:                                 *void;
    advancedBlendMaxColorAttachments:      u32;
    advancedBlendIndependentBlend:         VkBool32;
    advancedBlendNonPremultipliedSrcColor: VkBool32;
    advancedBlendNonPremultipliedDstColor: VkBool32;
    advancedBlendCorrelatedOverlap:        VkBool32;
    advancedBlendAllOperations:            VkBool32;
}

VkPipelineColorBlendAdvancedStateCreateInfoEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    srcPremultiplied: VkBool32;
    dstPremultiplied: VkBool32;
    blendOverlap:     VkBlendOverlapEXT;
}

VkPipelineCoverageToColorStateCreateFlagsNV :: VkFlags;
VkPipelineCoverageToColorStateCreateInfoNV :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    flags:                   VkPipelineCoverageToColorStateCreateFlagsNV;
    coverageToColorEnable:   VkBool32;
    coverageToColorLocation: u32;
}

VkCoverageModulationModeNV :: enum s32 {
    NONE_NV     :: 0;
    RGB_NV      :: 1;
    ALPHA_NV    :: 2;
    RGBA_NV     :: 3;
    MAX_ENUM_NV :: 2147483647;
}

VkPipelineCoverageModulationStateCreateFlagsNV :: VkFlags;
VkPipelineCoverageModulationStateCreateInfoNV :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    flags:                         VkPipelineCoverageModulationStateCreateFlagsNV;
    coverageModulationMode:        VkCoverageModulationModeNV;
    coverageModulationTableEnable: VkBool32;
    coverageModulationTableCount:  u32;
    pCoverageModulationTable:      *float;
}

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    shaderSMCount:    u32;
    shaderWarpsPerSM: u32;
}

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    shaderSMBuiltins: VkBool32;
}

VkDrmFormatModifierPropertiesEXT :: struct {
    drmFormatModifier:               u64;
    drmFormatModifierPlaneCount:     u32;
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags;
}

VkDrmFormatModifierPropertiesListEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    drmFormatModifierCount:       u32;
    pDrmFormatModifierProperties: *VkDrmFormatModifierPropertiesEXT;
}

VkPhysicalDeviceImageDrmFormatModifierInfoEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    drmFormatModifier:     u64;
    sharingMode:           VkSharingMode;
    queueFamilyIndexCount: u32;
    pQueueFamilyIndices:   *u32;
}

VkImageDrmFormatModifierListCreateInfoEXT :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    drmFormatModifierCount: u32;
    pDrmFormatModifiers:    *u64;
}

VkImageDrmFormatModifierExplicitCreateInfoEXT :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    drmFormatModifier:           u64;
    drmFormatModifierPlaneCount: u32;
    pPlaneLayouts:               *VkSubresourceLayout;
}

VkImageDrmFormatModifierPropertiesEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    drmFormatModifier: u64;
}

VkDrmFormatModifierProperties2EXT :: struct {
    drmFormatModifier:               u64;
    drmFormatModifierPlaneCount:     u32;
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags2;
}

VkDrmFormatModifierPropertiesList2EXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    drmFormatModifierCount:       u32;
    pDrmFormatModifierProperties: *VkDrmFormatModifierProperties2EXT;
}

PFN_vkGetImageDrmFormatModifierPropertiesEXT :: #type (device: VkDevice, image: VkImage, pProperties: *VkImageDrmFormatModifierPropertiesEXT) -> VkResult #c_call;

VkValidationCacheEXT_T :: struct {}
VkValidationCacheEXT :: *VkValidationCacheEXT_T;

VkValidationCacheHeaderVersionEXT :: enum s32 {
    ONE_EXT      :: 1;
    MAX_ENUM_EXT :: 2147483647;
}

VkValidationCacheCreateFlagsEXT :: VkFlags;
VkValidationCacheCreateInfoEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkValidationCacheCreateFlagsEXT;
    initialDataSize: u64;
    pInitialData:    *void;
}

VkShaderModuleValidationCacheCreateInfoEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    validationCache: VkValidationCacheEXT;
}

PFN_vkCreateValidationCacheEXT :: #type (device: VkDevice, pCreateInfo: *VkValidationCacheCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pValidationCache: *VkValidationCacheEXT) -> VkResult #c_call;
PFN_vkDestroyValidationCacheEXT :: #type (device: VkDevice, validationCache: VkValidationCacheEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkMergeValidationCachesEXT :: #type (device: VkDevice, dstCache: VkValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *VkValidationCacheEXT) -> VkResult #c_call;
PFN_vkGetValidationCacheDataEXT :: #type (device: VkDevice, validationCache: VkValidationCacheEXT, pDataSize: *u64, pData: *void) -> VkResult #c_call;

VkDescriptorBindingFlagBitsEXT :: VkDescriptorBindingFlagBits;

VkDescriptorBindingFlagsEXT :: VkDescriptorBindingFlags;

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT :: VkDescriptorSetLayoutBindingFlagsCreateInfo;

VkPhysicalDeviceDescriptorIndexingFeaturesEXT :: VkPhysicalDeviceDescriptorIndexingFeatures;

VkPhysicalDeviceDescriptorIndexingPropertiesEXT :: VkPhysicalDeviceDescriptorIndexingProperties;

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT :: VkDescriptorSetVariableDescriptorCountAllocateInfo;

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT :: VkDescriptorSetVariableDescriptorCountLayoutSupport;

VkShadingRatePaletteEntryNV :: enum s32 {
    NO_INVOCATIONS_NV               :: 0;
    _16_INVOCATIONS_PER_PIXEL_NV    :: 1;
    _8_INVOCATIONS_PER_PIXEL_NV     :: 2;
    _4_INVOCATIONS_PER_PIXEL_NV     :: 3;
    _2_INVOCATIONS_PER_PIXEL_NV     :: 4;
    _1_INVOCATION_PER_PIXEL_NV      :: 5;
    _1_INVOCATION_PER_2X1_PIXELS_NV :: 6;
    _1_INVOCATION_PER_1X2_PIXELS_NV :: 7;
    _1_INVOCATION_PER_2X2_PIXELS_NV :: 8;
    _1_INVOCATION_PER_4X2_PIXELS_NV :: 9;
    _1_INVOCATION_PER_2X4_PIXELS_NV :: 10;
    _1_INVOCATION_PER_4X4_PIXELS_NV :: 11;
    MAX_ENUM_NV                     :: 2147483647;
}

VkCoarseSampleOrderTypeNV :: enum s32 {
    DEFAULT_NV      :: 0;
    CUSTOM_NV       :: 1;
    PIXEL_MAJOR_NV  :: 2;
    SAMPLE_MAJOR_NV :: 3;
    MAX_ENUM_NV     :: 2147483647;
}

VkShadingRatePaletteNV :: struct {
    shadingRatePaletteEntryCount: u32;
    pShadingRatePaletteEntries:   *VkShadingRatePaletteEntryNV;
}

VkPipelineViewportShadingRateImageStateCreateInfoNV :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    shadingRateImageEnable: VkBool32;
    viewportCount:          u32;
    pShadingRatePalettes:   *VkShadingRatePaletteNV;
}

VkPhysicalDeviceShadingRateImageFeaturesNV :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    shadingRateImage:             VkBool32;
    shadingRateCoarseSampleOrder: VkBool32;
}

VkPhysicalDeviceShadingRateImagePropertiesNV :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    shadingRateTexelSize:        VkExtent2D;
    shadingRatePaletteSize:      u32;
    shadingRateMaxCoarseSamples: u32;
}

VkCoarseSampleLocationNV :: struct {
    pixelX: u32;
    pixelY: u32;
    sample: u32;
}

VkCoarseSampleOrderCustomNV :: struct {
    shadingRate:         VkShadingRatePaletteEntryNV;
    sampleCount:         u32;
    sampleLocationCount: u32;
    pSampleLocations:    *VkCoarseSampleLocationNV;
}

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    sampleOrderType:        VkCoarseSampleOrderTypeNV;
    customSampleOrderCount: u32;
    pCustomSampleOrders:    *VkCoarseSampleOrderCustomNV;
}

PFN_vkCmdBindShadingRateImageNV :: #type (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> void #c_call;
PFN_vkCmdSetViewportShadingRatePaletteNV :: #type (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *VkShadingRatePaletteNV) -> void #c_call;
PFN_vkCmdSetCoarseSampleOrderNV :: #type (commandBuffer: VkCommandBuffer, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *VkCoarseSampleOrderCustomNV) -> void #c_call;

VkAccelerationStructureNV_T :: struct {}
VkAccelerationStructureNV :: *VkAccelerationStructureNV_T;

VkRayTracingShaderGroupTypeKHR :: enum s32 {
    GENERAL_KHR              :: 0;
    TRIANGLES_HIT_GROUP_KHR  :: 1;
    PROCEDURAL_HIT_GROUP_KHR :: 2;
    GENERAL_NV               :: 0;
    TRIANGLES_HIT_GROUP_NV   :: 1;
    PROCEDURAL_HIT_GROUP_NV  :: 2;
    MAX_ENUM_KHR             :: 2147483647;
}

VkRayTracingShaderGroupTypeNV :: VkRayTracingShaderGroupTypeKHR;

VkGeometryTypeKHR :: enum s32 {
    TRIANGLES_KHR :: 0;
    AABBS_KHR     :: 1;
    INSTANCES_KHR :: 2;
    TRIANGLES_NV  :: 0;
    AABBS_NV      :: 1;
    MAX_ENUM_KHR  :: 2147483647;
}

VkGeometryTypeNV :: VkGeometryTypeKHR;

VkAccelerationStructureTypeKHR :: enum s32 {
    TOP_LEVEL_KHR    :: 0;
    BOTTOM_LEVEL_KHR :: 1;
    GENERIC_KHR      :: 2;
    TOP_LEVEL_NV     :: 0;
    BOTTOM_LEVEL_NV  :: 1;
    MAX_ENUM_KHR     :: 2147483647;
}

VkAccelerationStructureTypeNV :: VkAccelerationStructureTypeKHR;

VkCopyAccelerationStructureModeKHR :: enum s32 {
    CLONE_KHR       :: 0;
    COMPACT_KHR     :: 1;
    SERIALIZE_KHR   :: 2;
    DESERIALIZE_KHR :: 3;
    CLONE_NV        :: 0;
    COMPACT_NV      :: 1;
    MAX_ENUM_KHR    :: 2147483647;
}

VkCopyAccelerationStructureModeNV :: VkCopyAccelerationStructureModeKHR;

VkAccelerationStructureMemoryRequirementsTypeNV :: enum s32 {
    OBJECT_NV         :: 0;
    BUILD_SCRATCH_NV  :: 1;
    UPDATE_SCRATCH_NV :: 2;
    MAX_ENUM_NV       :: 2147483647;
}

VkGeometryFlagBitsKHR :: enum s32 {
    OPAQUE_BIT_KHR                          :: 1;
    NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR :: 2;
    OPAQUE_BIT_NV                           :: 1;
    NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV  :: 2;
    FLAG_BITS_MAX_ENUM_KHR                  :: 2147483647;
}

VkGeometryFlagsKHR :: VkFlags;
VkGeometryFlagsNV :: VkGeometryFlagsKHR;

VkGeometryFlagBitsNV :: VkGeometryFlagBitsKHR;

VkGeometryInstanceFlagBitsKHR :: enum s32 {
    TRIANGLE_FACING_CULL_DISABLE_BIT_KHR    :: 1;
    TRIANGLE_FLIP_FACING_BIT_KHR            :: 2;
    FORCE_OPAQUE_BIT_KHR                    :: 4;
    FORCE_NO_OPAQUE_BIT_KHR                 :: 8;
    FORCE_OPACITY_MICROMAP_2_STATE_EXT      :: 16;
    DISABLE_OPACITY_MICROMAPS_EXT           :: 32;
    TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR :: 2;
    TRIANGLE_CULL_DISABLE_BIT_NV            :: 1;
    TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV  :: 2;
    FORCE_OPAQUE_BIT_NV                     :: 4;
    FORCE_NO_OPAQUE_BIT_NV                  :: 8;
    FLAG_BITS_MAX_ENUM_KHR                  :: 2147483647;
}

VkGeometryInstanceFlagsKHR :: VkFlags;
VkGeometryInstanceFlagsNV :: VkGeometryInstanceFlagsKHR;

VkGeometryInstanceFlagBitsNV :: VkGeometryInstanceFlagBitsKHR;

VkBuildAccelerationStructureFlagBitsKHR :: enum s32 {
    ALLOW_UPDATE_BIT_KHR                   :: 1;
    ALLOW_COMPACTION_BIT_KHR               :: 2;
    PREFER_FAST_TRACE_BIT_KHR              :: 4;
    PREFER_FAST_BUILD_BIT_KHR              :: 8;
    LOW_MEMORY_BIT_KHR                     :: 16;
    MOTION_BIT_NV                          :: 32;
    ALLOW_OPACITY_MICROMAP_UPDATE_EXT      :: 64;
    ALLOW_DISABLE_OPACITY_MICROMAPS_EXT    :: 128;
    ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT :: 256;

    ALLOW_DATA_ACCESS_KHR                  :: 2048;
    ALLOW_UPDATE_BIT_NV                    :: 1;
    ALLOW_COMPACTION_BIT_NV                :: 2;
    PREFER_FAST_TRACE_BIT_NV               :: 4;
    PREFER_FAST_BUILD_BIT_NV               :: 8;
    LOW_MEMORY_BIT_NV                      :: 16;
    FLAG_BITS_MAX_ENUM_KHR                 :: 2147483647;
}

VkBuildAccelerationStructureFlagsKHR :: VkFlags;
VkBuildAccelerationStructureFlagsNV :: VkBuildAccelerationStructureFlagsKHR;

VkBuildAccelerationStructureFlagBitsNV :: VkBuildAccelerationStructureFlagBitsKHR;

VkRayTracingShaderGroupCreateInfoNV :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    type:               VkRayTracingShaderGroupTypeKHR;
    generalShader:      u32;
    closestHitShader:   u32;
    anyHitShader:       u32;
    intersectionShader: u32;
}

VkRayTracingPipelineCreateInfoNV :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    flags:              VkPipelineCreateFlags;
    stageCount:         u32;
    pStages:            *VkPipelineShaderStageCreateInfo;
    groupCount:         u32;
    pGroups:            *VkRayTracingShaderGroupCreateInfoNV;
    maxRecursionDepth:  u32;
    layout:             VkPipelineLayout;
    basePipelineHandle: VkPipeline;
    basePipelineIndex:  s32;
}

VkGeometryTrianglesNV :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    vertexData:      VkBuffer;
    vertexOffset:    VkDeviceSize;
    vertexCount:     u32;
    vertexStride:    VkDeviceSize;
    vertexFormat:    VkFormat;
    indexData:       VkBuffer;
    indexOffset:     VkDeviceSize;
    indexCount:      u32;
    indexType:       VkIndexType;
    transformData:   VkBuffer;
    transformOffset: VkDeviceSize;
}

VkGeometryAABBNV :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    aabbData: VkBuffer;
    numAABBs: u32;
    stride:   u32;
    offset:   VkDeviceSize;
}

VkGeometryDataNV :: struct {
    triangles: VkGeometryTrianglesNV;
    aabbs:     VkGeometryAABBNV;
}

VkGeometryNV :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    geometryType: VkGeometryTypeKHR;
    geometry:     VkGeometryDataNV;
    flags:        VkGeometryFlagsKHR;
}

VkAccelerationStructureInfoNV :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    type:          VkAccelerationStructureTypeNV;
    flags:         VkBuildAccelerationStructureFlagsNV;
    instanceCount: u32;
    geometryCount: u32;
    pGeometries:   *VkGeometryNV;
}

VkAccelerationStructureCreateInfoNV :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    compactedSize: VkDeviceSize;
    info:          VkAccelerationStructureInfoNV;
}

VkBindAccelerationStructureMemoryInfoNV :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    accelerationStructure: VkAccelerationStructureNV;
    memory:                VkDeviceMemory;
    memoryOffset:          VkDeviceSize;
    deviceIndexCount:      u32;
    pDeviceIndices:        *u32;
}

VkWriteDescriptorSetAccelerationStructureNV :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    accelerationStructureCount: u32;
    pAccelerationStructures:    *VkAccelerationStructureNV;
}

VkAccelerationStructureMemoryRequirementsInfoNV :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    type:                  VkAccelerationStructureMemoryRequirementsTypeNV;
    accelerationStructure: VkAccelerationStructureNV;
}

VkPhysicalDeviceRayTracingPropertiesNV :: struct {
    sType:                                  VkStructureType;
    pNext:                                  *void;
    shaderGroupHandleSize:                  u32;
    maxRecursionDepth:                      u32;
    maxShaderGroupStride:                   u32;
    shaderGroupBaseAlignment:               u32;
    maxGeometryCount:                       u64;
    maxInstanceCount:                       u64;
    maxTriangleCount:                       u64;
    maxDescriptorSetAccelerationStructures: u32;
}

VkTransformMatrixKHR :: struct {
    matrix: [3] [4] float;
}

VkTransformMatrixNV :: VkTransformMatrixKHR;

VkAabbPositionsKHR :: struct {
    minX: float;
    minY: float;
    minZ: float;
    maxX: float;
    maxY: float;
    maxZ: float;
}

VkAabbPositionsNV :: VkAabbPositionsKHR;

VkAccelerationStructureInstanceKHR :: struct {
    transform:                      VkTransformMatrixKHR;
    __bitfield:                     [8] u8;
    /* 
        instanceCustomIndex: u32; /* 24 bits */
        mask: u32; /* 8 bits */
        instanceShaderBindingTableRecordOffset: u32; /* 24 bits */
        flags: VkGeometryInstanceFlagsKHR; /* 8 bits */;
    */

    accelerationStructureReference: u64;
}

VkAccelerationStructureInstanceNV :: VkAccelerationStructureInstanceKHR;

PFN_vkCreateAccelerationStructureNV :: #type (device: VkDevice, pCreateInfo: *VkAccelerationStructureCreateInfoNV, pAllocator: *VkAllocationCallbacks, pAccelerationStructure: *VkAccelerationStructureNV) -> VkResult #c_call;
PFN_vkDestroyAccelerationStructureNV :: #type (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetAccelerationStructureMemoryRequirementsNV :: #type (device: VkDevice, pInfo: *VkAccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *VkMemoryRequirements2KHR) -> void #c_call;
PFN_vkBindAccelerationStructureMemoryNV :: #type (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindAccelerationStructureMemoryInfoNV) -> VkResult #c_call;
PFN_vkCmdBuildAccelerationStructureNV :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkAccelerationStructureInfoNV, instanceData: VkBuffer, instanceOffset: VkDeviceSize, update: VkBool32, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, scratch: VkBuffer, scratchOffset: VkDeviceSize) -> void #c_call;
PFN_vkCmdCopyAccelerationStructureNV :: #type (commandBuffer: VkCommandBuffer, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, mode: VkCopyAccelerationStructureModeKHR) -> void #c_call;
PFN_vkCmdTraceRaysNV :: #type (commandBuffer: VkCommandBuffer, raygenShaderBindingTableBuffer: VkBuffer, raygenShaderBindingOffset: VkDeviceSize, missShaderBindingTableBuffer: VkBuffer, missShaderBindingOffset: VkDeviceSize, missShaderBindingStride: VkDeviceSize, hitShaderBindingTableBuffer: VkBuffer, hitShaderBindingOffset: VkDeviceSize, hitShaderBindingStride: VkDeviceSize, callableShaderBindingTableBuffer: VkBuffer, callableShaderBindingOffset: VkDeviceSize, callableShaderBindingStride: VkDeviceSize, width: u32, height: u32, depth: u32) -> void #c_call;
PFN_vkCreateRayTracingPipelinesNV :: #type (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkRayTracingPipelineCreateInfoNV, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkGetRayTracingShaderGroupHandlesKHR :: #type (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: u64, pData: *void) -> VkResult #c_call;
PFN_vkGetRayTracingShaderGroupHandlesNV :: #type (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: u64, pData: *void) -> VkResult #c_call;
PFN_vkGetAccelerationStructureHandleNV :: #type (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, dataSize: u64, pData: *void) -> VkResult #c_call;
PFN_vkCmdWriteAccelerationStructuresPropertiesNV :: #type (commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureNV, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) -> void #c_call;
PFN_vkCompileDeferredNV :: #type (device: VkDevice, pipeline: VkPipeline, shader: u32) -> VkResult #c_call;

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    representativeFragmentTest: VkBool32;
}

VkPipelineRepresentativeFragmentTestStateCreateInfoNV :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    representativeFragmentTestEnable: VkBool32;
}

VkPhysicalDeviceImageViewImageFormatInfoEXT :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    imageViewType: VkImageViewType;
}

VkFilterCubicImageViewImageFormatPropertiesEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    filterCubic:       VkBool32;
    filterCubicMinmax: VkBool32;
}

VkQueueGlobalPriorityEXT :: VkQueueGlobalPriorityKHR;

VkDeviceQueueGlobalPriorityCreateInfoEXT :: VkDeviceQueueGlobalPriorityCreateInfoKHR;

VkImportMemoryHostPointerInfoEXT :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    handleType:   VkExternalMemoryHandleTypeFlagBits;
    pHostPointer: *void;
}

VkMemoryHostPointerPropertiesEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    memoryTypeBits: u32;
}

VkPhysicalDeviceExternalMemoryHostPropertiesEXT :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    minImportedHostPointerAlignment: VkDeviceSize;
}

PFN_vkGetMemoryHostPointerPropertiesEXT :: #type (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *void, pMemoryHostPointerProperties: *VkMemoryHostPointerPropertiesEXT) -> VkResult #c_call;

PFN_vkCmdWriteBufferMarkerAMD :: #type (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) -> void #c_call;

VkPipelineCompilerControlFlagBitsAMD :: enum s32 {
    VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD :: 2147483647;
}

VkPipelineCompilerControlFlagsAMD :: VkFlags;
VkPipelineCompilerControlCreateInfoAMD :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    compilerControlFlags: VkPipelineCompilerControlFlagsAMD;
}

VkTimeDomainEXT :: enum s32 {
    DEVICE_EXT                    :: 0;
    CLOCK_MONOTONIC_EXT           :: 1;
    CLOCK_MONOTONIC_RAW_EXT       :: 2;
    QUERY_PERFORMANCE_COUNTER_EXT :: 3;
    MAX_ENUM_EXT                  :: 2147483647;
}

VkCalibratedTimestampInfoEXT :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    timeDomain: VkTimeDomainEXT;
}

PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: #type (physicalDevice: VkPhysicalDevice, pTimeDomainCount: *u32, pTimeDomains: *VkTimeDomainEXT) -> VkResult #c_call;
PFN_vkGetCalibratedTimestampsEXT :: #type (device: VkDevice, timestampCount: u32, pTimestampInfos: *VkCalibratedTimestampInfoEXT, pTimestamps: *u64, pMaxDeviation: *u64) -> VkResult #c_call;

VkPhysicalDeviceShaderCorePropertiesAMD :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    shaderEngineCount:          u32;
    shaderArraysPerEngineCount: u32;
    computeUnitsPerShaderArray: u32;
    simdPerComputeUnit:         u32;
    wavefrontsPerSimd:          u32;
    wavefrontSize:              u32;
    sgprsPerSimd:               u32;
    minSgprAllocation:          u32;
    maxSgprAllocation:          u32;
    sgprAllocationGranularity:  u32;
    vgprsPerSimd:               u32;
    minVgprAllocation:          u32;
    maxVgprAllocation:          u32;
    vgprAllocationGranularity:  u32;
}

VkMemoryOverallocationBehaviorAMD :: enum s32 {
    DEFAULT_AMD    :: 0;
    ALLOWED_AMD    :: 1;
    DISALLOWED_AMD :: 2;
    MAX_ENUM_AMD   :: 2147483647;
}

VkDeviceMemoryOverallocationCreateInfoAMD :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    overallocationBehavior: VkMemoryOverallocationBehaviorAMD;
}

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    maxVertexAttribDivisor: u32;
}

VkVertexInputBindingDivisorDescriptionEXT :: struct {
    binding: u32;
    divisor: u32;
}

VkPipelineVertexInputDivisorStateCreateInfoEXT :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    vertexBindingDivisorCount: u32;
    pVertexBindingDivisors:    *VkVertexInputBindingDivisorDescriptionEXT;
}

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT :: struct {
    sType:                                  VkStructureType;
    pNext:                                  *void;
    vertexAttributeInstanceRateDivisor:     VkBool32;
    vertexAttributeInstanceRateZeroDivisor: VkBool32;
}

VkPipelineCreationFeedbackFlagBitsEXT :: VkPipelineCreationFeedbackFlagBits;

VkPipelineCreationFeedbackFlagsEXT :: VkPipelineCreationFeedbackFlags;

VkPipelineCreationFeedbackCreateInfoEXT :: VkPipelineCreationFeedbackCreateInfo;

VkPipelineCreationFeedbackEXT :: VkPipelineCreationFeedback;

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    computeDerivativeGroupQuads:  VkBool32;
    computeDerivativeGroupLinear: VkBool32;
}

VkPhysicalDeviceMeshShaderFeaturesNV :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    taskShader: VkBool32;
    meshShader: VkBool32;
}

VkPhysicalDeviceMeshShaderPropertiesNV :: struct {
    sType:                             VkStructureType;
    pNext:                             *void;
    maxDrawMeshTasksCount:             u32;
    maxTaskWorkGroupInvocations:       u32;
    maxTaskWorkGroupSize:              [3] u32;
    maxTaskTotalMemorySize:            u32;
    maxTaskOutputCount:                u32;
    maxMeshWorkGroupInvocations:       u32;
    maxMeshWorkGroupSize:              [3] u32;
    maxMeshTotalMemorySize:            u32;
    maxMeshOutputVertices:             u32;
    maxMeshOutputPrimitives:           u32;
    maxMeshMultiviewViewCount:         u32;
    meshOutputPerVertexGranularity:    u32;
    meshOutputPerPrimitiveGranularity: u32;
}

VkDrawMeshTasksIndirectCommandNV :: struct {
    taskCount: u32;
    firstTask: u32;
}

PFN_vkCmdDrawMeshTasksNV :: #type (commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksIndirectNV :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksIndirectCountNV :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV :: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;

VkPhysicalDeviceShaderImageFootprintFeaturesNV :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    imageFootprint: VkBool32;
}

VkPipelineViewportExclusiveScissorStateCreateInfoNV :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    exclusiveScissorCount: u32;
    pExclusiveScissors:    *VkRect2D;
}

VkPhysicalDeviceExclusiveScissorFeaturesNV :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    exclusiveScissor: VkBool32;
}

PFN_vkCmdSetExclusiveScissorEnableNV :: #type (commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *VkBool32) -> void #c_call;
PFN_vkCmdSetExclusiveScissorNV :: #type (commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *VkRect2D) -> void #c_call;

VkQueueFamilyCheckpointPropertiesNV :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    checkpointExecutionStageMask: VkPipelineStageFlags;
}

VkCheckpointDataNV :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    stage:             VkPipelineStageFlagBits;
    pCheckpointMarker: *void;
}

PFN_vkCmdSetCheckpointNV :: #type (commandBuffer: VkCommandBuffer, pCheckpointMarker: *void) -> void #c_call;
PFN_vkGetQueueCheckpointDataNV :: #type (queue: VkQueue, pCheckpointDataCount: *u32, pCheckpointData: *VkCheckpointDataNV) -> void #c_call;

VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    shaderIntegerFunctions2: VkBool32;
}

VkPerformanceConfigurationINTEL_T :: struct {}
VkPerformanceConfigurationINTEL :: *VkPerformanceConfigurationINTEL_T;

VkPerformanceConfigurationTypeINTEL :: enum s32 {
    COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL :: 0;
    MAX_ENUM_INTEL                                  :: 2147483647;
}

VkQueryPoolSamplingModeINTEL :: enum s32 {
    MANUAL_INTEL   :: 0;
    MAX_ENUM_INTEL :: 2147483647;
}

VkPerformanceOverrideTypeINTEL :: enum s32 {
    NULL_HARDWARE_INTEL    :: 0;
    FLUSH_GPU_CACHES_INTEL :: 1;
    MAX_ENUM_INTEL         :: 2147483647;
}

VkPerformanceParameterTypeINTEL :: enum s32 {
    HW_COUNTERS_SUPPORTED_INTEL    :: 0;
    STREAM_MARKER_VALID_BITS_INTEL :: 1;
    MAX_ENUM_INTEL                 :: 2147483647;
}

VkPerformanceValueTypeINTEL :: enum s32 {
    UINT32_INTEL   :: 0;
    UINT64_INTEL   :: 1;
    FLOAT_INTEL    :: 2;
    BOOL_INTEL     :: 3;
    STRING_INTEL   :: 4;
    MAX_ENUM_INTEL :: 2147483647;
}

VkPerformanceValueDataINTEL :: union {
    value32:     u32;
    value64:     u64;
    valueFloat:  float;
    valueBool:   VkBool32;
    valueString: *u8;
}

VkPerformanceValueINTEL :: struct {
    type: VkPerformanceValueTypeINTEL;
    data: VkPerformanceValueDataINTEL;
}

VkInitializePerformanceApiInfoINTEL :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    pUserData: *void;
}

VkQueryPoolPerformanceQueryCreateInfoINTEL :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    performanceCountersSampling: VkQueryPoolSamplingModeINTEL;
}

VkQueryPoolCreateInfoINTEL :: VkQueryPoolPerformanceQueryCreateInfoINTEL;

VkPerformanceMarkerInfoINTEL :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    marker: u64;
}

VkPerformanceStreamMarkerInfoINTEL :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    marker: u32;
}

VkPerformanceOverrideInfoINTEL :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    type:      VkPerformanceOverrideTypeINTEL;
    enable:    VkBool32;
    parameter: u64;
}

VkPerformanceConfigurationAcquireInfoINTEL :: struct {
    sType: VkStructureType;
    pNext: *void;
    type:  VkPerformanceConfigurationTypeINTEL;
}

PFN_vkInitializePerformanceApiINTEL :: #type (device: VkDevice, pInitializeInfo: *VkInitializePerformanceApiInfoINTEL) -> VkResult #c_call;
PFN_vkUninitializePerformanceApiINTEL :: #type (device: VkDevice) -> void #c_call;
PFN_vkCmdSetPerformanceMarkerINTEL :: #type (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkPerformanceMarkerInfoINTEL) -> VkResult #c_call;
PFN_vkCmdSetPerformanceStreamMarkerINTEL :: #type (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkPerformanceStreamMarkerInfoINTEL) -> VkResult #c_call;
PFN_vkCmdSetPerformanceOverrideINTEL :: #type (commandBuffer: VkCommandBuffer, pOverrideInfo: *VkPerformanceOverrideInfoINTEL) -> VkResult #c_call;
PFN_vkAcquirePerformanceConfigurationINTEL :: #type (device: VkDevice, pAcquireInfo: *VkPerformanceConfigurationAcquireInfoINTEL, pConfiguration: *VkPerformanceConfigurationINTEL) -> VkResult #c_call;
PFN_vkReleasePerformanceConfigurationINTEL :: #type (device: VkDevice, configuration: VkPerformanceConfigurationINTEL) -> VkResult #c_call;
PFN_vkQueueSetPerformanceConfigurationINTEL :: #type (queue: VkQueue, configuration: VkPerformanceConfigurationINTEL) -> VkResult #c_call;
PFN_vkGetPerformanceParameterINTEL :: #type (device: VkDevice, parameter: VkPerformanceParameterTypeINTEL, pValue: *VkPerformanceValueINTEL) -> VkResult #c_call;

VkPhysicalDevicePCIBusInfoPropertiesEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    pciDomain:   u32;
    pciBus:      u32;
    pciDevice:   u32;
    pciFunction: u32;
}

VkDisplayNativeHdrSurfaceCapabilitiesAMD :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    localDimmingSupport: VkBool32;
}

VkSwapchainDisplayNativeHdrCreateInfoAMD :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    localDimmingEnable: VkBool32;
}

PFN_vkSetLocalDimmingAMD :: #type (device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) -> void #c_call;

VkPhysicalDeviceFragmentDensityMapFeaturesEXT :: struct {
    sType:                                 VkStructureType;
    pNext:                                 *void;
    fragmentDensityMap:                    VkBool32;
    fragmentDensityMapDynamic:             VkBool32;
    fragmentDensityMapNonSubsampledImages: VkBool32;
}

VkPhysicalDeviceFragmentDensityMapPropertiesEXT :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    minFragmentDensityTexelSize: VkExtent2D;
    maxFragmentDensityTexelSize: VkExtent2D;
    fragmentDensityInvocations:  VkBool32;
}

VkRenderPassFragmentDensityMapCreateInfoEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    fragmentDensityMapAttachment: VkAttachmentReference;
}

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT :: VkPhysicalDeviceScalarBlockLayoutFeatures;

VkPhysicalDeviceSubgroupSizeControlFeaturesEXT :: VkPhysicalDeviceSubgroupSizeControlFeatures;

VkPhysicalDeviceSubgroupSizeControlPropertiesEXT :: VkPhysicalDeviceSubgroupSizeControlProperties;

VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT :: VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;

VkShaderCorePropertiesFlagBitsAMD :: enum s32 {
    VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD :: 2147483647;
}

VkShaderCorePropertiesFlagsAMD :: VkFlags;
VkPhysicalDeviceShaderCoreProperties2AMD :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    shaderCoreFeatures:     VkShaderCorePropertiesFlagsAMD;
    activeComputeUnitCount: u32;
}

VkPhysicalDeviceCoherentMemoryFeaturesAMD :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    deviceCoherentMemory: VkBool32;
}

VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    shaderImageInt64Atomics: VkBool32;
    sparseImageInt64Atomics: VkBool32;
}

VkPhysicalDeviceMemoryBudgetPropertiesEXT :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    heapBudget: [16] VkDeviceSize;
    heapUsage:  [16] VkDeviceSize;
}

VkPhysicalDeviceMemoryPriorityFeaturesEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    memoryPriority: VkBool32;
}

VkMemoryPriorityAllocateInfoEXT :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    priority: float;
}

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    dedicatedAllocationImageAliasing: VkBool32;
}

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    bufferDeviceAddress:              VkBool32;
    bufferDeviceAddressCaptureReplay: VkBool32;
    bufferDeviceAddressMultiDevice:   VkBool32;
}

VkPhysicalDeviceBufferAddressFeaturesEXT :: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

VkBufferDeviceAddressInfoEXT :: VkBufferDeviceAddressInfo;

VkBufferDeviceAddressCreateInfoEXT :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    deviceAddress: VkDeviceAddress;
}

PFN_vkGetBufferDeviceAddressEXT :: #type (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) -> VkDeviceAddress #c_call;

VkToolPurposeFlagBitsEXT :: VkToolPurposeFlagBits;

VkToolPurposeFlagsEXT :: VkToolPurposeFlags;

VkPhysicalDeviceToolPropertiesEXT :: VkPhysicalDeviceToolProperties;

PFN_vkGetPhysicalDeviceToolPropertiesEXT :: #type (physicalDevice: VkPhysicalDevice, pToolCount: *u32, pToolProperties: *VkPhysicalDeviceToolProperties) -> VkResult #c_call;

VkImageStencilUsageCreateInfoEXT :: VkImageStencilUsageCreateInfo;

VkValidationFeatureEnableEXT :: enum s32 {
    GPU_ASSISTED_EXT                      :: 0;
    GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT :: 1;
    BEST_PRACTICES_EXT                    :: 2;
    DEBUG_PRINTF_EXT                      :: 3;
    SYNCHRONIZATION_VALIDATION_EXT        :: 4;
    MAX_ENUM_EXT                          :: 2147483647;
}

VkValidationFeatureDisableEXT :: enum s32 {
    ALL_EXT                     :: 0;
    SHADERS_EXT                 :: 1;
    THREAD_SAFETY_EXT           :: 2;
    API_PARAMETERS_EXT          :: 3;
    OBJECT_LIFETIMES_EXT        :: 4;
    CORE_CHECKS_EXT             :: 5;
    UNIQUE_HANDLES_EXT          :: 6;
    SHADER_VALIDATION_CACHE_EXT :: 7;
    MAX_ENUM_EXT                :: 2147483647;
}

VkValidationFeaturesEXT :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    enabledValidationFeatureCount:  u32;
    pEnabledValidationFeatures:     *VkValidationFeatureEnableEXT;
    disabledValidationFeatureCount: u32;
    pDisabledValidationFeatures:    *VkValidationFeatureDisableEXT;
}

VkComponentTypeNV :: VkComponentTypeKHR;

VkScopeNV :: VkScopeKHR;

VkCooperativeMatrixPropertiesNV :: struct {
    sType: VkStructureType;
    pNext: *void;
    MSize: u32;
    NSize: u32;
    KSize: u32;
    AType: VkComponentTypeNV;
    BType: VkComponentTypeNV;
    CType: VkComponentTypeNV;
    DType: VkComponentTypeNV;
    scope: VkScopeNV;
}

VkPhysicalDeviceCooperativeMatrixFeaturesNV :: struct {
    sType:                               VkStructureType;
    pNext:                               *void;
    cooperativeMatrix:                   VkBool32;
    cooperativeMatrixRobustBufferAccess: VkBool32;
}

VkPhysicalDeviceCooperativeMatrixPropertiesNV :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    cooperativeMatrixSupportedStages: VkShaderStageFlags;
}

PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkCooperativeMatrixPropertiesNV) -> VkResult #c_call;

VkCoverageReductionModeNV :: enum s32 {
    MERGE_NV    :: 0;
    TRUNCATE_NV :: 1;
    MAX_ENUM_NV :: 2147483647;
}

VkPipelineCoverageReductionStateCreateFlagsNV :: VkFlags;
VkPhysicalDeviceCoverageReductionModeFeaturesNV :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    coverageReductionMode: VkBool32;
}

VkPipelineCoverageReductionStateCreateInfoNV :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    flags:                 VkPipelineCoverageReductionStateCreateFlagsNV;
    coverageReductionMode: VkCoverageReductionModeNV;
}

VkFramebufferMixedSamplesCombinationNV :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    coverageReductionMode: VkCoverageReductionModeNV;
    rasterizationSamples:  VkSampleCountFlagBits;
    depthStencilSamples:   VkSampleCountFlags;
    colorSamples:          VkSampleCountFlags;
}

PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: #type (physicalDevice: VkPhysicalDevice, pCombinationCount: *u32, pCombinations: *VkFramebufferMixedSamplesCombinationNV) -> VkResult #c_call;

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    fragmentShaderSampleInterlock:      VkBool32;
    fragmentShaderPixelInterlock:       VkBool32;
    fragmentShaderShadingRateInterlock: VkBool32;
}

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    ycbcrImageArrays: VkBool32;
}

VkProvokingVertexModeEXT :: enum s32 {
    FIRST_VERTEX_EXT :: 0;
    LAST_VERTEX_EXT  :: 1;
    MAX_ENUM_EXT     :: 2147483647;
}

VkPhysicalDeviceProvokingVertexFeaturesEXT :: struct {
    sType:                                     VkStructureType;
    pNext:                                     *void;
    provokingVertexLast:                       VkBool32;
    transformFeedbackPreservesProvokingVertex: VkBool32;
}

VkPhysicalDeviceProvokingVertexPropertiesEXT :: struct {
    sType:                                                VkStructureType;
    pNext:                                                *void;
    provokingVertexModePerPipeline:                       VkBool32;
    transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32;
}

VkPipelineRasterizationProvokingVertexStateCreateInfoEXT :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    provokingVertexMode: VkProvokingVertexModeEXT;
}

VkHeadlessSurfaceCreateFlagsEXT :: VkFlags;
VkHeadlessSurfaceCreateInfoEXT :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkHeadlessSurfaceCreateFlagsEXT;
}

PFN_vkCreateHeadlessSurfaceEXT :: #type (instance: VkInstance, pCreateInfo: *VkHeadlessSurfaceCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;

VkLineRasterizationModeEXT :: enum s32 {
    DEFAULT_EXT            :: 0;
    RECTANGULAR_EXT        :: 1;
    BRESENHAM_EXT          :: 2;
    RECTANGULAR_SMOOTH_EXT :: 3;
    MAX_ENUM_EXT           :: 2147483647;
}

VkPhysicalDeviceLineRasterizationFeaturesEXT :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    rectangularLines:         VkBool32;
    bresenhamLines:           VkBool32;
    smoothLines:              VkBool32;
    stippledRectangularLines: VkBool32;
    stippledBresenhamLines:   VkBool32;
    stippledSmoothLines:      VkBool32;
}

VkPhysicalDeviceLineRasterizationPropertiesEXT :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    lineSubPixelPrecisionBits: u32;
}

VkPipelineRasterizationLineStateCreateInfoEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    lineRasterizationMode: VkLineRasterizationModeEXT;
    stippledLineEnable:    VkBool32;
    lineStippleFactor:     u32;
    lineStipplePattern:    u16;
}

PFN_vkCmdSetLineStippleEXT :: #type (commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> void #c_call;

VkPhysicalDeviceShaderAtomicFloatFeaturesEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    shaderBufferFloat32Atomics:   VkBool32;
    shaderBufferFloat32AtomicAdd: VkBool32;
    shaderBufferFloat64Atomics:   VkBool32;
    shaderBufferFloat64AtomicAdd: VkBool32;
    shaderSharedFloat32Atomics:   VkBool32;
    shaderSharedFloat32AtomicAdd: VkBool32;
    shaderSharedFloat64Atomics:   VkBool32;
    shaderSharedFloat64AtomicAdd: VkBool32;
    shaderImageFloat32Atomics:    VkBool32;
    shaderImageFloat32AtomicAdd:  VkBool32;
    sparseImageFloat32Atomics:    VkBool32;
    sparseImageFloat32AtomicAdd:  VkBool32;
}

VkPhysicalDeviceHostQueryResetFeaturesEXT :: VkPhysicalDeviceHostQueryResetFeatures;

PFN_vkResetQueryPoolEXT :: #type (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> void #c_call;

VkPhysicalDeviceIndexTypeUint8FeaturesEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    indexTypeUint8: VkBool32;
}

VkPhysicalDeviceExtendedDynamicStateFeaturesEXT :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    extendedDynamicState: VkBool32;
}

PFN_vkCmdSetCullModeEXT :: #type (commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> void #c_call;
PFN_vkCmdSetFrontFaceEXT :: #type (commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) -> void #c_call;
PFN_vkCmdSetPrimitiveTopologyEXT :: #type (commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) -> void #c_call;
PFN_vkCmdSetViewportWithCountEXT :: #type (commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *VkViewport) -> void #c_call;
PFN_vkCmdSetScissorWithCountEXT :: #type (commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *VkRect2D) -> void #c_call;
PFN_vkCmdBindVertexBuffers2EXT :: #type (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize, pStrides: *VkDeviceSize) -> void #c_call;
PFN_vkCmdSetDepthTestEnableEXT :: #type (commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthWriteEnableEXT :: #type (commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthCompareOpEXT :: #type (commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) -> void #c_call;
PFN_vkCmdSetDepthBoundsTestEnableEXT :: #type (commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetStencilTestEnableEXT :: #type (commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetStencilOpEXT :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) -> void #c_call;

VkHostImageCopyFlagBitsEXT :: enum s32 {
    MEMCPY_EXT             :: 1;
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647;
}

VkHostImageCopyFlagsEXT :: VkFlags;
VkPhysicalDeviceHostImageCopyFeaturesEXT :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    hostImageCopy: VkBool32;
}

VkPhysicalDeviceHostImageCopyPropertiesEXT :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    copySrcLayoutCount:              u32;
    pCopySrcLayouts:                 *VkImageLayout;
    copyDstLayoutCount:              u32;
    pCopyDstLayouts:                 *VkImageLayout;
    optimalTilingLayoutUUID:         [16] u8;
    identicalMemoryTypeRequirements: VkBool32;
}

VkMemoryToImageCopyEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    pHostPointer:      *void;
    memoryRowLength:   u32;
    memoryImageHeight: u32;
    imageSubresource:  VkImageSubresourceLayers;
    imageOffset:       VkOffset3D;
    imageExtent:       VkExtent3D;
}

VkImageToMemoryCopyEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    pHostPointer:      *void;
    memoryRowLength:   u32;
    memoryImageHeight: u32;
    imageSubresource:  VkImageSubresourceLayers;
    imageOffset:       VkOffset3D;
    imageExtent:       VkExtent3D;
}

VkCopyMemoryToImageInfoEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    flags:          VkHostImageCopyFlagsEXT;
    dstImage:       VkImage;
    dstImageLayout: VkImageLayout;
    regionCount:    u32;
    pRegions:       *VkMemoryToImageCopyEXT;
}

VkCopyImageToMemoryInfoEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    flags:          VkHostImageCopyFlagsEXT;
    srcImage:       VkImage;
    srcImageLayout: VkImageLayout;
    regionCount:    u32;
    pRegions:       *VkImageToMemoryCopyEXT;
}

VkCopyImageToImageInfoEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    flags:          VkHostImageCopyFlagsEXT;
    srcImage:       VkImage;
    srcImageLayout: VkImageLayout;
    dstImage:       VkImage;
    dstImageLayout: VkImageLayout;
    regionCount:    u32;
    pRegions:       *VkImageCopy2;
}

VkHostImageLayoutTransitionInfoEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    image:            VkImage;
    oldLayout:        VkImageLayout;
    newLayout:        VkImageLayout;
    subresourceRange: VkImageSubresourceRange;
}

VkSubresourceHostMemcpySizeEXT :: struct {
    sType: VkStructureType;
    pNext: *void;
    size:  VkDeviceSize;
}

VkHostImageCopyDevicePerformanceQueryEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    optimalDeviceAccess:   VkBool32;
    identicalMemoryLayout: VkBool32;
}

VkSubresourceLayout2EXT :: VkSubresourceLayout2KHR;

VkImageSubresource2EXT :: VkImageSubresource2KHR;

PFN_vkCopyMemoryToImageEXT :: #type (device: VkDevice, pCopyMemoryToImageInfo: *VkCopyMemoryToImageInfoEXT) -> VkResult #c_call;
PFN_vkCopyImageToMemoryEXT :: #type (device: VkDevice, pCopyImageToMemoryInfo: *VkCopyImageToMemoryInfoEXT) -> VkResult #c_call;
PFN_vkCopyImageToImageEXT :: #type (device: VkDevice, pCopyImageToImageInfo: *VkCopyImageToImageInfoEXT) -> VkResult #c_call;
PFN_vkTransitionImageLayoutEXT :: #type (device: VkDevice, transitionCount: u32, pTransitions: *VkHostImageLayoutTransitionInfoEXT) -> VkResult #c_call;
PFN_vkGetImageSubresourceLayout2EXT :: #type (device: VkDevice, image: VkImage, pSubresource: *VkImageSubresource2KHR, pLayout: *VkSubresourceLayout2KHR) -> void #c_call;

VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    shaderBufferFloat16Atomics:      VkBool32;
    shaderBufferFloat16AtomicAdd:    VkBool32;
    shaderBufferFloat16AtomicMinMax: VkBool32;
    shaderBufferFloat32AtomicMinMax: VkBool32;
    shaderBufferFloat64AtomicMinMax: VkBool32;
    shaderSharedFloat16Atomics:      VkBool32;
    shaderSharedFloat16AtomicAdd:    VkBool32;
    shaderSharedFloat16AtomicMinMax: VkBool32;
    shaderSharedFloat32AtomicMinMax: VkBool32;
    shaderSharedFloat64AtomicMinMax: VkBool32;
    shaderImageFloat32AtomicMinMax:  VkBool32;
    sparseImageFloat32AtomicMinMax:  VkBool32;
}

VkPresentScalingFlagBitsEXT :: enum s32 {
    ONE_TO_ONE_BIT_EXT           :: 1;
    ASPECT_RATIO_STRETCH_BIT_EXT :: 2;
    STRETCH_BIT_EXT              :: 4;
    FLAG_BITS_MAX_ENUM_EXT       :: 2147483647;
}

VkPresentScalingFlagsEXT :: VkFlags;

VkPresentGravityFlagBitsEXT :: enum s32 {
    MIN_BIT_EXT            :: 1;
    MAX_BIT_EXT            :: 2;
    CENTERED_BIT_EXT       :: 4;
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647;
}

VkPresentGravityFlagsEXT :: VkFlags;
VkSurfacePresentModeEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    presentMode: VkPresentModeKHR;
}

VkSurfacePresentScalingCapabilitiesEXT :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    supportedPresentScaling:  VkPresentScalingFlagsEXT;
    supportedPresentGravityX: VkPresentGravityFlagsEXT;
    supportedPresentGravityY: VkPresentGravityFlagsEXT;
    minScaledImageExtent:     VkExtent2D;
    maxScaledImageExtent:     VkExtent2D;
}

VkSurfacePresentModeCompatibilityEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    presentModeCount: u32;
    pPresentModes:    *VkPresentModeKHR;
}

VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    swapchainMaintenance1: VkBool32;
}

VkSwapchainPresentFenceInfoEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    swapchainCount: u32;
    pFences:        *VkFence;
}

VkSwapchainPresentModesCreateInfoEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    presentModeCount: u32;
    pPresentModes:    *VkPresentModeKHR;
}

VkSwapchainPresentModeInfoEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    swapchainCount: u32;
    pPresentModes:  *VkPresentModeKHR;
}

VkSwapchainPresentScalingCreateInfoEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    scalingBehavior: VkPresentScalingFlagsEXT;
    presentGravityX: VkPresentGravityFlagsEXT;
    presentGravityY: VkPresentGravityFlagsEXT;
}

VkReleaseSwapchainImagesInfoEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    swapchain:       VkSwapchainKHR;
    imageIndexCount: u32;
    pImageIndices:   *u32;
}

PFN_vkReleaseSwapchainImagesEXT :: #type (device: VkDevice, pReleaseInfo: *VkReleaseSwapchainImagesInfoEXT) -> VkResult #c_call;

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT :: VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;

VkIndirectCommandsLayoutNV_T :: struct {}
VkIndirectCommandsLayoutNV :: *VkIndirectCommandsLayoutNV_T;

VkIndirectCommandsTokenTypeNV :: enum s32 {
    SHADER_GROUP_NV    :: 0;
    STATE_FLAGS_NV     :: 1;
    INDEX_BUFFER_NV    :: 2;
    VERTEX_BUFFER_NV   :: 3;
    PUSH_CONSTANT_NV   :: 4;
    DRAW_INDEXED_NV    :: 5;
    DRAW_NV            :: 6;
    DRAW_TASKS_NV      :: 7;
    DRAW_MESH_TASKS_NV :: 1000328000;
    PIPELINE_NV        :: 1000428003;
    DISPATCH_NV        :: 1000428004;
    MAX_ENUM_NV        :: 2147483647;
}

VkIndirectStateFlagBitsNV :: enum s32 {
    FRONTFACE_BIT_NV :: 1;
    BITS_MAX_ENUM_NV :: 2147483647;
}

VkIndirectStateFlagsNV :: VkFlags;

VkIndirectCommandsLayoutUsageFlagBitsNV :: enum s32 {
    EXPLICIT_PREPROCESS_BIT_NV :: 1;
    INDEXED_SEQUENCES_BIT_NV   :: 2;
    UNORDERED_SEQUENCES_BIT_NV :: 4;
    FLAG_BITS_MAX_ENUM_NV      :: 2147483647;
}

VkIndirectCommandsLayoutUsageFlagsNV :: VkFlags;
VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV :: struct {
    sType:                                    VkStructureType;
    pNext:                                    *void;
    maxGraphicsShaderGroupCount:              u32;
    maxIndirectSequenceCount:                 u32;
    maxIndirectCommandsTokenCount:            u32;
    maxIndirectCommandsStreamCount:           u32;
    maxIndirectCommandsTokenOffset:           u32;
    maxIndirectCommandsStreamStride:          u32;
    minSequencesCountBufferOffsetAlignment:   u32;
    minSequencesIndexBufferOffsetAlignment:   u32;
    minIndirectCommandsBufferOffsetAlignment: u32;
}

VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    deviceGeneratedCommands: VkBool32;
}

VkGraphicsShaderGroupCreateInfoNV :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    stageCount:         u32;
    pStages:            *VkPipelineShaderStageCreateInfo;
    pVertexInputState:  *VkPipelineVertexInputStateCreateInfo;
    pTessellationState: *VkPipelineTessellationStateCreateInfo;
}

VkGraphicsPipelineShaderGroupsCreateInfoNV :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    groupCount:    u32;
    pGroups:       *VkGraphicsShaderGroupCreateInfoNV;
    pipelineCount: u32;
    pPipelines:    *VkPipeline;
}

VkBindShaderGroupIndirectCommandNV :: struct {
    groupIndex: u32;
}

VkBindIndexBufferIndirectCommandNV :: struct {
    bufferAddress: VkDeviceAddress;
    size:          u32;
    indexType:     VkIndexType;
}

VkBindVertexBufferIndirectCommandNV :: struct {
    bufferAddress: VkDeviceAddress;
    size:          u32;
    stride:        u32;
}

VkSetStateFlagsIndirectCommandNV :: struct {
    data: u32;
}

VkIndirectCommandsStreamNV :: struct {
    buffer: VkBuffer;
    offset: VkDeviceSize;
}

VkIndirectCommandsLayoutTokenNV :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    tokenType:                    VkIndirectCommandsTokenTypeNV;
    stream:                       u32;
    offset:                       u32;
    vertexBindingUnit:            u32;
    vertexDynamicStride:          VkBool32;
    pushconstantPipelineLayout:   VkPipelineLayout;
    pushconstantShaderStageFlags: VkShaderStageFlags;
    pushconstantOffset:           u32;
    pushconstantSize:             u32;
    indirectStateFlags:           VkIndirectStateFlagsNV;
    indexTypeCount:               u32;
    pIndexTypes:                  *VkIndexType;
    pIndexTypeValues:             *u32;
}

VkIndirectCommandsLayoutCreateInfoNV :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    flags:             VkIndirectCommandsLayoutUsageFlagsNV;
    pipelineBindPoint: VkPipelineBindPoint;
    tokenCount:        u32;
    pTokens:           *VkIndirectCommandsLayoutTokenNV;
    streamCount:       u32;
    pStreamStrides:    *u32;
}

VkGeneratedCommandsInfoNV :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    pipelineBindPoint:      VkPipelineBindPoint;
    pipeline:               VkPipeline;
    indirectCommandsLayout: VkIndirectCommandsLayoutNV;
    streamCount:            u32;
    pStreams:               *VkIndirectCommandsStreamNV;
    sequencesCount:         u32;
    preprocessBuffer:       VkBuffer;
    preprocessOffset:       VkDeviceSize;
    preprocessSize:         VkDeviceSize;
    sequencesCountBuffer:   VkBuffer;
    sequencesCountOffset:   VkDeviceSize;
    sequencesIndexBuffer:   VkBuffer;
    sequencesIndexOffset:   VkDeviceSize;
}

VkGeneratedCommandsMemoryRequirementsInfoNV :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    pipelineBindPoint:      VkPipelineBindPoint;
    pipeline:               VkPipeline;
    indirectCommandsLayout: VkIndirectCommandsLayoutNV;
    maxSequencesCount:      u32;
}

PFN_vkGetGeneratedCommandsMemoryRequirementsNV :: #type (device: VkDevice, pInfo: *VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkCmdPreprocessGeneratedCommandsNV :: #type (commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: *VkGeneratedCommandsInfoNV) -> void #c_call;
PFN_vkCmdExecuteGeneratedCommandsNV :: #type (commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: *VkGeneratedCommandsInfoNV) -> void #c_call;
PFN_vkCmdBindPipelineShaderGroupNV :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, groupIndex: u32) -> void #c_call;
PFN_vkCreateIndirectCommandsLayoutNV :: #type (device: VkDevice, pCreateInfo: *VkIndirectCommandsLayoutCreateInfoNV, pAllocator: *VkAllocationCallbacks, pIndirectCommandsLayout: *VkIndirectCommandsLayoutNV) -> VkResult #c_call;
PFN_vkDestroyIndirectCommandsLayoutNV :: #type (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;

VkPhysicalDeviceInheritedViewportScissorFeaturesNV :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    inheritedViewportScissor2D: VkBool32;
}

VkCommandBufferInheritanceViewportScissorInfoNV :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    viewportScissor2D:  VkBool32;
    viewportDepthCount: u32;
    pViewportDepths:    *VkViewport;
}

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    texelBufferAlignment: VkBool32;
}

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT :: VkPhysicalDeviceTexelBufferAlignmentProperties;

VkRenderPassTransformBeginInfoQCOM :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    transform: VkSurfaceTransformFlagBitsKHR;
}

VkCommandBufferInheritanceRenderPassTransformInfoQCOM :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    transform:  VkSurfaceTransformFlagBitsKHR;
    renderArea: VkRect2D;
}

VkDepthBiasRepresentationEXT :: enum s32 {
    LEAST_REPRESENTABLE_VALUE_FORMAT_EXT      :: 0;
    LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT :: 1;
    FLOAT_EXT                                 :: 2;
    MAX_ENUM_EXT                              :: 2147483647;
}

VkPhysicalDeviceDepthBiasControlFeaturesEXT :: struct {
    sType:                                           VkStructureType;
    pNext:                                           *void;
    depthBiasControl:                                VkBool32;
    leastRepresentableValueForceUnormRepresentation: VkBool32;
    floatRepresentation:                             VkBool32;
    depthBiasExact:                                  VkBool32;
}

VkDepthBiasInfoEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    depthBiasConstantFactor: float;
    depthBiasClamp:          float;
    depthBiasSlopeFactor:    float;
}

VkDepthBiasRepresentationInfoEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    depthBiasRepresentation: VkDepthBiasRepresentationEXT;
    depthBiasExact:          VkBool32;
}

PFN_vkCmdSetDepthBias2EXT :: #type (commandBuffer: VkCommandBuffer, pDepthBiasInfo: *VkDepthBiasInfoEXT) -> void #c_call;

VkDeviceMemoryReportEventTypeEXT :: enum s32 {
    ALLOCATE_EXT          :: 0;
    FREE_EXT              :: 1;
    IMPORT_EXT            :: 2;
    UNIMPORT_EXT          :: 3;
    ALLOCATION_FAILED_EXT :: 4;
    MAX_ENUM_EXT          :: 2147483647;
}

VkDeviceMemoryReportFlagsEXT :: VkFlags;
VkPhysicalDeviceDeviceMemoryReportFeaturesEXT :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    deviceMemoryReport: VkBool32;
}

VkDeviceMemoryReportCallbackDataEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    flags:          VkDeviceMemoryReportFlagsEXT;
    type:           VkDeviceMemoryReportEventTypeEXT;
    memoryObjectId: u64;
    size:           VkDeviceSize;
    objectType:     VkObjectType;
    objectHandle:   u64;
    heapIndex:      u32;
}

PFN_vkDeviceMemoryReportCallbackEXT :: #type (pCallbackData: *VkDeviceMemoryReportCallbackDataEXT, pUserData: *void) -> void #c_call;

VkDeviceDeviceMemoryReportCreateInfoEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    flags:           VkDeviceMemoryReportFlagsEXT;
    pfnUserCallback: PFN_vkDeviceMemoryReportCallbackEXT;
    pUserData:       *void;
}

PFN_vkAcquireDrmDisplayEXT :: #type (physicalDevice: VkPhysicalDevice, drmFd: s32, display: VkDisplayKHR) -> VkResult #c_call;
PFN_vkGetDrmDisplayEXT :: #type (physicalDevice: VkPhysicalDevice, drmFd: s32, connectorId: u32, display: *VkDisplayKHR) -> VkResult #c_call;

VkPhysicalDeviceRobustness2FeaturesEXT :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    robustBufferAccess2: VkBool32;
    robustImageAccess2:  VkBool32;
    nullDescriptor:      VkBool32;
}

VkPhysicalDeviceRobustness2PropertiesEXT :: struct {
    sType:                                  VkStructureType;
    pNext:                                  *void;
    robustStorageBufferAccessSizeAlignment: VkDeviceSize;
    robustUniformBufferAccessSizeAlignment: VkDeviceSize;
}

VkSamplerCustomBorderColorCreateInfoEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    customBorderColor: VkClearColorValue;
    format:            VkFormat;
}

VkPhysicalDeviceCustomBorderColorPropertiesEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    maxCustomBorderColorSamplers: u32;
}

VkPhysicalDeviceCustomBorderColorFeaturesEXT :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    customBorderColors:             VkBool32;
    customBorderColorWithoutFormat: VkBool32;
}

VkPhysicalDevicePresentBarrierFeaturesNV :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    presentBarrier: VkBool32;
}

VkSurfaceCapabilitiesPresentBarrierNV :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    presentBarrierSupported: VkBool32;
}

VkSwapchainPresentBarrierCreateInfoNV :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    presentBarrierEnable: VkBool32;
}

VkPrivateDataSlotEXT :: VkPrivateDataSlot;

VkPrivateDataSlotCreateFlagsEXT :: VkPrivateDataSlotCreateFlags;

VkPhysicalDevicePrivateDataFeaturesEXT :: VkPhysicalDevicePrivateDataFeatures;

VkDevicePrivateDataCreateInfoEXT :: VkDevicePrivateDataCreateInfo;

VkPrivateDataSlotCreateInfoEXT :: VkPrivateDataSlotCreateInfo;

PFN_vkCreatePrivateDataSlotEXT :: #type (device: VkDevice, pCreateInfo: *VkPrivateDataSlotCreateInfo, pAllocator: *VkAllocationCallbacks, pPrivateDataSlot: *VkPrivateDataSlot) -> VkResult #c_call;
PFN_vkDestroyPrivateDataSlotEXT :: #type (device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkSetPrivateDataEXT :: #type (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult #c_call;
PFN_vkGetPrivateDataEXT :: #type (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *u64) -> void #c_call;

VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT :: VkPhysicalDevicePipelineCreationCacheControlFeatures;

VkDeviceDiagnosticsConfigFlagBitsNV :: enum s32 {
    ENABLE_SHADER_DEBUG_INFO_BIT_NV      :: 1;
    ENABLE_RESOURCE_TRACKING_BIT_NV      :: 2;
    ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV  :: 4;
    ENABLE_SHADER_ERROR_REPORTING_BIT_NV :: 8;
    FLAG_BITS_MAX_ENUM_NV                :: 2147483647;
}

VkDeviceDiagnosticsConfigFlagsNV :: VkFlags;
VkPhysicalDeviceDiagnosticsConfigFeaturesNV :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    diagnosticsConfig: VkBool32;
}

VkDeviceDiagnosticsConfigCreateInfoNV :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkDeviceDiagnosticsConfigFlagsNV;
}

VkQueryLowLatencySupportNV :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    pQueriedLowLatencyData: *void;
}

VkAccelerationStructureKHR_T :: struct {}
VkAccelerationStructureKHR :: *VkAccelerationStructureKHR_T;

VkPhysicalDeviceDescriptorBufferPropertiesEXT :: struct {
    sType:                                                VkStructureType;
    pNext:                                                *void;
    combinedImageSamplerDescriptorSingleArray:            VkBool32;
    bufferlessPushDescriptors:                            VkBool32;
    allowSamplerImageViewPostSubmitCreation:              VkBool32;
    descriptorBufferOffsetAlignment:                      VkDeviceSize;
    maxDescriptorBufferBindings:                          u32;
    maxResourceDescriptorBufferBindings:                  u32;
    maxSamplerDescriptorBufferBindings:                   u32;
    maxEmbeddedImmutableSamplerBindings:                  u32;
    maxEmbeddedImmutableSamplers:                         u32;
    bufferCaptureReplayDescriptorDataSize:                u64;
    imageCaptureReplayDescriptorDataSize:                 u64;
    imageViewCaptureReplayDescriptorDataSize:             u64;
    samplerCaptureReplayDescriptorDataSize:               u64;
    accelerationStructureCaptureReplayDescriptorDataSize: u64;
    samplerDescriptorSize:                                u64;
    combinedImageSamplerDescriptorSize:                   u64;
    sampledImageDescriptorSize:                           u64;
    storageImageDescriptorSize:                           u64;
    uniformTexelBufferDescriptorSize:                     u64;
    robustUniformTexelBufferDescriptorSize:               u64;
    storageTexelBufferDescriptorSize:                     u64;
    robustStorageTexelBufferDescriptorSize:               u64;
    uniformBufferDescriptorSize:                          u64;
    robustUniformBufferDescriptorSize:                    u64;
    storageBufferDescriptorSize:                          u64;
    robustStorageBufferDescriptorSize:                    u64;
    inputAttachmentDescriptorSize:                        u64;
    accelerationStructureDescriptorSize:                  u64;
    maxSamplerDescriptorBufferRange:                      VkDeviceSize;
    maxResourceDescriptorBufferRange:                     VkDeviceSize;
    samplerDescriptorBufferAddressSpaceSize:              VkDeviceSize;
    resourceDescriptorBufferAddressSpaceSize:             VkDeviceSize;
    descriptorBufferAddressSpaceSize:                     VkDeviceSize;
}

VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT :: struct {
    sType:                                        VkStructureType;
    pNext:                                        *void;
    combinedImageSamplerDensityMapDescriptorSize: u64;
}

VkPhysicalDeviceDescriptorBufferFeaturesEXT :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    descriptorBuffer:                   VkBool32;
    descriptorBufferCaptureReplay:      VkBool32;
    descriptorBufferImageLayoutIgnored: VkBool32;
    descriptorBufferPushDescriptors:    VkBool32;
}

VkDescriptorAddressInfoEXT :: struct {
    sType:   VkStructureType;
    pNext:   *void;
    address: VkDeviceAddress;
    range:   VkDeviceSize;
    format:  VkFormat;
}

VkDescriptorBufferBindingInfoEXT :: struct {
    sType:   VkStructureType;
    pNext:   *void;
    address: VkDeviceAddress;
    usage:   VkBufferUsageFlags;
}

VkDescriptorBufferBindingPushDescriptorBufferHandleEXT :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    buffer: VkBuffer;
}

VkDescriptorDataEXT :: union {
    pSampler:              *VkSampler;
    pCombinedImageSampler: *VkDescriptorImageInfo;
    pInputAttachmentImage: *VkDescriptorImageInfo;
    pSampledImage:         *VkDescriptorImageInfo;
    pStorageImage:         *VkDescriptorImageInfo;
    pUniformTexelBuffer:   *VkDescriptorAddressInfoEXT;
    pStorageTexelBuffer:   *VkDescriptorAddressInfoEXT;
    pUniformBuffer:        *VkDescriptorAddressInfoEXT;
    pStorageBuffer:        *VkDescriptorAddressInfoEXT;
    accelerationStructure: VkDeviceAddress;
}

VkDescriptorGetInfoEXT :: struct {
    sType: VkStructureType;
    pNext: *void;
    type:  VkDescriptorType;
    data:  VkDescriptorDataEXT;
}

VkBufferCaptureDescriptorDataInfoEXT :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    buffer: VkBuffer;
}

VkImageCaptureDescriptorDataInfoEXT :: struct {
    sType: VkStructureType;
    pNext: *void;
    image: VkImage;
}

VkImageViewCaptureDescriptorDataInfoEXT :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    imageView: VkImageView;
}

VkSamplerCaptureDescriptorDataInfoEXT :: struct {
    sType:   VkStructureType;
    pNext:   *void;
    sampler: VkSampler;
}

VkOpaqueCaptureDescriptorDataCreateInfoEXT :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    opaqueCaptureDescriptorData: *void;
}

VkAccelerationStructureCaptureDescriptorDataInfoEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    accelerationStructure:   VkAccelerationStructureKHR;
    accelerationStructureNV: VkAccelerationStructureNV;
}

PFN_vkGetDescriptorSetLayoutSizeEXT :: #type (device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *VkDeviceSize) -> void #c_call;
PFN_vkGetDescriptorSetLayoutBindingOffsetEXT :: #type (device: VkDevice, layout: VkDescriptorSetLayout, binding: u32, pOffset: *VkDeviceSize) -> void #c_call;
PFN_vkGetDescriptorEXT :: #type (device: VkDevice, pDescriptorInfo: *VkDescriptorGetInfoEXT, dataSize: u64, pDescriptor: *void) -> void #c_call;
PFN_vkCmdBindDescriptorBuffersEXT :: #type (commandBuffer: VkCommandBuffer, bufferCount: u32, pBindingInfos: *VkDescriptorBufferBindingInfoEXT) -> void #c_call;
PFN_vkCmdSetDescriptorBufferOffsetsEXT :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, setCount: u32, pBufferIndices: *u32, pOffsets: *VkDeviceSize) -> void #c_call;
PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32) -> void #c_call;
PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkBufferCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkGetImageOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkImageCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkImageViewCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkSamplerCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkAccelerationStructureCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;

VkGraphicsPipelineLibraryFlagBitsEXT :: enum s32 {
    VERTEX_INPUT_INTERFACE_BIT_EXT    :: 1;
    PRE_RASTERIZATION_SHADERS_BIT_EXT :: 2;
    FRAGMENT_SHADER_BIT_EXT           :: 4;
    FRAGMENT_OUTPUT_INTERFACE_BIT_EXT :: 8;
    FLAG_BITS_MAX_ENUM_EXT            :: 2147483647;
}

VkGraphicsPipelineLibraryFlagsEXT :: VkFlags;
VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    graphicsPipelineLibrary: VkBool32;
}

VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT :: struct {
    sType:                                                     VkStructureType;
    pNext:                                                     *void;
    graphicsPipelineLibraryFastLinking:                        VkBool32;
    graphicsPipelineLibraryIndependentInterpolationDecoration: VkBool32;
}

VkGraphicsPipelineLibraryCreateInfoEXT :: struct {
    sType: VkStructureType;
    pNext: *void;
    flags: VkGraphicsPipelineLibraryFlagsEXT;
}

VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    shaderEarlyAndLateFragmentTests: VkBool32;
}

VkFragmentShadingRateTypeNV :: enum s32 {
    FRAGMENT_SIZE_NV :: 0;
    ENUMS_NV         :: 1;
    MAX_ENUM_NV      :: 2147483647;
}

VkFragmentShadingRateNV :: enum s32 {
    _1_INVOCATION_PER_PIXEL_NV      :: 0;
    _1_INVOCATION_PER_1X2_PIXELS_NV :: 1;
    _1_INVOCATION_PER_2X1_PIXELS_NV :: 4;
    _1_INVOCATION_PER_2X2_PIXELS_NV :: 5;
    _1_INVOCATION_PER_2X4_PIXELS_NV :: 6;
    _1_INVOCATION_PER_4X2_PIXELS_NV :: 9;
    _1_INVOCATION_PER_4X4_PIXELS_NV :: 10;
    _2_INVOCATIONS_PER_PIXEL_NV     :: 11;
    _4_INVOCATIONS_PER_PIXEL_NV     :: 12;
    _8_INVOCATIONS_PER_PIXEL_NV     :: 13;
    _16_INVOCATIONS_PER_PIXEL_NV    :: 14;
    NO_INVOCATIONS_NV               :: 15;
    MAX_ENUM_NV                     :: 2147483647;
}

VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    fragmentShadingRateEnums:         VkBool32;
    supersampleFragmentShadingRates:  VkBool32;
    noInvocationFragmentShadingRates: VkBool32;
}

VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV :: struct {
    sType:                                 VkStructureType;
    pNext:                                 *void;
    maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits;
}

VkPipelineFragmentShadingRateEnumStateCreateInfoNV :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    shadingRateType: VkFragmentShadingRateTypeNV;
    shadingRate:     VkFragmentShadingRateNV;
    combinerOps:     [2] VkFragmentShadingRateCombinerOpKHR;
}

PFN_vkCmdSetFragmentShadingRateEnumNV :: #type (commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: *[2] VkFragmentShadingRateCombinerOpKHR) -> void #c_call;

VkAccelerationStructureMotionInstanceTypeNV :: enum s32 {
    STATIC_NV        :: 0;
    MATRIX_MOTION_NV :: 1;
    SRT_MOTION_NV    :: 2;
    MAX_ENUM_NV      :: 2147483647;
}

VkAccelerationStructureMotionInfoFlagsNV :: VkFlags;
VkAccelerationStructureMotionInstanceFlagsNV :: VkFlags;
VkDeviceOrHostAddressConstKHR :: union {
    deviceAddress: VkDeviceAddress;
    hostAddress:   *void;
}

VkAccelerationStructureGeometryMotionTrianglesDataNV :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    vertexData: VkDeviceOrHostAddressConstKHR;
}

VkAccelerationStructureMotionInfoNV :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    maxInstances: u32;
    flags:        VkAccelerationStructureMotionInfoFlagsNV;
}

VkAccelerationStructureMatrixMotionInstanceNV :: struct {
    transformT0:                    VkTransformMatrixKHR;
    transformT1:                    VkTransformMatrixKHR;
    __bitfield:                     [8] u8;
    /* 
        instanceCustomIndex: u32; /* 24 bits */
        mask: u32; /* 8 bits */
        instanceShaderBindingTableRecordOffset: u32; /* 24 bits */
        flags: VkGeometryInstanceFlagsKHR; /* 8 bits */;
    */

    accelerationStructureReference: u64;
}

VkSRTDataNV :: struct {
    sx:  float;
    a:   float;
    b:   float;
    pvx: float;
    sy:  float;
    c:   float;
    pvy: float;
    sz:  float;
    pvz: float;
    qx:  float;
    qy:  float;
    qz:  float;
    qw:  float;
    tx:  float;
    ty:  float;
    tz:  float;
}

VkAccelerationStructureSRTMotionInstanceNV :: struct {
    transformT0:                    VkSRTDataNV;
    transformT1:                    VkSRTDataNV;
    __bitfield:                     [8] u8;
    /* 
        instanceCustomIndex: u32; /* 24 bits */
        mask: u32; /* 8 bits */
        instanceShaderBindingTableRecordOffset: u32; /* 24 bits */
        flags: VkGeometryInstanceFlagsKHR; /* 8 bits */;
    */

    accelerationStructureReference: u64;
}

VkAccelerationStructureMotionInstanceDataNV :: union {
    staticInstance:       VkAccelerationStructureInstanceKHR;
    matrixMotionInstance: VkAccelerationStructureMatrixMotionInstanceNV;
    srtMotionInstance:    VkAccelerationStructureSRTMotionInstanceNV;
}

VkAccelerationStructureMotionInstanceNV :: struct {
    type:  VkAccelerationStructureMotionInstanceTypeNV;
    flags: VkAccelerationStructureMotionInstanceFlagsNV;
    data:  VkAccelerationStructureMotionInstanceDataNV;
}

VkPhysicalDeviceRayTracingMotionBlurFeaturesNV :: struct {
    sType:                                         VkStructureType;
    pNext:                                         *void;
    rayTracingMotionBlur:                          VkBool32;
    rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32;
}

VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    ycbcr2plane444Formats: VkBool32;
}

VkPhysicalDeviceFragmentDensityMap2FeaturesEXT :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    fragmentDensityMapDeferred: VkBool32;
}

VkPhysicalDeviceFragmentDensityMap2PropertiesEXT :: struct {
    sType:                                     VkStructureType;
    pNext:                                     *void;
    subsampledLoads:                           VkBool32;
    subsampledCoarseReconstructionEarlyAccess: VkBool32;
    maxSubsampledArrayLayers:                  u32;
    maxDescriptorSetSubsampledSamplers:        u32;
}

VkCopyCommandTransformInfoQCOM :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    transform: VkSurfaceTransformFlagBitsKHR;
}

VkPhysicalDeviceImageRobustnessFeaturesEXT :: VkPhysicalDeviceImageRobustnessFeatures;

VkImageCompressionFlagBitsEXT :: enum s32 {
    DEFAULT_EXT             :: 0;
    FIXED_RATE_DEFAULT_EXT  :: 1;
    FIXED_RATE_EXPLICIT_EXT :: 2;
    DISABLED_EXT            :: 4;
    FLAG_BITS_MAX_ENUM_EXT  :: 2147483647;
}

VkImageCompressionFlagsEXT :: VkFlags;

VkImageCompressionFixedRateFlagBitsEXT :: enum s32 {
    NONE_EXT               :: 0;
    _1BPC_BIT_EXT          :: 1;
    _2BPC_BIT_EXT          :: 2;
    _3BPC_BIT_EXT          :: 4;
    _4BPC_BIT_EXT          :: 8;
    _5BPC_BIT_EXT          :: 16;
    _6BPC_BIT_EXT          :: 32;
    _7BPC_BIT_EXT          :: 64;
    _8BPC_BIT_EXT          :: 128;
    _9BPC_BIT_EXT          :: 256;
    _10BPC_BIT_EXT         :: 512;
    _11BPC_BIT_EXT         :: 1024;
    _12BPC_BIT_EXT         :: 2048;
    _13BPC_BIT_EXT         :: 4096;
    _14BPC_BIT_EXT         :: 8192;
    _15BPC_BIT_EXT         :: 16384;
    _16BPC_BIT_EXT         :: 32768;
    _17BPC_BIT_EXT         :: 65536;
    _18BPC_BIT_EXT         :: 131072;
    _19BPC_BIT_EXT         :: 262144;
    _20BPC_BIT_EXT         :: 524288;
    _21BPC_BIT_EXT         :: 1048576;
    _22BPC_BIT_EXT         :: 2097152;
    _23BPC_BIT_EXT         :: 4194304;
    _24BPC_BIT_EXT         :: 8388608;
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647;
}

VkImageCompressionFixedRateFlagsEXT :: VkFlags;
VkPhysicalDeviceImageCompressionControlFeaturesEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    imageCompressionControl: VkBool32;
}

VkImageCompressionControlEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    flags:                        VkImageCompressionFlagsEXT;
    compressionControlPlaneCount: u32;
    pFixedRateFlags:              *VkImageCompressionFixedRateFlagsEXT;
}

VkImageCompressionPropertiesEXT :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    imageCompressionFlags:          VkImageCompressionFlagsEXT;
    imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT;
}

VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    attachmentFeedbackLoopLayout: VkBool32;
}

VkPhysicalDevice4444FormatsFeaturesEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    formatA4R4G4B4: VkBool32;
    formatA4B4G4R4: VkBool32;
}

VkDeviceFaultAddressTypeEXT :: enum s32 {
    NONE_EXT                        :: 0;
    READ_INVALID_EXT                :: 1;
    WRITE_INVALID_EXT               :: 2;
    EXECUTE_INVALID_EXT             :: 3;
    INSTRUCTION_POINTER_UNKNOWN_EXT :: 4;
    INSTRUCTION_POINTER_INVALID_EXT :: 5;
    INSTRUCTION_POINTER_FAULT_EXT   :: 6;
    MAX_ENUM_EXT                    :: 2147483647;
}

VkDeviceFaultVendorBinaryHeaderVersionEXT :: enum s32 {
    ONE_EXT      :: 1;
    MAX_ENUM_EXT :: 2147483647;
}

VkPhysicalDeviceFaultFeaturesEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    deviceFault:             VkBool32;
    deviceFaultVendorBinary: VkBool32;
}

VkDeviceFaultCountsEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    addressInfoCount: u32;
    vendorInfoCount:  u32;
    vendorBinarySize: VkDeviceSize;
}

VkDeviceFaultAddressInfoEXT :: struct {
    addressType:      VkDeviceFaultAddressTypeEXT;
    reportedAddress:  VkDeviceAddress;
    addressPrecision: VkDeviceSize;
}

VkDeviceFaultVendorInfoEXT :: struct {
    description:     [256] u8;
    vendorFaultCode: u64;
    vendorFaultData: u64;
}

VkDeviceFaultInfoEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    description:       [256] u8;
    pAddressInfos:     *VkDeviceFaultAddressInfoEXT;
    pVendorInfos:      *VkDeviceFaultVendorInfoEXT;
    pVendorBinaryData: *void;
}

VkDeviceFaultVendorBinaryHeaderVersionOneEXT :: struct {
    headerSize:            u32;
    headerVersion:         VkDeviceFaultVendorBinaryHeaderVersionEXT;
    vendorID:              u32;
    deviceID:              u32;
    driverVersion:         u32;
    pipelineCacheUUID:     [16] u8;
    applicationNameOffset: u32;
    applicationVersion:    u32;
    engineNameOffset:      u32;
    engineVersion:         u32;
    apiVersion:            u32;
}

PFN_vkGetDeviceFaultInfoEXT :: #type (device: VkDevice, pFaultCounts: *VkDeviceFaultCountsEXT, pFaultInfo: *VkDeviceFaultInfoEXT) -> VkResult #c_call;

VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT :: struct {
    sType:                                     VkStructureType;
    pNext:                                     *void;
    rasterizationOrderColorAttachmentAccess:   VkBool32;
    rasterizationOrderDepthAttachmentAccess:   VkBool32;
    rasterizationOrderStencilAttachmentAccess: VkBool32;
}

VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM :: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;

VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT :: struct {
    sType:                             VkStructureType;
    pNext:                             *void;
    formatRgba10x6WithoutYCbCrSampler: VkBool32;
}

VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    mutableDescriptorType: VkBool32;
}

VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE :: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;

VkMutableDescriptorTypeListEXT :: struct {
    descriptorTypeCount: u32;
    pDescriptorTypes:    *VkDescriptorType;
}

VkMutableDescriptorTypeListVALVE :: VkMutableDescriptorTypeListEXT;

VkMutableDescriptorTypeCreateInfoEXT :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    mutableDescriptorTypeListCount: u32;
    pMutableDescriptorTypeLists:    *VkMutableDescriptorTypeListEXT;
}

VkMutableDescriptorTypeCreateInfoVALVE :: VkMutableDescriptorTypeCreateInfoEXT;

VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    vertexInputDynamicState: VkBool32;
}

VkVertexInputBindingDescription2EXT :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    binding:   u32;
    stride:    u32;
    inputRate: VkVertexInputRate;
    divisor:   u32;
}

VkVertexInputAttributeDescription2EXT :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    location: u32;
    binding:  u32;
    format:   VkFormat;
    offset:   u32;
}

PFN_vkCmdSetVertexInputEXT :: #type (commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *VkVertexInputAttributeDescription2EXT) -> void #c_call;

VkPhysicalDeviceDrmPropertiesEXT :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    hasPrimary:   VkBool32;
    hasRender:    VkBool32;
    primaryMajor: s64;
    primaryMinor: s64;
    renderMajor:  s64;
    renderMinor:  s64;
}

VkDeviceAddressBindingTypeEXT :: enum s32 {
    BIND_EXT     :: 0;
    UNBIND_EXT   :: 1;
    MAX_ENUM_EXT :: 2147483647;
}

VkDeviceAddressBindingFlagBitsEXT :: enum s32 {
    INTERNAL_OBJECT_BIT_EXT :: 1;
    FLAG_BITS_MAX_ENUM_EXT  :: 2147483647;
}

VkDeviceAddressBindingFlagsEXT :: VkFlags;
VkPhysicalDeviceAddressBindingReportFeaturesEXT :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    reportAddressBinding: VkBool32;
}

VkDeviceAddressBindingCallbackDataEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    flags:       VkDeviceAddressBindingFlagsEXT;
    baseAddress: VkDeviceAddress;
    size:        VkDeviceSize;
    bindingType: VkDeviceAddressBindingTypeEXT;
}

VkPhysicalDeviceDepthClipControlFeaturesEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    depthClipControl: VkBool32;
}

VkPipelineViewportDepthClipControlCreateInfoEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    negativeOneToOne: VkBool32;
}

VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT :: struct {
    sType:                             VkStructureType;
    pNext:                             *void;
    primitiveTopologyListRestart:      VkBool32;
    primitiveTopologyPatchListRestart: VkBool32;
}

VkSubpassShadingPipelineCreateInfoHUAWEI :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    renderPass: VkRenderPass;
    subpass:    u32;
}

VkPhysicalDeviceSubpassShadingFeaturesHUAWEI :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    subpassShading: VkBool32;
}

VkPhysicalDeviceSubpassShadingPropertiesHUAWEI :: struct {
    sType:                                     VkStructureType;
    pNext:                                     *void;
    maxSubpassShadingWorkgroupSizeAspectRatio: u32;
}

PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI :: #type (device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *VkExtent2D) -> VkResult #c_call;
PFN_vkCmdSubpassShadingHUAWEI :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;

VkPhysicalDeviceInvocationMaskFeaturesHUAWEI :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    invocationMask: VkBool32;
}

PFN_vkCmdBindInvocationMaskHUAWEI :: #type (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> void #c_call;

VkRemoteAddressNV :: *void;

VkMemoryGetRemoteAddressInfoNV :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    memory:     VkDeviceMemory;
    handleType: VkExternalMemoryHandleTypeFlagBits;
}

VkPhysicalDeviceExternalMemoryRDMAFeaturesNV :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    externalMemoryRDMA: VkBool32;
}

PFN_vkGetMemoryRemoteAddressNV :: #type (device: VkDevice, pMemoryGetRemoteAddressInfo: *VkMemoryGetRemoteAddressInfoNV, pAddress: *VkRemoteAddressNV) -> VkResult #c_call;

VkPipelineInfoEXT :: VkPipelineInfoKHR;

VkPipelinePropertiesIdentifierEXT :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    pipelineIdentifier: [16] u8;
}

VkPhysicalDevicePipelinePropertiesFeaturesEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    pipelinePropertiesIdentifier: VkBool32;
}

PFN_vkGetPipelinePropertiesEXT :: #type (device: VkDevice, pPipelineInfo: *VkPipelineInfoEXT, pPipelineProperties: *VkBaseOutStructure) -> VkResult #c_call;

VkFrameBoundaryFlagBitsEXT :: enum s32 {
    FRAME_END_BIT_EXT      :: 1;
    FLAG_BITS_MAX_ENUM_EXT :: 2147483647;
}

VkFrameBoundaryFlagsEXT :: VkFlags;
VkPhysicalDeviceFrameBoundaryFeaturesEXT :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    frameBoundary: VkBool32;
}

VkFrameBoundaryEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    flags:       VkFrameBoundaryFlagsEXT;
    frameID:     u64;
    imageCount:  u32;
    pImages:     *VkImage;
    bufferCount: u32;
    pBuffers:    *VkBuffer;
    tagName:     u64;
    tagSize:     u64;
    pTag:        *void;
}

VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT :: struct {
    sType:                             VkStructureType;
    pNext:                             *void;
    multisampledRenderToSingleSampled: VkBool32;
}

VkSubpassResolvePerformanceQueryEXT :: struct {
    sType:   VkStructureType;
    pNext:   *void;
    optimal: VkBool32;
}

VkMultisampledRenderToSingleSampledInfoEXT :: struct {
    sType:                                   VkStructureType;
    pNext:                                   *void;
    multisampledRenderToSingleSampledEnable: VkBool32;
    rasterizationSamples:                    VkSampleCountFlagBits;
}

VkPhysicalDeviceExtendedDynamicState2FeaturesEXT :: struct {
    sType:                                   VkStructureType;
    pNext:                                   *void;
    extendedDynamicState2:                   VkBool32;
    extendedDynamicState2LogicOp:            VkBool32;
    extendedDynamicState2PatchControlPoints: VkBool32;
}

PFN_vkCmdSetPatchControlPointsEXT :: #type (commandBuffer: VkCommandBuffer, patchControlPoints: u32) -> void #c_call;
PFN_vkCmdSetRasterizerDiscardEnableEXT :: #type (commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthBiasEnableEXT :: #type (commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetLogicOpEXT :: #type (commandBuffer: VkCommandBuffer, logicOp: VkLogicOp) -> void #c_call;
PFN_vkCmdSetPrimitiveRestartEnableEXT :: #type (commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) -> void #c_call;

VkPhysicalDeviceColorWriteEnableFeaturesEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    colorWriteEnable: VkBool32;
}

VkPipelineColorWriteCreateInfoEXT :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    attachmentCount:    u32;
    pColorWriteEnables: *VkBool32;
}

PFN_vkCmdSetColorWriteEnableEXT :: #type (commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *VkBool32) -> void #c_call;

VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT :: struct {
    sType:                                         VkStructureType;
    pNext:                                         *void;
    primitivesGeneratedQuery:                      VkBool32;
    primitivesGeneratedQueryWithRasterizerDiscard: VkBool32;
    primitivesGeneratedQueryWithNonZeroStreams:    VkBool32;
}

VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT :: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;

VkQueueFamilyGlobalPriorityPropertiesEXT :: VkQueueFamilyGlobalPriorityPropertiesKHR;

VkPhysicalDeviceImageViewMinLodFeaturesEXT :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    minLod: VkBool32;
}

VkImageViewMinLodCreateInfoEXT :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    minLod: float;
}

VkPhysicalDeviceMultiDrawFeaturesEXT :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    multiDraw: VkBool32;
}

VkPhysicalDeviceMultiDrawPropertiesEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    maxMultiDrawCount: u32;
}

VkMultiDrawInfoEXT :: struct {
    firstVertex: u32;
    vertexCount: u32;
}

VkMultiDrawIndexedInfoEXT :: struct {
    firstIndex:   u32;
    indexCount:   u32;
    vertexOffset: s32;
}

PFN_vkCmdDrawMultiEXT :: #type (commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawMultiIndexedEXT :: #type (commandBuffer: VkCommandBuffer, drawCount: u32, pIndexInfo: *VkMultiDrawIndexedInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32, pVertexOffset: *s32) -> void #c_call;

VkPhysicalDeviceImage2DViewOf3DFeaturesEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    image2DViewOf3D:   VkBool32;
    sampler2DViewOf3D: VkBool32;
}

VkPhysicalDeviceShaderTileImageFeaturesEXT :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    shaderTileImageColorReadAccess:   VkBool32;
    shaderTileImageDepthReadAccess:   VkBool32;
    shaderTileImageStencilReadAccess: VkBool32;
}

VkPhysicalDeviceShaderTileImagePropertiesEXT :: struct {
    sType:                                            VkStructureType;
    pNext:                                            *void;
    shaderTileImageCoherentReadAccelerated:           VkBool32;
    shaderTileImageReadSampleFromPixelRateInvocation: VkBool32;
    shaderTileImageReadFromHelperInvocation:          VkBool32;
}

VkMicromapEXT_T :: struct {}
VkMicromapEXT :: *VkMicromapEXT_T;

VkMicromapTypeEXT :: enum s32 {
    OPACITY_MICROMAP_EXT :: 0;

    MAX_ENUM_EXT         :: 2147483647;
}

VkBuildMicromapModeEXT :: enum s32 {
    BUILD_EXT    :: 0;
    MAX_ENUM_EXT :: 2147483647;
}

VkCopyMicromapModeEXT :: enum s32 {
    CLONE_EXT       :: 0;
    SERIALIZE_EXT   :: 1;
    DESERIALIZE_EXT :: 2;
    COMPACT_EXT     :: 3;
    MAX_ENUM_EXT    :: 2147483647;
}

VkOpacityMicromapFormatEXT :: enum s32 {
    _2_STATE_EXT :: 1;
    _4_STATE_EXT :: 2;
    MAX_ENUM_EXT :: 2147483647;
}

VkOpacityMicromapSpecialIndexEXT :: enum s32 {
    FULLY_TRANSPARENT_EXT         :: -1;
    FULLY_OPAQUE_EXT              :: -2;
    FULLY_UNKNOWN_TRANSPARENT_EXT :: -3;
    FULLY_UNKNOWN_OPAQUE_EXT      :: -4;
    MAX_ENUM_EXT                  :: 2147483647;
}

VkAccelerationStructureCompatibilityKHR :: enum s32 {
    COMPATIBLE_KHR   :: 0;
    INCOMPATIBLE_KHR :: 1;
    MAX_ENUM_KHR     :: 2147483647;
}

VkAccelerationStructureBuildTypeKHR :: enum s32 {
    HOST_KHR           :: 0;
    DEVICE_KHR         :: 1;
    HOST_OR_DEVICE_KHR :: 2;
    MAX_ENUM_KHR       :: 2147483647;
}

VkBuildMicromapFlagBitsEXT :: enum s32 {
    PREFER_FAST_TRACE_BIT_EXT :: 1;
    PREFER_FAST_BUILD_BIT_EXT :: 2;
    ALLOW_COMPACTION_BIT_EXT  :: 4;
    FLAG_BITS_MAX_ENUM_EXT    :: 2147483647;
}

VkBuildMicromapFlagsEXT :: VkFlags;

VkMicromapCreateFlagBitsEXT :: enum s32 {
    DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT :: 1;
    FLAG_BITS_MAX_ENUM_EXT                :: 2147483647;
}

VkMicromapCreateFlagsEXT :: VkFlags;
VkMicromapUsageEXT :: struct {
    count:            u32;
    subdivisionLevel: u32;
    format:           u32;
}

VkDeviceOrHostAddressKHR :: union {
    deviceAddress: VkDeviceAddress;
    hostAddress:   *void;
}

VkMicromapBuildInfoEXT :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    type:                VkMicromapTypeEXT;
    flags:               VkBuildMicromapFlagsEXT;
    mode:                VkBuildMicromapModeEXT;
    dstMicromap:         VkMicromapEXT;
    usageCountsCount:    u32;
    pUsageCounts:        *VkMicromapUsageEXT;
    ppUsageCounts:       **VkMicromapUsageEXT;
    data:                VkDeviceOrHostAddressConstKHR;
    scratchData:         VkDeviceOrHostAddressKHR;
    triangleArray:       VkDeviceOrHostAddressConstKHR;
    triangleArrayStride: VkDeviceSize;
}

VkMicromapCreateInfoEXT :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    createFlags:   VkMicromapCreateFlagsEXT;
    buffer:        VkBuffer;
    offset:        VkDeviceSize;
    size:          VkDeviceSize;
    type:          VkMicromapTypeEXT;
    deviceAddress: VkDeviceAddress;
}

VkPhysicalDeviceOpacityMicromapFeaturesEXT :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    micromap:              VkBool32;
    micromapCaptureReplay: VkBool32;
    micromapHostCommands:  VkBool32;
}

VkPhysicalDeviceOpacityMicromapPropertiesEXT :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    maxOpacity2StateSubdivisionLevel: u32;
    maxOpacity4StateSubdivisionLevel: u32;
}

VkMicromapVersionInfoEXT :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    pVersionData: *u8;
}

VkCopyMicromapToMemoryInfoEXT :: struct {
    sType: VkStructureType;
    pNext: *void;
    src:   VkMicromapEXT;
    dst:   VkDeviceOrHostAddressKHR;
    mode:  VkCopyMicromapModeEXT;
}

VkCopyMemoryToMicromapInfoEXT :: struct {
    sType: VkStructureType;
    pNext: *void;
    src:   VkDeviceOrHostAddressConstKHR;
    dst:   VkMicromapEXT;
    mode:  VkCopyMicromapModeEXT;
}

VkCopyMicromapInfoEXT :: struct {
    sType: VkStructureType;
    pNext: *void;
    src:   VkMicromapEXT;
    dst:   VkMicromapEXT;
    mode:  VkCopyMicromapModeEXT;
}

VkMicromapBuildSizesInfoEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    micromapSize:     VkDeviceSize;
    buildScratchSize: VkDeviceSize;
    discardable:      VkBool32;
}

VkAccelerationStructureTrianglesOpacityMicromapEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    indexType:        VkIndexType;
    indexBuffer:      VkDeviceOrHostAddressConstKHR;
    indexStride:      VkDeviceSize;
    baseTriangle:     u32;
    usageCountsCount: u32;
    pUsageCounts:     *VkMicromapUsageEXT;
    ppUsageCounts:    **VkMicromapUsageEXT;
    micromap:         VkMicromapEXT;
}

VkMicromapTriangleEXT :: struct {
    dataOffset:       u32;
    subdivisionLevel: u16;
    format:           u16;
}

PFN_vkCreateMicromapEXT :: #type (device: VkDevice, pCreateInfo: *VkMicromapCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pMicromap: *VkMicromapEXT) -> VkResult #c_call;
PFN_vkDestroyMicromapEXT :: #type (device: VkDevice, micromap: VkMicromapEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCmdBuildMicromapsEXT :: #type (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkMicromapBuildInfoEXT) -> void #c_call;
PFN_vkBuildMicromapsEXT :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *VkMicromapBuildInfoEXT) -> VkResult #c_call;
PFN_vkCopyMicromapEXT :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMicromapInfoEXT) -> VkResult #c_call;
PFN_vkCopyMicromapToMemoryEXT :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMicromapToMemoryInfoEXT) -> VkResult #c_call;
PFN_vkCopyMemoryToMicromapEXT :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMemoryToMicromapInfoEXT) -> VkResult #c_call;
PFN_vkWriteMicromapsPropertiesEXT :: #type (device: VkDevice, micromapCount: u32, pMicromaps: *VkMicromapEXT, queryType: VkQueryType, dataSize: u64, pData: *void, stride: u64) -> VkResult #c_call;
PFN_vkCmdCopyMicromapEXT :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMicromapInfoEXT) -> void #c_call;
PFN_vkCmdCopyMicromapToMemoryEXT :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMicromapToMemoryInfoEXT) -> void #c_call;
PFN_vkCmdCopyMemoryToMicromapEXT :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMemoryToMicromapInfoEXT) -> void #c_call;
PFN_vkCmdWriteMicromapsPropertiesEXT :: #type (commandBuffer: VkCommandBuffer, micromapCount: u32, pMicromaps: *VkMicromapEXT, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) -> void #c_call;
PFN_vkGetDeviceMicromapCompatibilityEXT :: #type (device: VkDevice, pVersionInfo: *VkMicromapVersionInfoEXT, pCompatibility: *VkAccelerationStructureCompatibilityKHR) -> void #c_call;
PFN_vkGetMicromapBuildSizesEXT :: #type (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *VkMicromapBuildInfoEXT, pSizeInfo: *VkMicromapBuildSizesInfoEXT) -> void #c_call;

VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    clustercullingShader:          VkBool32;
    multiviewClusterCullingShader: VkBool32;
}

VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    maxWorkGroupCount:             [3] u32;
    maxWorkGroupSize:              [3] u32;
    maxOutputClusterCount:         u32;
    indirectBufferOffsetAlignment: VkDeviceSize;
}

PFN_vkCmdDrawClusterHUAWEI :: #type (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;
PFN_vkCmdDrawClusterIndirectHUAWEI :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) -> void #c_call;

VkPhysicalDeviceBorderColorSwizzleFeaturesEXT :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    borderColorSwizzle:          VkBool32;
    borderColorSwizzleFromImage: VkBool32;
}

VkSamplerBorderColorComponentMappingCreateInfoEXT :: struct {
    sType:      VkStructureType;
    pNext:      *void;
    components: VkComponentMapping;
    srgb:       VkBool32;
}

VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    pageableDeviceLocalMemory: VkBool32;
}

PFN_vkSetDeviceMemoryPriorityEXT :: #type (device: VkDevice, memory: VkDeviceMemory, priority: float) -> void #c_call;

VkPhysicalDeviceShaderCorePropertiesARM :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    pixelRate: u32;
    texelRate: u32;
    fmaRate:   u32;
}

VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    imageSlicedViewOf3D: VkBool32;
}

VkImageViewSlicedCreateInfoEXT :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    sliceOffset: u32;
    sliceCount:  u32;
}

VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    descriptorSetHostMapping: VkBool32;
}

VkDescriptorSetBindingReferenceVALVE :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    descriptorSetLayout: VkDescriptorSetLayout;
    binding:             u32;
}

VkDescriptorSetLayoutHostMappingInfoVALVE :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    descriptorOffset: u64;
    descriptorSize:   u32;
}

PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE :: #type (device: VkDevice, pBindingReference: *VkDescriptorSetBindingReferenceVALVE, pHostMapping: *VkDescriptorSetLayoutHostMappingInfoVALVE) -> void #c_call;
PFN_vkGetDescriptorSetHostMappingVALVE :: #type (device: VkDevice, descriptorSet: VkDescriptorSet, ppData: **void) -> void #c_call;

VkPhysicalDeviceDepthClampZeroOneFeaturesEXT :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    depthClampZeroOne: VkBool32;
}

VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    nonSeamlessCubeMap: VkBool32;
}

VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    fragmentDensityMapOffset: VkBool32;
}

VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    fragmentDensityOffsetGranularity: VkExtent2D;
}

VkSubpassFragmentDensityMapOffsetEndInfoQCOM :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    fragmentDensityOffsetCount: u32;
    pFragmentDensityOffsets:    *VkOffset2D;
}

VkCopyMemoryIndirectCommandNV :: struct {
    srcAddress: VkDeviceAddress;
    dstAddress: VkDeviceAddress;
    size:       VkDeviceSize;
}

VkCopyMemoryToImageIndirectCommandNV :: struct {
    srcAddress:        VkDeviceAddress;
    bufferRowLength:   u32;
    bufferImageHeight: u32;
    imageSubresource:  VkImageSubresourceLayers;
    imageOffset:       VkOffset3D;
    imageExtent:       VkExtent3D;
}

VkPhysicalDeviceCopyMemoryIndirectFeaturesNV :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    indirectCopy: VkBool32;
}

VkPhysicalDeviceCopyMemoryIndirectPropertiesNV :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    supportedQueues: VkQueueFlags;
}

PFN_vkCmdCopyMemoryIndirectNV :: #type (commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdCopyMemoryToImageIndirectNV :: #type (commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32, dstImage: VkImage, dstImageLayout: VkImageLayout, pImageSubresources: *VkImageSubresourceLayers) -> void #c_call;

// Flag bits for VkMemoryDecompressionMethodFlagBitsNV
VkMemoryDecompressionMethodFlagBitsNV :: VkFlags64;
VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV: VkMemoryDecompressionMethodFlagBitsNV : 1;

VkMemoryDecompressionMethodFlagsNV :: VkFlags64;
VkDecompressMemoryRegionNV :: struct {
    srcAddress:          VkDeviceAddress;
    dstAddress:          VkDeviceAddress;
    compressedSize:      VkDeviceSize;
    decompressedSize:    VkDeviceSize;
    decompressionMethod: VkMemoryDecompressionMethodFlagsNV;
}

VkPhysicalDeviceMemoryDecompressionFeaturesNV :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    memoryDecompression: VkBool32;
}

VkPhysicalDeviceMemoryDecompressionPropertiesNV :: struct {
    sType:                         VkStructureType;
    pNext:                         *void;
    decompressionMethods:          VkMemoryDecompressionMethodFlagsNV;
    maxDecompressionIndirectCount: u64;
}

PFN_vkCmdDecompressMemoryNV :: #type (commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *VkDecompressMemoryRegionNV) -> void #c_call;
PFN_vkCmdDecompressMemoryIndirectCountNV :: #type (commandBuffer: VkCommandBuffer, indirectCommandsAddress: VkDeviceAddress, indirectCommandsCountAddress: VkDeviceAddress, stride: u32) -> void #c_call;

VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV :: struct {
    sType:                               VkStructureType;
    pNext:                               *void;
    deviceGeneratedCompute:              VkBool32;
    deviceGeneratedComputePipelines:     VkBool32;
    deviceGeneratedComputeCaptureReplay: VkBool32;
}

VkComputePipelineIndirectBufferInfoNV :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    deviceAddress:                      VkDeviceAddress;
    size:                               VkDeviceSize;
    pipelineDeviceAddressCaptureReplay: VkDeviceAddress;
}

VkPipelineIndirectDeviceAddressInfoNV :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    pipelineBindPoint: VkPipelineBindPoint;
    pipeline:          VkPipeline;
}

VkBindPipelineIndirectCommandNV :: struct {
    pipelineAddress: VkDeviceAddress;
}

PFN_vkGetPipelineIndirectMemoryRequirementsNV :: #type (device: VkDevice, pCreateInfo: *VkComputePipelineCreateInfo, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkCmdUpdatePipelineIndirectBufferNV :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) -> void #c_call;
PFN_vkGetPipelineIndirectDeviceAddressNV :: #type (device: VkDevice, pInfo: *VkPipelineIndirectDeviceAddressInfoNV) -> VkDeviceAddress #c_call;

VkPhysicalDeviceLinearColorAttachmentFeaturesNV :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    linearColorAttachment: VkBool32;
}

VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT :: struct {
    sType:                            VkStructureType;
    pNext:                            *void;
    imageCompressionControlSwapchain: VkBool32;
}

VkImageViewSampleWeightCreateInfoQCOM :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    filterCenter: VkOffset2D;
    filterSize:   VkExtent2D;
    numPhases:    u32;
}

VkPhysicalDeviceImageProcessingFeaturesQCOM :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    textureSampleWeighted: VkBool32;
    textureBoxFilter:      VkBool32;
    textureBlockMatch:     VkBool32;
}

VkPhysicalDeviceImageProcessingPropertiesQCOM :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    maxWeightFilterPhases:    u32;
    maxWeightFilterDimension: VkExtent2D;
    maxBlockMatchRegion:      VkExtent2D;
    maxBoxFilterBlockSize:    VkExtent2D;
}

VkPhysicalDeviceNestedCommandBufferFeaturesEXT :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    nestedCommandBuffer:                VkBool32;
    nestedCommandBufferRendering:       VkBool32;
    nestedCommandBufferSimultaneousUse: VkBool32;
}

VkPhysicalDeviceNestedCommandBufferPropertiesEXT :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    maxCommandBufferNestingLevel: u32;
}

VkExternalMemoryAcquireUnmodifiedEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    acquireUnmodifiedMemory: VkBool32;
}

VkPhysicalDeviceExtendedDynamicState3FeaturesEXT :: struct {
    sType:                                                 VkStructureType;
    pNext:                                                 *void;
    extendedDynamicState3TessellationDomainOrigin:         VkBool32;
    extendedDynamicState3DepthClampEnable:                 VkBool32;
    extendedDynamicState3PolygonMode:                      VkBool32;
    extendedDynamicState3RasterizationSamples:             VkBool32;
    extendedDynamicState3SampleMask:                       VkBool32;
    extendedDynamicState3AlphaToCoverageEnable:            VkBool32;
    extendedDynamicState3AlphaToOneEnable:                 VkBool32;
    extendedDynamicState3LogicOpEnable:                    VkBool32;
    extendedDynamicState3ColorBlendEnable:                 VkBool32;
    extendedDynamicState3ColorBlendEquation:               VkBool32;
    extendedDynamicState3ColorWriteMask:                   VkBool32;
    extendedDynamicState3RasterizationStream:              VkBool32;
    extendedDynamicState3ConservativeRasterizationMode:    VkBool32;
    extendedDynamicState3ExtraPrimitiveOverestimationSize: VkBool32;
    extendedDynamicState3DepthClipEnable:                  VkBool32;
    extendedDynamicState3SampleLocationsEnable:            VkBool32;
    extendedDynamicState3ColorBlendAdvanced:               VkBool32;
    extendedDynamicState3ProvokingVertexMode:              VkBool32;
    extendedDynamicState3LineRasterizationMode:            VkBool32;
    extendedDynamicState3LineStippleEnable:                VkBool32;
    extendedDynamicState3DepthClipNegativeOneToOne:        VkBool32;
    extendedDynamicState3ViewportWScalingEnable:           VkBool32;
    extendedDynamicState3ViewportSwizzle:                  VkBool32;
    extendedDynamicState3CoverageToColorEnable:            VkBool32;
    extendedDynamicState3CoverageToColorLocation:          VkBool32;
    extendedDynamicState3CoverageModulationMode:           VkBool32;
    extendedDynamicState3CoverageModulationTableEnable:    VkBool32;
    extendedDynamicState3CoverageModulationTable:          VkBool32;
    extendedDynamicState3CoverageReductionMode:            VkBool32;
    extendedDynamicState3RepresentativeFragmentTestEnable: VkBool32;
    extendedDynamicState3ShadingRateImageEnable:           VkBool32;
}

VkPhysicalDeviceExtendedDynamicState3PropertiesEXT :: struct {
    sType:                                VkStructureType;
    pNext:                                *void;
    dynamicPrimitiveTopologyUnrestricted: VkBool32;
}

VkColorBlendEquationEXT :: struct {
    srcColorBlendFactor: VkBlendFactor;
    dstColorBlendFactor: VkBlendFactor;
    colorBlendOp:        VkBlendOp;
    srcAlphaBlendFactor: VkBlendFactor;
    dstAlphaBlendFactor: VkBlendFactor;
    alphaBlendOp:        VkBlendOp;
}

VkColorBlendAdvancedEXT :: struct {
    advancedBlendOp:  VkBlendOp;
    srcPremultiplied: VkBool32;
    dstPremultiplied: VkBool32;
    blendOverlap:     VkBlendOverlapEXT;
    clampResults:     VkBool32;
}

PFN_vkCmdSetTessellationDomainOriginEXT :: #type (commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin) -> void #c_call;
PFN_vkCmdSetDepthClampEnableEXT :: #type (commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetPolygonModeEXT :: #type (commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode) -> void #c_call;
PFN_vkCmdSetRasterizationSamplesEXT :: #type (commandBuffer: VkCommandBuffer, rasterizationSamples: VkSampleCountFlagBits) -> void #c_call;
PFN_vkCmdSetSampleMaskEXT :: #type (commandBuffer: VkCommandBuffer, samples: VkSampleCountFlagBits, pSampleMask: *VkSampleMask) -> void #c_call;
PFN_vkCmdSetAlphaToCoverageEnableEXT :: #type (commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetAlphaToOneEnableEXT :: #type (commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetLogicOpEnableEXT :: #type (commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetColorBlendEnableEXT :: #type (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEnables: *VkBool32) -> void #c_call;
PFN_vkCmdSetColorBlendEquationEXT :: #type (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEquations: *VkColorBlendEquationEXT) -> void #c_call;
PFN_vkCmdSetColorWriteMaskEXT :: #type (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorWriteMasks: *VkColorComponentFlags) -> void #c_call;
PFN_vkCmdSetRasterizationStreamEXT :: #type (commandBuffer: VkCommandBuffer, rasterizationStream: u32) -> void #c_call;
PFN_vkCmdSetConservativeRasterizationModeEXT :: #type (commandBuffer: VkCommandBuffer, conservativeRasterizationMode: VkConservativeRasterizationModeEXT) -> void #c_call;
PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT :: #type (commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: float) -> void #c_call;
PFN_vkCmdSetDepthClipEnableEXT :: #type (commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetSampleLocationsEnableEXT :: #type (commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetColorBlendAdvancedEXT :: #type (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendAdvanced: *VkColorBlendAdvancedEXT) -> void #c_call;
PFN_vkCmdSetProvokingVertexModeEXT :: #type (commandBuffer: VkCommandBuffer, provokingVertexMode: VkProvokingVertexModeEXT) -> void #c_call;
PFN_vkCmdSetLineRasterizationModeEXT :: #type (commandBuffer: VkCommandBuffer, lineRasterizationMode: VkLineRasterizationModeEXT) -> void #c_call;
PFN_vkCmdSetLineStippleEnableEXT :: #type (commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthClipNegativeOneToOneEXT :: #type (commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32) -> void #c_call;
PFN_vkCmdSetViewportWScalingEnableNV :: #type (commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetViewportSwizzleNV :: #type (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportSwizzles: *VkViewportSwizzleNV) -> void #c_call;
PFN_vkCmdSetCoverageToColorEnableNV :: #type (commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetCoverageToColorLocationNV :: #type (commandBuffer: VkCommandBuffer, coverageToColorLocation: u32) -> void #c_call;
PFN_vkCmdSetCoverageModulationModeNV :: #type (commandBuffer: VkCommandBuffer, coverageModulationMode: VkCoverageModulationModeNV) -> void #c_call;
PFN_vkCmdSetCoverageModulationTableEnableNV :: #type (commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetCoverageModulationTableNV :: #type (commandBuffer: VkCommandBuffer, coverageModulationTableCount: u32, pCoverageModulationTable: *float) -> void #c_call;
PFN_vkCmdSetShadingRateImageEnableNV :: #type (commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetRepresentativeFragmentTestEnableNV :: #type (commandBuffer: VkCommandBuffer, representativeFragmentTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetCoverageReductionModeNV :: #type (commandBuffer: VkCommandBuffer, coverageReductionMode: VkCoverageReductionModeNV) -> void #c_call;

VkSubpassMergeStatusEXT :: enum s32 {
    MERGED_EXT                                   :: 0;
    DISALLOWED_EXT                               :: 1;
    NOT_MERGED_SIDE_EFFECTS_EXT                  :: 2;
    NOT_MERGED_SAMPLES_MISMATCH_EXT              :: 3;
    NOT_MERGED_VIEWS_MISMATCH_EXT                :: 4;
    NOT_MERGED_ALIASING_EXT                      :: 5;
    NOT_MERGED_DEPENDENCIES_EXT                  :: 6;
    NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT :: 7;
    NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT          :: 8;
    NOT_MERGED_INSUFFICIENT_STORAGE_EXT          :: 9;
    NOT_MERGED_DEPTH_STENCIL_COUNT_EXT           :: 10;
    NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT      :: 11;
    NOT_MERGED_SINGLE_SUBPASS_EXT                :: 12;
    NOT_MERGED_UNSPECIFIED_EXT                   :: 13;
    MAX_ENUM_EXT                                 :: 2147483647;
}

VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT :: struct {
    sType:                VkStructureType;
    pNext:                *void;
    subpassMergeFeedback: VkBool32;
}

VkRenderPassCreationControlEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    disallowMerging: VkBool32;
}

VkRenderPassCreationFeedbackInfoEXT :: struct {
    postMergeSubpassCount: u32;
}

VkRenderPassCreationFeedbackCreateInfoEXT :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    pRenderPassFeedback: *VkRenderPassCreationFeedbackInfoEXT;
}

VkRenderPassSubpassFeedbackInfoEXT :: struct {
    subpassMergeStatus: VkSubpassMergeStatusEXT;
    description:        [256] u8;
    postMergeIndex:     u32;
}

VkRenderPassSubpassFeedbackCreateInfoEXT :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    pSubpassFeedback: *VkRenderPassSubpassFeedbackInfoEXT;
}

VkDirectDriverLoadingModeLUNARG :: enum s32 {
    EXCLUSIVE_LUNARG :: 0;
    INCLUSIVE_LUNARG :: 1;
    MAX_ENUM_LUNARG  :: 2147483647;
}

VkDirectDriverLoadingFlagsLUNARG :: VkFlags;
PFN_vkGetInstanceProcAddrLUNARG :: #type (instance: VkInstance, pName: *u8) -> PFN_vkVoidFunction #c_call;

VkDirectDriverLoadingInfoLUNARG :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    flags:                  VkDirectDriverLoadingFlagsLUNARG;
    pfnGetInstanceProcAddr: PFN_vkGetInstanceProcAddrLUNARG;
}

VkDirectDriverLoadingListLUNARG :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    mode:        VkDirectDriverLoadingModeLUNARG;
    driverCount: u32;
    pDrivers:    *VkDirectDriverLoadingInfoLUNARG;
}

VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    shaderModuleIdentifier: VkBool32;
}

VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT :: struct {
    sType:                               VkStructureType;
    pNext:                               *void;
    shaderModuleIdentifierAlgorithmUUID: [16] u8;
}

VkPipelineShaderStageModuleIdentifierCreateInfoEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    identifierSize: u32;
    pIdentifier:    *u8;
}

VkShaderModuleIdentifierEXT :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    identifierSize: u32;
    identifier:     [32] u8;
}

PFN_vkGetShaderModuleIdentifierEXT :: #type (device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *VkShaderModuleIdentifierEXT) -> void #c_call;
PFN_vkGetShaderModuleCreateInfoIdentifierEXT :: #type (device: VkDevice, pCreateInfo: *VkShaderModuleCreateInfo, pIdentifier: *VkShaderModuleIdentifierEXT) -> void #c_call;

VkOpticalFlowSessionNV_T :: struct {}
VkOpticalFlowSessionNV :: *VkOpticalFlowSessionNV_T;

VkOpticalFlowPerformanceLevelNV :: enum s32 {
    UNKNOWN_NV  :: 0;
    SLOW_NV     :: 1;
    MEDIUM_NV   :: 2;
    FAST_NV     :: 3;
    MAX_ENUM_NV :: 2147483647;
}

VkOpticalFlowSessionBindingPointNV :: enum s32 {
    UNKNOWN_NV              :: 0;
    INPUT_NV                :: 1;
    REFERENCE_NV            :: 2;
    HINT_NV                 :: 3;
    FLOW_VECTOR_NV          :: 4;
    BACKWARD_FLOW_VECTOR_NV :: 5;
    COST_NV                 :: 6;
    BACKWARD_COST_NV        :: 7;
    GLOBAL_FLOW_NV          :: 8;
    MAX_ENUM_NV             :: 2147483647;
}

VkOpticalFlowGridSizeFlagBitsNV :: enum s32 {
    UNKNOWN_NV            :: 0;
    _1X1_BIT_NV           :: 1;
    _2X2_BIT_NV           :: 2;
    _4X4_BIT_NV           :: 4;
    _8X8_BIT_NV           :: 8;
    FLAG_BITS_MAX_ENUM_NV :: 2147483647;
}

VkOpticalFlowGridSizeFlagsNV :: VkFlags;

VkOpticalFlowUsageFlagBitsNV :: enum s32 {
    UNKNOWN_NV            :: 0;
    INPUT_BIT_NV          :: 1;
    OUTPUT_BIT_NV         :: 2;
    HINT_BIT_NV           :: 4;
    COST_BIT_NV           :: 8;
    GLOBAL_FLOW_BIT_NV    :: 16;
    FLAG_BITS_MAX_ENUM_NV :: 2147483647;
}

VkOpticalFlowUsageFlagsNV :: VkFlags;

VkOpticalFlowSessionCreateFlagBitsNV :: enum s32 {
    ENABLE_HINT_BIT_NV        :: 1;
    ENABLE_COST_BIT_NV        :: 2;
    ENABLE_GLOBAL_FLOW_BIT_NV :: 4;
    ALLOW_REGIONS_BIT_NV      :: 8;
    BOTH_DIRECTIONS_BIT_NV    :: 16;
    FLAG_BITS_MAX_ENUM_NV     :: 2147483647;
}

VkOpticalFlowSessionCreateFlagsNV :: VkFlags;

VkOpticalFlowExecuteFlagBitsNV :: enum s32 {
    DISABLE_TEMPORAL_HINTS_BIT_NV :: 1;
    FLAG_BITS_MAX_ENUM_NV         :: 2147483647;
}

VkOpticalFlowExecuteFlagsNV :: VkFlags;
VkPhysicalDeviceOpticalFlowFeaturesNV :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    opticalFlow: VkBool32;
}

VkPhysicalDeviceOpticalFlowPropertiesNV :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    supportedOutputGridSizes:   VkOpticalFlowGridSizeFlagsNV;
    supportedHintGridSizes:     VkOpticalFlowGridSizeFlagsNV;
    hintSupported:              VkBool32;
    costSupported:              VkBool32;
    bidirectionalFlowSupported: VkBool32;
    globalFlowSupported:        VkBool32;
    minWidth:                   u32;
    minHeight:                  u32;
    maxWidth:                   u32;
    maxHeight:                  u32;
    maxNumRegionsOfInterest:    u32;
}

VkOpticalFlowImageFormatInfoNV :: struct {
    sType: VkStructureType;
    pNext: *void;
    usage: VkOpticalFlowUsageFlagsNV;
}

VkOpticalFlowImageFormatPropertiesNV :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    format: VkFormat;
}

VkOpticalFlowSessionCreateInfoNV :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    width:            u32;
    height:           u32;
    imageFormat:      VkFormat;
    flowVectorFormat: VkFormat;
    costFormat:       VkFormat;
    outputGridSize:   VkOpticalFlowGridSizeFlagsNV;
    hintGridSize:     VkOpticalFlowGridSizeFlagsNV;
    performanceLevel: VkOpticalFlowPerformanceLevelNV;
    flags:            VkOpticalFlowSessionCreateFlagsNV;
}

VkOpticalFlowSessionCreatePrivateDataInfoNV :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    id:           u32;
    size:         u32;
    pPrivateData: *void;
}

VkOpticalFlowExecuteInfoNV :: struct {
    sType:       VkStructureType;
    pNext:       *void;
    flags:       VkOpticalFlowExecuteFlagsNV;
    regionCount: u32;
    pRegions:    *VkRect2D;
}

PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV :: #type (physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *VkOpticalFlowImageFormatInfoNV, pFormatCount: *u32, pImageFormatProperties: *VkOpticalFlowImageFormatPropertiesNV) -> VkResult #c_call;
PFN_vkCreateOpticalFlowSessionNV :: #type (device: VkDevice, pCreateInfo: *VkOpticalFlowSessionCreateInfoNV, pAllocator: *VkAllocationCallbacks, pSession: *VkOpticalFlowSessionNV) -> VkResult #c_call;
PFN_vkDestroyOpticalFlowSessionNV :: #type (device: VkDevice, session: VkOpticalFlowSessionNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkBindOpticalFlowSessionImageNV :: #type (device: VkDevice, session: VkOpticalFlowSessionNV, bindingPoint: VkOpticalFlowSessionBindingPointNV, view: VkImageView, layout: VkImageLayout) -> VkResult #c_call;
PFN_vkCmdOpticalFlowExecuteNV :: #type (commandBuffer: VkCommandBuffer, session: VkOpticalFlowSessionNV, pExecuteInfo: *VkOpticalFlowExecuteInfoNV) -> void #c_call;

VkPhysicalDeviceLegacyDitheringFeaturesEXT :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    legacyDithering: VkBool32;
}

VkPhysicalDevicePipelineProtectedAccessFeaturesEXT :: struct {
    sType:                   VkStructureType;
    pNext:                   *void;
    pipelineProtectedAccess: VkBool32;
}

VkShaderEXT_T :: struct {}
VkShaderEXT :: *VkShaderEXT_T;

VkShaderCodeTypeEXT :: enum s32 {
    BINARY_EXT   :: 0;
    SPIRV_EXT    :: 1;
    MAX_ENUM_EXT :: 2147483647;
}

VkShaderCreateFlagBitsEXT :: enum s32 {
    LINK_STAGE_BIT_EXT                       :: 1;
    ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT      :: 2;
    REQUIRE_FULL_SUBGROUPS_BIT_EXT           :: 4;
    NO_TASK_SHADER_BIT_EXT                   :: 8;
    DISPATCH_BASE_BIT_EXT                    :: 16;
    FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT :: 32;
    FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT  :: 64;
    FLAG_BITS_MAX_ENUM_EXT                   :: 2147483647;
}

VkShaderCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceShaderObjectFeaturesEXT :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    shaderObject: VkBool32;
}

VkPhysicalDeviceShaderObjectPropertiesEXT :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    shaderBinaryUUID:    [16] u8;
    shaderBinaryVersion: u32;
}

VkShaderCreateInfoEXT :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    flags:                  VkShaderCreateFlagsEXT;
    stage:                  VkShaderStageFlagBits;
    nextStage:              VkShaderStageFlags;
    codeType:               VkShaderCodeTypeEXT;
    codeSize:               u64;
    pCode:                  *void;
    pName:                  *u8;
    setLayoutCount:         u32;
    pSetLayouts:            *VkDescriptorSetLayout;
    pushConstantRangeCount: u32;
    pPushConstantRanges:    *VkPushConstantRange;
    pSpecializationInfo:    *VkSpecializationInfo;
}

VkShaderRequiredSubgroupSizeCreateInfoEXT :: VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;

PFN_vkCreateShadersEXT :: #type (device: VkDevice, createInfoCount: u32, pCreateInfos: *VkShaderCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pShaders: *VkShaderEXT) -> VkResult #c_call;
PFN_vkDestroyShaderEXT :: #type (device: VkDevice, shader: VkShaderEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetShaderBinaryDataEXT :: #type (device: VkDevice, shader: VkShaderEXT, pDataSize: *u64, pData: *void) -> VkResult #c_call;
PFN_vkCmdBindShadersEXT :: #type (commandBuffer: VkCommandBuffer, stageCount: u32, pStages: *VkShaderStageFlagBits, pShaders: *VkShaderEXT) -> void #c_call;

VkPhysicalDeviceTilePropertiesFeaturesQCOM :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    tileProperties: VkBool32;
}

VkTilePropertiesQCOM :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    tileSize:  VkExtent3D;
    apronSize: VkExtent2D;
    origin:    VkOffset2D;
}

PFN_vkGetFramebufferTilePropertiesQCOM :: #type (device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *u32, pProperties: *VkTilePropertiesQCOM) -> VkResult #c_call;
PFN_vkGetDynamicRenderingTilePropertiesQCOM :: #type (device: VkDevice, pRenderingInfo: *VkRenderingInfo, pProperties: *VkTilePropertiesQCOM) -> VkResult #c_call;

VkPhysicalDeviceAmigoProfilingFeaturesSEC :: struct {
    sType:          VkStructureType;
    pNext:          *void;
    amigoProfiling: VkBool32;
}

VkAmigoProfilingSubmitInfoSEC :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    firstDrawTimestamp:  u64;
    swapBufferTimestamp: u64;
}

VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    multiviewPerViewViewports: VkBool32;
}

VkRayTracingInvocationReorderModeNV :: enum s32 {
    NONE_NV     :: 0;
    REORDER_NV  :: 1;
    MAX_ENUM_NV :: 2147483647;
}

VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV :: struct {
    sType:                                     VkStructureType;
    pNext:                                     *void;
    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeNV;
}

VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    rayTracingInvocationReorder: VkBool32;
}

VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    extendedSparseAddressSpace: VkBool32;
}

VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    extendedSparseAddressSpaceSize: VkDeviceSize;
    extendedSparseImageUsageFlags:  VkImageUsageFlags;
    extendedSparseBufferUsageFlags: VkBufferUsageFlags;
}

VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    shaderCoreBuiltins: VkBool32;
}

VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    shaderCoreMask:     u64;
    shaderCoreCount:    u32;
    shaderWarpsPerCore: u32;
}

VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    pipelineLibraryGroupHandles: VkBool32;
}

VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT :: struct {
    sType:                             VkStructureType;
    pNext:                             *void;
    dynamicRenderingUnusedAttachments: VkBool32;
}

VkLatencyMarkerNV :: enum s32 {
    SIMULATION_START_NV               :: 0;
    SIMULATION_END_NV                 :: 1;
    RENDERSUBMIT_START_NV             :: 2;
    RENDERSUBMIT_END_NV               :: 3;
    PRESENT_START_NV                  :: 4;
    PRESENT_END_NV                    :: 5;
    INPUT_SAMPLE_NV                   :: 6;
    TRIGGER_FLASH_NV                  :: 7;
    OUT_OF_BAND_RENDERSUBMIT_START_NV :: 8;
    OUT_OF_BAND_RENDERSUBMIT_END_NV   :: 9;
    OUT_OF_BAND_PRESENT_START_NV      :: 10;
    OUT_OF_BAND_PRESENT_END_NV        :: 11;
    MAX_ENUM_NV                       :: 2147483647;
}

VkOutOfBandQueueTypeNV :: enum s32 {
    RENDER_NV   :: 0;
    PRESENT_NV  :: 1;
    MAX_ENUM_NV :: 2147483647;
}

VkLatencySleepModeInfoNV :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    lowLatencyMode:    VkBool32;
    lowLatencyBoost:   VkBool32;
    minimumIntervalUs: u32;
}

VkLatencySleepInfoNV :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    signalSemaphore: VkSemaphore;
    value:           u64;
}

VkSetLatencyMarkerInfoNV :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    presentID: u64;
    marker:    VkLatencyMarkerNV;
}

VkLatencyTimingsFrameReportNV :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    presentID:                u64;
    inputSampleTimeUs:        u64;
    simStartTimeUs:           u64;
    simEndTimeUs:             u64;
    renderSubmitStartTimeUs:  u64;
    renderSubmitEndTimeUs:    u64;
    presentStartTimeUs:       u64;
    presentEndTimeUs:         u64;
    driverStartTimeUs:        u64;
    driverEndTimeUs:          u64;
    osRenderQueueStartTimeUs: u64;
    osRenderQueueEndTimeUs:   u64;
    gpuRenderStartTimeUs:     u64;
    gpuRenderEndTimeUs:       u64;
}

VkGetLatencyMarkerInfoNV :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    pTimings: *VkLatencyTimingsFrameReportNV;
}

VkLatencySubmissionPresentIdNV :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    presentID: u64;
}

VkSwapchainLatencyCreateInfoNV :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    latencyModeEnable: VkBool32;
}

VkOutOfBandQueueTypeInfoNV :: struct {
    sType:     VkStructureType;
    pNext:     *void;
    queueType: VkOutOfBandQueueTypeNV;
}

VkLatencySurfaceCapabilitiesNV :: struct {
    sType:            VkStructureType;
    pNext:            *void;
    presentModeCount: u32;
    pPresentModes:    *VkPresentModeKHR;
}

PFN_vkSetLatencySleepModeNV :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *VkLatencySleepModeInfoNV) -> VkResult #c_call;
PFN_vkLatencySleepNV :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pSleepInfo: *VkLatencySleepInfoNV) -> VkResult #c_call;
PFN_vkSetLatencyMarkerNV :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: *VkSetLatencyMarkerInfoNV) -> void #c_call;
PFN_vkGetLatencyTimingsNV :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pTimingCount: *u32, pLatencyMarkerInfo: *VkGetLatencyMarkerInfoNV) -> void #c_call;
PFN_vkQueueNotifyOutOfBandNV :: #type (queue: VkQueue, pQueueTypeInfo: *VkOutOfBandQueueTypeInfoNV) -> void #c_call;

VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM :: struct {
    sType:                       VkStructureType;
    pNext:                       *void;
    multiviewPerViewRenderAreas: VkBool32;
}

VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    perViewRenderAreaCount: u32;
    pPerViewRenderAreas:    *VkRect2D;
}

VkBlockMatchWindowCompareModeQCOM :: enum s32 {
    MIN_QCOM      :: 0;
    MAX_QCOM      :: 1;
    MAX_ENUM_QCOM :: 2147483647;
}

VkPhysicalDeviceImageProcessing2FeaturesQCOM :: struct {
    sType:              VkStructureType;
    pNext:              *void;
    textureBlockMatch2: VkBool32;
}

VkPhysicalDeviceImageProcessing2PropertiesQCOM :: struct {
    sType:               VkStructureType;
    pNext:               *void;
    maxBlockMatchWindow: VkExtent2D;
}

VkSamplerBlockMatchWindowCreateInfoQCOM :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    windowExtent:      VkExtent2D;
    windowCompareMode: VkBlockMatchWindowCompareModeQCOM;
}

VkCubicFilterWeightsQCOM :: enum s32 {
    CATMULL_ROM_QCOM           :: 0;
    ZERO_TANGENT_CARDINAL_QCOM :: 1;
    B_SPLINE_QCOM              :: 2;
    MITCHELL_NETRAVALI_QCOM    :: 3;
    MAX_ENUM_QCOM              :: 2147483647;
}

VkPhysicalDeviceCubicWeightsFeaturesQCOM :: struct {
    sType:                  VkStructureType;
    pNext:                  *void;
    selectableCubicWeights: VkBool32;
}

VkSamplerCubicWeightsCreateInfoQCOM :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    cubicWeights: VkCubicFilterWeightsQCOM;
}

VkBlitImageCubicWeightsInfoQCOM :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    cubicWeights: VkCubicFilterWeightsQCOM;
}

VkPhysicalDeviceYcbcrDegammaFeaturesQCOM :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    ycbcrDegamma: VkBool32;
}

VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM :: struct {
    sType:             VkStructureType;
    pNext:             *void;
    enableYDegamma:    VkBool32;
    enableCbCrDegamma: VkBool32;
}

VkPhysicalDeviceCubicClampFeaturesQCOM :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    cubicRangeClamp: VkBool32;
}

VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    attachmentFeedbackLoopDynamicState: VkBool32;
}

PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT :: #type (commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) -> void #c_call;

VkLayeredDriverUnderlyingApiMSFT :: enum s32 {
    NONE_MSFT     :: 0;
    D3D12_MSFT    :: 1;
    MAX_ENUM_MSFT :: 2147483647;
}

VkPhysicalDeviceLayeredDriverPropertiesMSFT :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    underlyingAPI: VkLayeredDriverUnderlyingApiMSFT;
}

VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    descriptorPoolOverallocation: VkBool32;
}

VkBuildAccelerationStructureModeKHR :: enum s32 {
    BUILD_KHR    :: 0;
    UPDATE_KHR   :: 1;
    MAX_ENUM_KHR :: 2147483647;
}

VkAccelerationStructureCreateFlagBitsKHR :: enum s32 {
    DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR    :: 1;
    DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT :: 8;
    MOTION_BIT_NV                            :: 4;
    FLAG_BITS_MAX_ENUM_KHR                   :: 2147483647;
}

VkAccelerationStructureCreateFlagsKHR :: VkFlags;
VkAccelerationStructureBuildRangeInfoKHR :: struct {
    primitiveCount:  u32;
    primitiveOffset: u32;
    firstVertex:     u32;
    transformOffset: u32;
}

VkAccelerationStructureGeometryTrianglesDataKHR :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    vertexFormat:  VkFormat;
    vertexData:    VkDeviceOrHostAddressConstKHR;
    vertexStride:  VkDeviceSize;
    maxVertex:     u32;
    indexType:     VkIndexType;
    indexData:     VkDeviceOrHostAddressConstKHR;
    transformData: VkDeviceOrHostAddressConstKHR;
}

VkAccelerationStructureGeometryAabbsDataKHR :: struct {
    sType:  VkStructureType;
    pNext:  *void;
    data:   VkDeviceOrHostAddressConstKHR;
    stride: VkDeviceSize;
}

VkAccelerationStructureGeometryInstancesDataKHR :: struct {
    sType:           VkStructureType;
    pNext:           *void;
    arrayOfPointers: VkBool32;
    data:            VkDeviceOrHostAddressConstKHR;
}

VkAccelerationStructureGeometryDataKHR :: union {
    triangles: VkAccelerationStructureGeometryTrianglesDataKHR;
    aabbs:     VkAccelerationStructureGeometryAabbsDataKHR;
    instances: VkAccelerationStructureGeometryInstancesDataKHR;
}

VkAccelerationStructureGeometryKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    geometryType: VkGeometryTypeKHR;
    geometry:     VkAccelerationStructureGeometryDataKHR;
    flags:        VkGeometryFlagsKHR;
}

VkAccelerationStructureBuildGeometryInfoKHR :: struct {
    sType:                    VkStructureType;
    pNext:                    *void;
    type:                     VkAccelerationStructureTypeKHR;
    flags:                    VkBuildAccelerationStructureFlagsKHR;
    mode:                     VkBuildAccelerationStructureModeKHR;
    srcAccelerationStructure: VkAccelerationStructureKHR;
    dstAccelerationStructure: VkAccelerationStructureKHR;
    geometryCount:            u32;
    pGeometries:              *VkAccelerationStructureGeometryKHR;
    ppGeometries:             **VkAccelerationStructureGeometryKHR;
    scratchData:              VkDeviceOrHostAddressKHR;
}

VkAccelerationStructureCreateInfoKHR :: struct {
    sType:         VkStructureType;
    pNext:         *void;
    createFlags:   VkAccelerationStructureCreateFlagsKHR;
    buffer:        VkBuffer;
    offset:        VkDeviceSize;
    size:          VkDeviceSize;
    type:          VkAccelerationStructureTypeKHR;
    deviceAddress: VkDeviceAddress;
}

VkWriteDescriptorSetAccelerationStructureKHR :: struct {
    sType:                      VkStructureType;
    pNext:                      *void;
    accelerationStructureCount: u32;
    pAccelerationStructures:    *VkAccelerationStructureKHR;
}

VkPhysicalDeviceAccelerationStructureFeaturesKHR :: struct {
    sType:                                                 VkStructureType;
    pNext:                                                 *void;
    accelerationStructure:                                 VkBool32;
    accelerationStructureCaptureReplay:                    VkBool32;
    accelerationStructureIndirectBuild:                    VkBool32;
    accelerationStructureHostCommands:                     VkBool32;
    descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32;
}

VkPhysicalDeviceAccelerationStructurePropertiesKHR :: struct {
    sType:                                                      VkStructureType;
    pNext:                                                      *void;
    maxGeometryCount:                                           u64;
    maxInstanceCount:                                           u64;
    maxPrimitiveCount:                                          u64;
    maxPerStageDescriptorAccelerationStructures:                u32;
    maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32;
    maxDescriptorSetAccelerationStructures:                     u32;
    maxDescriptorSetUpdateAfterBindAccelerationStructures:      u32;
    minAccelerationStructureScratchOffsetAlignment:             u32;
}

VkAccelerationStructureDeviceAddressInfoKHR :: struct {
    sType:                 VkStructureType;
    pNext:                 *void;
    accelerationStructure: VkAccelerationStructureKHR;
}

VkAccelerationStructureVersionInfoKHR :: struct {
    sType:        VkStructureType;
    pNext:        *void;
    pVersionData: *u8;
}

VkCopyAccelerationStructureToMemoryInfoKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    src:   VkAccelerationStructureKHR;
    dst:   VkDeviceOrHostAddressKHR;
    mode:  VkCopyAccelerationStructureModeKHR;
}

VkCopyMemoryToAccelerationStructureInfoKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    src:   VkDeviceOrHostAddressConstKHR;
    dst:   VkAccelerationStructureKHR;
    mode:  VkCopyAccelerationStructureModeKHR;
}

VkCopyAccelerationStructureInfoKHR :: struct {
    sType: VkStructureType;
    pNext: *void;
    src:   VkAccelerationStructureKHR;
    dst:   VkAccelerationStructureKHR;
    mode:  VkCopyAccelerationStructureModeKHR;
}

VkAccelerationStructureBuildSizesInfoKHR :: struct {
    sType:                     VkStructureType;
    pNext:                     *void;
    accelerationStructureSize: VkDeviceSize;
    updateScratchSize:         VkDeviceSize;
    buildScratchSize:          VkDeviceSize;
}

PFN_vkCreateAccelerationStructureKHR :: #type (device: VkDevice, pCreateInfo: *VkAccelerationStructureCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pAccelerationStructure: *VkAccelerationStructureKHR) -> VkResult #c_call;
PFN_vkDestroyAccelerationStructureKHR :: #type (device: VkDevice, accelerationStructure: VkAccelerationStructureKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCmdBuildAccelerationStructuresKHR :: #type (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: **VkAccelerationStructureBuildRangeInfoKHR) -> void #c_call;
PFN_vkCmdBuildAccelerationStructuresIndirectKHR :: #type (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, pIndirectDeviceAddresses: *VkDeviceAddress, pIndirectStrides: *u32, ppMaxPrimitiveCounts: **u32) -> void #c_call;
PFN_vkBuildAccelerationStructuresKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: **VkAccelerationStructureBuildRangeInfoKHR) -> VkResult #c_call;
PFN_vkCopyAccelerationStructureKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyAccelerationStructureInfoKHR) -> VkResult #c_call;
PFN_vkCopyAccelerationStructureToMemoryKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyAccelerationStructureToMemoryInfoKHR) -> VkResult #c_call;
PFN_vkCopyMemoryToAccelerationStructureKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMemoryToAccelerationStructureInfoKHR) -> VkResult #c_call;
PFN_vkWriteAccelerationStructuresPropertiesKHR :: #type (device: VkDevice, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureKHR, queryType: VkQueryType, dataSize: u64, pData: *void, stride: u64) -> VkResult #c_call;
PFN_vkCmdCopyAccelerationStructureKHR :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyAccelerationStructureInfoKHR) -> void #c_call;
PFN_vkCmdCopyAccelerationStructureToMemoryKHR :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyAccelerationStructureToMemoryInfoKHR) -> void #c_call;
PFN_vkCmdCopyMemoryToAccelerationStructureKHR :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMemoryToAccelerationStructureInfoKHR) -> void #c_call;
PFN_vkGetAccelerationStructureDeviceAddressKHR :: #type (device: VkDevice, pInfo: *VkAccelerationStructureDeviceAddressInfoKHR) -> VkDeviceAddress #c_call;
PFN_vkCmdWriteAccelerationStructuresPropertiesKHR :: #type (commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureKHR, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) -> void #c_call;
PFN_vkGetDeviceAccelerationStructureCompatibilityKHR :: #type (device: VkDevice, pVersionInfo: *VkAccelerationStructureVersionInfoKHR, pCompatibility: *VkAccelerationStructureCompatibilityKHR) -> void #c_call;
PFN_vkGetAccelerationStructureBuildSizesKHR :: #type (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *VkAccelerationStructureBuildGeometryInfoKHR, pMaxPrimitiveCounts: *u32, pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR) -> void #c_call;

VkShaderGroupShaderKHR :: enum s32 {
    GENERAL_KHR      :: 0;
    CLOSEST_HIT_KHR  :: 1;
    ANY_HIT_KHR      :: 2;
    INTERSECTION_KHR :: 3;
    MAX_ENUM_KHR     :: 2147483647;
}

VkRayTracingShaderGroupCreateInfoKHR :: struct {
    sType:                           VkStructureType;
    pNext:                           *void;
    type:                            VkRayTracingShaderGroupTypeKHR;
    generalShader:                   u32;
    closestHitShader:                u32;
    anyHitShader:                    u32;
    intersectionShader:              u32;
    pShaderGroupCaptureReplayHandle: *void;
}

VkRayTracingPipelineInterfaceCreateInfoKHR :: struct {
    sType:                          VkStructureType;
    pNext:                          *void;
    maxPipelineRayPayloadSize:      u32;
    maxPipelineRayHitAttributeSize: u32;
}

VkRayTracingPipelineCreateInfoKHR :: struct {
    sType:                        VkStructureType;
    pNext:                        *void;
    flags:                        VkPipelineCreateFlags;
    stageCount:                   u32;
    pStages:                      *VkPipelineShaderStageCreateInfo;
    groupCount:                   u32;
    pGroups:                      *VkRayTracingShaderGroupCreateInfoKHR;
    maxPipelineRayRecursionDepth: u32;
    pLibraryInfo:                 *VkPipelineLibraryCreateInfoKHR;
    pLibraryInterface:            *VkRayTracingPipelineInterfaceCreateInfoKHR;
    pDynamicState:                *VkPipelineDynamicStateCreateInfo;
    layout:                       VkPipelineLayout;
    basePipelineHandle:           VkPipeline;
    basePipelineIndex:            s32;
}

VkPhysicalDeviceRayTracingPipelineFeaturesKHR :: struct {
    sType:                                                 VkStructureType;
    pNext:                                                 *void;
    rayTracingPipeline:                                    VkBool32;
    rayTracingPipelineShaderGroupHandleCaptureReplay:      VkBool32;
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32;
    rayTracingPipelineTraceRaysIndirect:                   VkBool32;
    rayTraversalPrimitiveCulling:                          VkBool32;
}

VkPhysicalDeviceRayTracingPipelinePropertiesKHR :: struct {
    sType:                              VkStructureType;
    pNext:                              *void;
    shaderGroupHandleSize:              u32;
    maxRayRecursionDepth:               u32;
    maxShaderGroupStride:               u32;
    shaderGroupBaseAlignment:           u32;
    shaderGroupHandleCaptureReplaySize: u32;
    maxRayDispatchInvocationCount:      u32;
    shaderGroupHandleAlignment:         u32;
    maxRayHitAttributeSize:             u32;
}

VkStridedDeviceAddressRegionKHR :: struct {
    deviceAddress: VkDeviceAddress;
    stride:        VkDeviceSize;
    size:          VkDeviceSize;
}

VkTraceRaysIndirectCommandKHR :: struct {
    width:  u32;
    height: u32;
    depth:  u32;
}

PFN_vkCmdTraceRaysKHR :: #type (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32) -> void #c_call;
PFN_vkCreateRayTracingPipelinesKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkRayTracingPipelineCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR :: #type (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: u64, pData: *void) -> VkResult #c_call;
PFN_vkCmdTraceRaysIndirectKHR :: #type (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *VkStridedDeviceAddressRegionKHR, indirectDeviceAddress: VkDeviceAddress) -> void #c_call;
PFN_vkGetRayTracingShaderGroupStackSizeKHR :: #type (device: VkDevice, pipeline: VkPipeline, group: u32, groupShader: VkShaderGroupShaderKHR) -> VkDeviceSize #c_call;
PFN_vkCmdSetRayTracingPipelineStackSizeKHR :: #type (commandBuffer: VkCommandBuffer, pipelineStackSize: u32) -> void #c_call;

VkPhysicalDeviceRayQueryFeaturesKHR :: struct {
    sType:    VkStructureType;
    pNext:    *void;
    rayQuery: VkBool32;
}

VkPhysicalDeviceMeshShaderFeaturesEXT :: struct {
    sType:                                  VkStructureType;
    pNext:                                  *void;
    taskShader:                             VkBool32;
    meshShader:                             VkBool32;
    multiviewMeshShader:                    VkBool32;
    primitiveFragmentShadingRateMeshShader: VkBool32;
    meshShaderQueries:                      VkBool32;
}

VkPhysicalDeviceMeshShaderPropertiesEXT :: struct {
    sType:                                 VkStructureType;
    pNext:                                 *void;
    maxTaskWorkGroupTotalCount:            u32;
    maxTaskWorkGroupCount:                 [3] u32;
    maxTaskWorkGroupInvocations:           u32;
    maxTaskWorkGroupSize:                  [3] u32;
    maxTaskPayloadSize:                    u32;
    maxTaskSharedMemorySize:               u32;
    maxTaskPayloadAndSharedMemorySize:     u32;
    maxMeshWorkGroupTotalCount:            u32;
    maxMeshWorkGroupCount:                 [3] u32;
    maxMeshWorkGroupInvocations:           u32;
    maxMeshWorkGroupSize:                  [3] u32;
    maxMeshSharedMemorySize:               u32;
    maxMeshPayloadAndSharedMemorySize:     u32;
    maxMeshOutputMemorySize:               u32;
    maxMeshPayloadAndOutputMemorySize:     u32;
    maxMeshOutputComponents:               u32;
    maxMeshOutputVertices:                 u32;
    maxMeshOutputPrimitives:               u32;
    maxMeshOutputLayers:                   u32;
    maxMeshMultiviewViewCount:             u32;
    meshOutputPerVertexGranularity:        u32;
    meshOutputPerPrimitiveGranularity:     u32;
    maxPreferredTaskWorkGroupInvocations:  u32;
    maxPreferredMeshWorkGroupInvocations:  u32;
    prefersLocalInvocationVertexOutput:    VkBool32;
    prefersLocalInvocationPrimitiveOutput: VkBool32;
    prefersCompactVertexOutput:            VkBool32;
    prefersCompactPrimitiveOutput:         VkBool32;
}

VkDrawMeshTasksIndirectCommandEXT :: struct {
    groupCountX: u32;
    groupCountY: u32;
    groupCountZ: u32;
}

PFN_vkCmdDrawMeshTasksEXT :: #type (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksIndirectEXT :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksIndirectCountEXT :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;

/// Flags for created #VmaAllocator.
VmaAllocatorCreateFlagBits :: enum s32 {
    EXTERNALLY_SYNCHRONIZED_BIT    :: 1;

    KHR_DEDICATED_ALLOCATION_BIT   :: 2;

    KHR_BIND_MEMORY2_BIT           :: 4;

    EXT_MEMORY_BUDGET_BIT          :: 8;

    AMD_DEVICE_COHERENT_MEMORY_BIT :: 16;

    BUFFER_DEVICE_ADDRESS_BIT      :: 32;

    EXT_MEMORY_PRIORITY_BIT        :: 64;

    FLAG_BITS_MAX_ENUM             :: 2147483647;
}

/// See #VmaAllocatorCreateFlagBits.
VmaAllocatorCreateFlags :: VkFlags;

/// \brief Intended usage of the allocated memory.
VmaMemoryUsage :: enum s32 {
    UNKNOWN              :: 0;

    GPU_ONLY             :: 1;

    CPU_ONLY             :: 2;

    CPU_TO_GPU           :: 3;

    GPU_TO_CPU           :: 4;

    CPU_COPY             :: 5;

    GPU_LAZILY_ALLOCATED :: 6;

    AUTO                 :: 7;

    AUTO_PREFER_DEVICE   :: 8;

    AUTO_PREFER_HOST     :: 9;

    MAX_ENUM             :: 2147483647;
}

/// Flags to be passed as VmaAllocationCreateInfo::flags.
VmaAllocationCreateFlagBits :: enum s32 {
    DEDICATED_MEMORY_BIT                   :: 1;

    NEVER_ALLOCATE_BIT                     :: 2;

    MAPPED_BIT                             :: 4;

    USER_DATA_COPY_STRING_BIT              :: 32;

    UPPER_ADDRESS_BIT                      :: 64;

    DONT_BIND_BIT                          :: 128;

    WITHIN_BUDGET_BIT                      :: 256;

    CAN_ALIAS_BIT                          :: 512;

    HOST_ACCESS_SEQUENTIAL_WRITE_BIT       :: 1024;

    HOST_ACCESS_RANDOM_BIT                 :: 2048;

    HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT :: 4096;

    STRATEGY_MIN_MEMORY_BIT                :: 65536;

    STRATEGY_MIN_TIME_BIT                  :: 131072;

    STRATEGY_MIN_OFFSET_BIT                :: 262144;

    STRATEGY_BEST_FIT_BIT                  :: 65536;

    STRATEGY_FIRST_FIT_BIT                 :: 131072;

    STRATEGY_MASK                          :: 458752;

    FLAG_BITS_MAX_ENUM                     :: 2147483647;
}

/// See #VmaAllocationCreateFlagBits.
VmaAllocationCreateFlags :: VkFlags;

/// Flags to be passed as VmaPoolCreateInfo::flags.
VmaPoolCreateFlagBits :: enum s32 {
    IGNORE_BUFFER_IMAGE_GRANULARITY_BIT :: 2;

    LINEAR_ALGORITHM_BIT                :: 4;

    ALGORITHM_MASK                      :: 4;

    FLAG_BITS_MAX_ENUM                  :: 2147483647;
}

/// Flags to be passed as VmaPoolCreateInfo::flags. See #VmaPoolCreateFlagBits.
VmaPoolCreateFlags :: VkFlags;

/// Flags to be passed as VmaDefragmentationInfo::flags.
VmaDefragmentationFlagBits :: enum s32 {
    ALGORITHM_FAST_BIT      :: 1;

    ALGORITHM_BALANCED_BIT  :: 2;

    ALGORITHM_FULL_BIT      :: 4;

    ALGORITHM_EXTENSIVE_BIT :: 8;

    ALGORITHM_MASK          :: 15;

    BITS_MAX_ENUM           :: 2147483647;
}

/// See #VmaDefragmentationFlagBits.
VmaDefragmentationFlags :: VkFlags;

/// Operation performed on single defragmentation move. See structure #VmaDefragmentationMove.
VmaDefragmentationMoveOperation :: enum s32 {
    COPY    :: 0;

    IGNORE  :: 1;

    DESTROY :: 2;
}

/// Flags to be passed as VmaVirtualBlockCreateInfo::flags.
VmaVirtualBlockCreateFlagBits :: enum s32 {
    LINEAR_ALGORITHM_BIT :: 1;

    ALGORITHM_MASK       :: 1;

    FLAG_BITS_MAX_ENUM   :: 2147483647;
}

/// Flags to be passed as VmaVirtualBlockCreateInfo::flags. See #VmaVirtualBlockCreateFlagBits.
VmaVirtualBlockCreateFlags :: VkFlags;

/// Flags to be passed as VmaVirtualAllocationCreateInfo::flags.
VmaVirtualAllocationCreateFlagBits :: enum s32 {
    UPPER_ADDRESS_BIT       :: 64;

    STRATEGY_MIN_MEMORY_BIT :: 65536;

    STRATEGY_MIN_TIME_BIT   :: 131072;

    STRATEGY_MIN_OFFSET_BIT :: 262144;

    STRATEGY_MASK           :: 458752;

    FLAG_BITS_MAX_ENUM      :: 2147483647;
}

/// Flags to be passed as VmaVirtualAllocationCreateInfo::flags. See #VmaVirtualAllocationCreateFlagBits.
VmaVirtualAllocationCreateFlags :: VkFlags;

VmaAllocator_T :: struct {}
/** \struct VmaAllocator
\brief Represents main object of this library initialized.

Fill structure #VmaAllocatorCreateInfo and call function vmaCreateAllocator() to create it.
Call function vmaDestroyAllocator() to destroy it.

It is recommended to create just one object of this type per `VkDevice` object,
right after Vulkan is initialized and keep it alive until before Vulkan device is destroyed.
*/
VmaAllocator :: *VmaAllocator_T;

VmaPool_T :: struct {}
/** \struct VmaPool
\brief Represents custom memory pool

Fill structure VmaPoolCreateInfo and call function vmaCreatePool() to create it.
Call function vmaDestroyPool() to destroy it.

For more information see [Custom memory pools](@ref choosing_memory_type_custom_memory_pools).
*/
VmaPool :: *VmaPool_T;

VmaAllocation_T :: struct {}
/** \struct VmaAllocation
\brief Represents single memory allocation.

It may be either dedicated block of `VkDeviceMemory` or a specific region of a bigger block of this type
plus unique offset.

There are multiple ways to create such object.
You need to fill structure VmaAllocationCreateInfo.
For more information see [Choosing memory type](@ref choosing_memory_type).

Although the library provides convenience functions that create Vulkan buffer or image,
allocate memory for it and bind them together,
binding of the allocation to a buffer or an image is out of scope of the allocation itself.
Allocation object can exist without buffer/image bound,
binding can be done manually by the user, and destruction of it can be done
independently of destruction of the allocation.

The object also remembers its size and some other information.
To retrieve this information, use function vmaGetAllocationInfo() and inspect
returned structure VmaAllocationInfo.
*/
VmaAllocation :: *VmaAllocation_T;

VmaDefragmentationContext_T :: struct {}
/** \struct VmaDefragmentationContext
\brief An opaque object that represents started defragmentation process.

Fill structure #VmaDefragmentationInfo and call function vmaBeginDefragmentation() to create it.
Call function vmaEndDefragmentation() to destroy it.
*/
VmaDefragmentationContext :: *VmaDefragmentationContext_T;

VmaVirtualAllocation_T :: struct {}
/** \struct VmaVirtualAllocation
\brief Represents single memory allocation done inside VmaVirtualBlock.

Use it as a unique identifier to virtual allocation within the single block.

Use value `VK_NULL_HANDLE` to represent a null/invalid allocation.
*/
VmaVirtualAllocation :: *VmaVirtualAllocation_T;

VmaVirtualBlock_T :: struct {}
/** \struct VmaVirtualBlock
\brief Handle to a virtual block object that allows to use core allocation algorithm without allocating any real GPU memory.

Fill in #VmaVirtualBlockCreateInfo structure and use vmaCreateVirtualBlock() to create it. Use vmaDestroyVirtualBlock() to destroy it.
For more information, see documentation chapter \ref virtual_allocator.

This object is not thread-safe - should not be used from multiple threads simultaneously, must be synchronized externally.
*/
VmaVirtualBlock :: *VmaVirtualBlock_T;

/// Callback function called after successful vkAllocateMemory.
PFN_vmaAllocateDeviceMemoryFunction :: #type (allocator: VmaAllocator, memoryType: u32, memory: VkDeviceMemory, size: VkDeviceSize, pUserData: *void) -> void #c_call;

/// Callback function called before vkFreeMemory.
PFN_vmaFreeDeviceMemoryFunction :: #type (allocator: VmaAllocator, memoryType: u32, memory: VkDeviceMemory, size: VkDeviceSize, pUserData: *void) -> void #c_call;

/** \brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`.

Provided for informative purpose, e.g. to gather statistics about number of
allocations or total amount of memory allocated in Vulkan.

Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.
*/
VmaDeviceMemoryCallbacks :: struct {
    /// Optional, can be null.
    pfnAllocate: PFN_vmaAllocateDeviceMemoryFunction;

    /// Optional, can be null.
    pfnFree:     PFN_vmaFreeDeviceMemoryFunction;

    /// Optional, can be null.
    pUserData:   *void;
}

/** \brief Pointers to some Vulkan functions - a subset used by the library.

Used in VmaAllocatorCreateInfo::pVulkanFunctions.
*/
VmaVulkanFunctions :: struct {
    /// Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS.
    vkGetInstanceProcAddr:                   PFN_vkGetInstanceProcAddr;

    /// Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS.
    vkGetDeviceProcAddr:                     PFN_vkGetDeviceProcAddr;
    vkGetPhysicalDeviceProperties:           PFN_vkGetPhysicalDeviceProperties;
    vkGetPhysicalDeviceMemoryProperties:     PFN_vkGetPhysicalDeviceMemoryProperties;
    vkAllocateMemory:                        PFN_vkAllocateMemory;
    vkFreeMemory:                            PFN_vkFreeMemory;
    vkMapMemory:                             PFN_vkMapMemory;
    vkUnmapMemory:                           PFN_vkUnmapMemory;
    vkFlushMappedMemoryRanges:               PFN_vkFlushMappedMemoryRanges;
    vkInvalidateMappedMemoryRanges:          PFN_vkInvalidateMappedMemoryRanges;
    vkBindBufferMemory:                      PFN_vkBindBufferMemory;
    vkBindImageMemory:                       PFN_vkBindImageMemory;
    vkGetBufferMemoryRequirements:           PFN_vkGetBufferMemoryRequirements;
    vkGetImageMemoryRequirements:            PFN_vkGetImageMemoryRequirements;
    vkCreateBuffer:                          PFN_vkCreateBuffer;
    vkDestroyBuffer:                         PFN_vkDestroyBuffer;
    vkCreateImage:                           PFN_vkCreateImage;
    vkDestroyImage:                          PFN_vkDestroyImage;
    vkCmdCopyBuffer:                         PFN_vkCmdCopyBuffer;

    /// Fetch "vkGetBufferMemoryRequirements2" on Vulkan >= 1.1, fetch "vkGetBufferMemoryRequirements2KHR" when using VK_KHR_dedicated_allocation extension.
    vkGetBufferMemoryRequirements2KHR:       PFN_vkGetBufferMemoryRequirements2KHR;

    /// Fetch "vkGetImageMemoryRequirements2" on Vulkan >= 1.1, fetch "vkGetImageMemoryRequirements2KHR" when using VK_KHR_dedicated_allocation extension.
    vkGetImageMemoryRequirements2KHR:        PFN_vkGetImageMemoryRequirements2KHR;

    /// Fetch "vkBindBufferMemory2" on Vulkan >= 1.1, fetch "vkBindBufferMemory2KHR" when using VK_KHR_bind_memory2 extension.
    vkBindBufferMemory2KHR:                  PFN_vkBindBufferMemory2KHR;

    /// Fetch "vkBindImageMemory2" on Vulkan >= 1.1, fetch "vkBindImageMemory2KHR" when using VK_KHR_bind_memory2 extension.
    vkBindImageMemory2KHR:                   PFN_vkBindImageMemory2KHR;

    vkGetPhysicalDeviceMemoryProperties2KHR: PFN_vkGetPhysicalDeviceMemoryProperties2KHR;

    /// Fetch from "vkGetDeviceBufferMemoryRequirements" on Vulkan >= 1.3, but you can also fetch it from "vkGetDeviceBufferMemoryRequirementsKHR" if you enabled extension VK_KHR_maintenance4.
    vkGetDeviceBufferMemoryRequirements:     PFN_vkGetDeviceBufferMemoryRequirements;

    /// Fetch from "vkGetDeviceImageMemoryRequirements" on Vulkan >= 1.3, but you can also fetch it from "vkGetDeviceImageMemoryRequirementsKHR" if you enabled extension VK_KHR_maintenance4.
    vkGetDeviceImageMemoryRequirements:      PFN_vkGetDeviceImageMemoryRequirements;
}

/// Description of a Allocator to be created.
VmaAllocatorCreateInfo :: struct {
    /// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.
    flags:                          VmaAllocatorCreateFlags;

    /// Vulkan physical device.
    /** It must be valid throughout whole lifetime of created allocator. */
    physicalDevice:                 VkPhysicalDevice;

    /// Vulkan device.
    /** It must be valid throughout whole lifetime of created allocator. */
    device:                         VkDevice;

    /// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.
    /** Set to 0 to use default, which is currently 256 MiB. */
    preferredLargeHeapBlockSize:    VkDeviceSize;

    /// Custom CPU memory allocation callbacks. Optional.
    /** Optional, can be null. When specified, will also be used for all CPU-side memory allocations. */
    pAllocationCallbacks:           *VkAllocationCallbacks;

    /// Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.
    /** Optional, can be null. */
    pDeviceMemoryCallbacks:         *VmaDeviceMemoryCallbacks;

    /** \brief Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap.
    
    If not NULL, it must be a pointer to an array of
    `VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on
    maximum number of bytes that can be allocated out of particular Vulkan memory
    heap.
    
    Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that
    heap. This is also the default in case of `pHeapSizeLimit` = NULL.
    
    If there is a limit defined for a heap:
    
    - If user tries to allocate more memory from that heap using this allocator,
    the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
    - If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the
    value of this limit will be reported instead when using vmaGetMemoryProperties().
    
    Warning! Using this feature may not be equivalent to installing a GPU with
    smaller amount of memory, because graphics driver doesn't necessary fail new
    allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is
    exceeded. It may return success and just silently migrate some device memory
    blocks to system RAM. This driver behavior can also be controlled using
    VK_AMD_memory_overallocation_behavior extension.
    */
    pHeapSizeLimit:                 *VkDeviceSize;

    /** \brief Pointers to Vulkan functions. Can be null.
    
    For details see [Pointers to Vulkan functions](@ref config_Vulkan_functions).
    */
    pVulkanFunctions:               *VmaVulkanFunctions;

    /** \brief Handle to Vulkan instance object.
    
    Starting from version 3.0.0 this member is no longer optional, it must be set!
    */
    instance:                       VkInstance;

    /** \brief Optional. The highest version of Vulkan that the application is designed to use.
    
    It must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`.
    The patch version number specified is ignored. Only the major and minor versions are considered.
    It must be less or equal (preferably equal) to value as passed to `vkCreateInstance` as `VkApplicationInfo::apiVersion`.
    Only versions 1.0, 1.1, 1.2, 1.3 are supported by the current implementation.
    Leaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`.
    */
    vulkanApiVersion:               u32;

    /** \brief Either null or a pointer to an array of external memory handle types for each Vulkan memory type.
    
    If not NULL, it must be a pointer to an array of `VkPhysicalDeviceMemoryProperties::memoryTypeCount`
    elements, defining external memory handle types of particular Vulkan memory type,
    to be passed using `VkExportMemoryAllocateInfoKHR`.
    
    Any of the elements may be equal to 0, which means not to use `VkExportMemoryAllocateInfoKHR` on this memory type.
    This is also the default in case of `pTypeExternalMemoryHandleTypes` = NULL.
    */
    pTypeExternalMemoryHandleTypes: *VkExternalMemoryHandleTypeFlagsKHR;
}

/// Information about existing #VmaAllocator object.
VmaAllocatorInfo :: struct {
    /** \brief Handle to Vulkan instance object.
    
    This is the same value as has been passed through VmaAllocatorCreateInfo::instance.
    */
    instance:       VkInstance;

    /** \brief Handle to Vulkan physical device object.
    
    This is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice.
    */
    physicalDevice: VkPhysicalDevice;

    /** \brief Handle to Vulkan device object.
    
    This is the same value as has been passed through VmaAllocatorCreateInfo::device.
    */
    device:         VkDevice;
}

/** \brief Calculated statistics of memory usage e.g. in a specific memory type, heap, custom pool, or total.

These are fast to calculate.
See functions: vmaGetHeapBudgets(), vmaGetPoolStatistics().
*/
VmaStatistics :: struct {
    /** \brief Number of `VkDeviceMemory` objects - Vulkan memory blocks allocated.
    */
    blockCount:      u32;

    /** \brief Number of #VmaAllocation objects allocated.
    
    Dedicated allocations have their own blocks, so each one adds 1 to `allocationCount` as well as `blockCount`.
    */
    allocationCount: u32;

    /** \brief Number of bytes allocated in `VkDeviceMemory` blocks.
    
    \note To avoid confusion, please be aware that what Vulkan calls an "allocation" - a whole `VkDeviceMemory` object
    (e.g. as in `VkPhysicalDeviceLimits::maxMemoryAllocationCount`) is called a "block" in VMA, while VMA calls
    "allocation" a #VmaAllocation object that represents a memory region sub-allocated from such block, usually for a single buffer or image.
    */
    blockBytes:      VkDeviceSize;

    /** \brief Total number of bytes occupied by all #VmaAllocation objects.
    
    Always less or equal than `blockBytes`.
    Difference `(blockBytes - allocationBytes)` is the amount of memory allocated from Vulkan
    but unused by any #VmaAllocation.
    */
    allocationBytes: VkDeviceSize;
}

/** \brief More detailed statistics than #VmaStatistics.

These are slower to calculate. Use for debugging purposes.
See functions: vmaCalculateStatistics(), vmaCalculatePoolStatistics().

Previous version of the statistics API provided averages, but they have been removed
because they can be easily calculated as:

\code
VkDeviceSize allocationSizeAvg = detailedStats.statistics.allocationBytes / detailedStats.statistics.allocationCount;
VkDeviceSize unusedBytes = detailedStats.statistics.blockBytes - detailedStats.statistics.allocationBytes;
VkDeviceSize unusedRangeSizeAvg = unusedBytes / detailedStats.unusedRangeCount;
\endcode
*/
VmaDetailedStatistics :: struct {
    /// Basic statistics.
    statistics:         VmaStatistics;

    /// Number of free ranges of memory between allocations.
    unusedRangeCount:   u32;

    /// Smallest allocation size. `VK_WHOLE_SIZE` if there are 0 allocations.
    allocationSizeMin:  VkDeviceSize;

    /// Largest allocation size. 0 if there are 0 allocations.
    allocationSizeMax:  VkDeviceSize;

    /// Smallest empty range size. `VK_WHOLE_SIZE` if there are 0 empty ranges.
    unusedRangeSizeMin: VkDeviceSize;

    /// Largest empty range size. 0 if there are 0 empty ranges.
    unusedRangeSizeMax: VkDeviceSize;
}

/** \brief  General statistics from current state of the Allocator -
total memory usage across all memory heaps and types.

These are slower to calculate. Use for debugging purposes.
See function vmaCalculateStatistics().
*/
VmaTotalStatistics :: struct {
    memoryType: [32] VmaDetailedStatistics;
    memoryHeap: [16] VmaDetailedStatistics;
    total:      VmaDetailedStatistics;
}

/** \brief Statistics of current memory usage and available budget for a specific memory heap.

These are fast to calculate.
See function vmaGetHeapBudgets().
*/
VmaBudget :: struct {
    /** \brief Statistics fetched from the library.
    */
    statistics: VmaStatistics;

    /** \brief Estimated current memory usage of the program, in bytes.
    
    Fetched from system using VK_EXT_memory_budget extension if enabled.
    
    It might be different than `statistics.blockBytes` (usually higher) due to additional implicit objects
    also occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or
    `VkDeviceMemory` blocks allocated outside of this library, if any.
    */
    usage:      VkDeviceSize;

    /** \brief Estimated amount of memory available to the program, in bytes.
    
    Fetched from system using VK_EXT_memory_budget extension if enabled.
    
    It might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors
    external to the program, decided by the operating system.
    Difference `budget - usage` is the amount of additional memory that can probably
    be allocated without problems. Exceeding the budget may result in various problems.
    */
    budget:     VkDeviceSize;
}

/** \brief Parameters of new #VmaAllocation.

To be used with functions like vmaCreateBuffer(), vmaCreateImage(), and many others.
*/
VmaAllocationCreateInfo :: struct {
    /// Use #VmaAllocationCreateFlagBits enum.
    flags:          VmaAllocationCreateFlags;

    /** \brief Intended usage of memory.
    
    You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \n
    If `pool` is not null, this member is ignored.
    */
    usage:          VmaMemoryUsage;

    /** \brief Flags that must be set in a Memory Type chosen for an allocation.
    
    Leave 0 if you specify memory requirements in other way. \n
    If `pool` is not null, this member is ignored.*/
    requiredFlags:  VkMemoryPropertyFlags;

    /** \brief Flags that preferably should be set in a memory type chosen for an allocation.
    
    Set to 0 if no additional flags are preferred. \n
    If `pool` is not null, this member is ignored. */
    preferredFlags: VkMemoryPropertyFlags;

    /** \brief Bitmask containing one bit set for every memory type acceptable for this allocation.
    
    Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if
    it meets other requirements specified by this structure, with no further
    restrictions on memory type index. \n
    If `pool` is not null, this member is ignored.
    */
    memoryTypeBits: u32;

    /** \brief Pool that this allocation should be created in.
    
    Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:
    `usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored.
    */
    pool:           VmaPool;

    /** \brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData().
    
    If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either
    null or pointer to a null-terminated string. The string will be then copied to
    internal buffer, so it doesn't need to be valid after allocation call.
    */
    pUserData:      *void;

    /** \brief A floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations.
    
    It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object
    and this allocation ends up as dedicated or is explicitly forced as dedicated using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
    Otherwise, it has the priority of a memory block where it is placed and this variable is ignored.
    */
    priority:       float;
}

/// Describes parameter of created #VmaPool.
VmaPoolCreateInfo :: struct {
    /** \brief Vulkan memory type index to allocate this pool from.
    */
    memoryTypeIndex:        u32;

    /** \brief Use combination of #VmaPoolCreateFlagBits.
    */
    flags:                  VmaPoolCreateFlags;

    /** \brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes. Optional.
    
    Specify nonzero to set explicit, constant size of memory blocks used by this
    pool.
    
    Leave 0 to use default and let the library manage block sizes automatically.
    Sizes of particular blocks may vary.
    In this case, the pool will also support dedicated allocations.
    */
    blockSize:              VkDeviceSize;

    /** \brief Minimum number of blocks to be always allocated in this pool, even if they stay empty.
    
    Set to 0 to have no preallocated blocks and allow the pool be completely empty.
    */
    minBlockCount:          u64;

    /** \brief Maximum number of blocks that can be allocated in this pool. Optional.
    
    Set to 0 to use default, which is `SIZE_MAX`, which means no limit.
    
    Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated
    throughout whole lifetime of this pool.
    */
    maxBlockCount:          u64;

    /** \brief A floating-point value between 0 and 1, indicating the priority of the allocations in this pool relative to other memory allocations.
    
    It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object.
    Otherwise, this variable is ignored.
    */
    priority:               float;

    /** \brief Additional minimum alignment to be used for all allocations created from this pool. Can be 0.
    
    Leave 0 (default) not to impose any additional alignment. If not 0, it must be a power of two.
    It can be useful in cases where alignment returned by Vulkan by functions like `vkGetBufferMemoryRequirements` is not enough,
    e.g. when doing interop with OpenGL.
    */
    minAllocationAlignment: VkDeviceSize;

    /** \brief Additional `pNext` chain to be attached to `VkMemoryAllocateInfo` used for every allocation made by this pool. Optional.
    
    Optional, can be null. If not null, it must point to a `pNext` chain of structures that can be attached to `VkMemoryAllocateInfo`.
    It can be useful for special needs such as adding `VkExportMemoryAllocateInfoKHR`.
    Structures pointed by this member must remain alive and unchanged for the whole lifetime of the custom pool.
    
    Please note that some structures, e.g. `VkMemoryPriorityAllocateInfoEXT`, `VkMemoryDedicatedAllocateInfoKHR`,
    can be attached automatically by this library when using other, more convenient of its features.
    */
    pMemoryAllocateNext:    *void;
}

/// Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().
VmaAllocationInfo :: struct {
    /** \brief Memory type index that this allocation was allocated from.
    
    It never changes.
    */
    memoryType:   u32;

    /** \brief Handle to Vulkan memory object.
    
    Same memory object can be shared by multiple allocations.
    
    It can change after the allocation is moved during \ref defragmentation.
    */
    deviceMemory: VkDeviceMemory;

    /** \brief Offset in `VkDeviceMemory` object to the beginning of this allocation, in bytes. `(deviceMemory, offset)` pair is unique to this allocation.
    
    You usually don't need to use this offset. If you create a buffer or an image together with the allocation using e.g. function
    vmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the beginning of the buffer or image,
    not entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also refer to the beginning of the allocation
    and apply this offset automatically.
    
    It can change after the allocation is moved during \ref defragmentation.
    */
    offset:       VkDeviceSize;

    /** \brief Size of this allocation, in bytes.
    
    It never changes.
    
    \note Allocation size returned in this variable may be greater than the size
    requested for the resource e.g. as `VkBufferCreateInfo::size`. Whole size of the
    allocation is accessible for operations on memory e.g. using a pointer after
    mapping with vmaMapMemory(), but operations on the resource e.g. using
    `vkCmdCopyBuffer` must be limited to the size of the resource.
    */
    size:         VkDeviceSize;

    /** \brief Pointer to the beginning of this allocation as mapped data.
    
    If the allocation hasn't been mapped using vmaMapMemory() and hasn't been
    created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null.
    
    It can change after call to vmaMapMemory(), vmaUnmapMemory().
    It can also change after the allocation is moved during \ref defragmentation.
    */
    pMappedData:  *void;

    /** \brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData().
    
    It can change after call to vmaSetAllocationUserData() for this allocation.
    */
    pUserData:    *void;

    /** \brief Custom allocation name that was set with vmaSetAllocationName().
    
    It can change after call to vmaSetAllocationName() for this allocation.
    
    Another way to set custom name is to pass it in VmaAllocationCreateInfo::pUserData with
    additional flag #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT set [DEPRECATED].
    */
    pName:        *u8;
}

/** Callback function called during vmaBeginDefragmentation() to check custom criterion about ending current defragmentation pass.

Should return true if the defragmentation needs to stop current pass.
*/
PFN_vmaCheckDefragmentationBreakFunction :: #type (pUserData: *void) -> VkBool32 #c_call;

/** \brief Parameters for defragmentation.

To be used with function vmaBeginDefragmentation().
*/
VmaDefragmentationInfo :: struct {
    /// \brief Use combination of #VmaDefragmentationFlagBits.
    flags:                  VmaDefragmentationFlags;

    /** \brief Custom pool to be defragmented.
    
    If null then default pools will undergo defragmentation process.
    */
    pool:                   VmaPool;

    /** \brief Maximum numbers of bytes that can be copied during single pass, while moving allocations to different places.
    
    `0` means no limit.
    */
    maxBytesPerPass:        VkDeviceSize;

    /** \brief Maximum number of allocations that can be moved during single pass to a different place.
    
    `0` means no limit.
    */
    maxAllocationsPerPass:  u32;

    /** \brief Optional custom callback for stopping vmaBeginDefragmentation().
    
    Have to return true for breaking current defragmentation pass.
    */
    pfnBreakCallback:       PFN_vmaCheckDefragmentationBreakFunction;

    /// \brief Optional data to pass to custom callback for stopping pass of defragmentation.
    pBreakCallbackUserData: *void;
}

/// Single move of an allocation to be done for defragmentation.
VmaDefragmentationMove :: struct {
    /// Operation to be performed on the allocation by vmaEndDefragmentationPass(). Default value is #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY. You can modify it.
    operation:        VmaDefragmentationMoveOperation;

    /// Allocation that should be moved.
    srcAllocation:    VmaAllocation;

    /** \brief Temporary allocation pointing to destination memory that will replace `srcAllocation`.
    
    \warning Do not store this allocation in your data structures! It exists only temporarily, for the duration of the defragmentation pass,
    to be used for binding new buffer/image to the destination memory using e.g. vmaBindBufferMemory().
    vmaEndDefragmentationPass() will destroy it and make `srcAllocation` point to this memory.
    */
    dstTmpAllocation: VmaAllocation;
}

/** \brief Parameters for incremental defragmentation steps.

To be used with function vmaBeginDefragmentationPass().
*/
VmaDefragmentationPassMoveInfo :: struct {
    /// Number of elements in the `pMoves` array.
    moveCount: u32;

    /** \brief Array of moves to be performed by the user in the current defragmentation pass.
    
    Pointer to an array of `moveCount` elements, owned by VMA, created in vmaBeginDefragmentationPass(), destroyed in vmaEndDefragmentationPass().
    
    For each element, you should:
    
    1. Create a new buffer/image in the place pointed by VmaDefragmentationMove::dstMemory + VmaDefragmentationMove::dstOffset.
    2. Copy data from the VmaDefragmentationMove::srcAllocation e.g. using `vkCmdCopyBuffer`, `vkCmdCopyImage`.
    3. Make sure these commands finished executing on the GPU.
    4. Destroy the old buffer/image.
    
    Only then you can finish defragmentation pass by calling vmaEndDefragmentationPass().
    After this call, the allocation will point to the new place in memory.
    
    Alternatively, if you cannot move specific allocation, you can set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE.
    
    Alternatively, if you decide you want to completely remove the allocation:
    
    1. Destroy its buffer/image.
    2. Set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY.
    
    Then, after vmaEndDefragmentationPass() the allocation will be freed.
    */
    pMoves:    *VmaDefragmentationMove;
}

/// Statistics returned for defragmentation process in function vmaEndDefragmentation().
VmaDefragmentationStats :: struct {
    /// Total number of bytes that have been copied while moving allocations to different places.
    bytesMoved:              VkDeviceSize;

    /// Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects.
    bytesFreed:              VkDeviceSize;

    /// Number of allocations that have been moved to different places.
    allocationsMoved:        u32;

    /// Number of empty `VkDeviceMemory` objects that have been released to the system.
    deviceMemoryBlocksFreed: u32;
}

/// Parameters of created #VmaVirtualBlock object to be passed to vmaCreateVirtualBlock().
VmaVirtualBlockCreateInfo :: struct {
    /** \brief Total size of the virtual block.
    
    Sizes can be expressed in bytes or any units you want as long as you are consistent in using them.
    For example, if you allocate from some array of structures, 1 can mean single instance of entire structure.
    */
    size:                 VkDeviceSize;

    /** \brief Use combination of #VmaVirtualBlockCreateFlagBits.
    */
    flags:                VmaVirtualBlockCreateFlags;

    /** \brief Custom CPU memory allocation callbacks. Optional.
    
    Optional, can be null. When specified, they will be used for all CPU-side memory allocations.
    */
    pAllocationCallbacks: *VkAllocationCallbacks;
}

/// Parameters of created virtual allocation to be passed to vmaVirtualAllocate().
VmaVirtualAllocationCreateInfo :: struct {
    /** \brief Size of the allocation.
    
    Cannot be zero.
    */
    size:      VkDeviceSize;

    /** \brief Required alignment of the allocation. Optional.
    
    Must be power of two. Special value 0 has the same meaning as 1 - means no special alignment is required, so allocation can start at any offset.
    */
    alignment: VkDeviceSize;

    /** \brief Use combination of #VmaVirtualAllocationCreateFlagBits.
    */
    flags:     VmaVirtualAllocationCreateFlags;

    /** \brief Custom pointer to be associated with the allocation. Optional.
    
    It can be any value and can be used for user-defined purposes. It can be fetched or changed later.
    */
    pUserData: *void;
}

/// Parameters of an existing virtual allocation, returned by vmaGetVirtualAllocationInfo().
VmaVirtualAllocationInfo :: struct {
    /** \brief Offset of the allocation.
    
    Offset at which the allocation was made.
    */
    offset:    VkDeviceSize;

    /** \brief Size of the allocation.
    
    Same value as passed in VmaVirtualAllocationCreateInfo::size.
    */
    size:      VkDeviceSize;

    /** \brief Custom pointer associated with the allocation.
    
    Same value as passed in VmaVirtualAllocationCreateInfo::pUserData or to vmaSetVirtualAllocationUserData().
    */
    pUserData: *void;
}

/// Creates #VmaAllocator object.
vmaCreateAllocator :: (pCreateInfo: *VmaAllocatorCreateInfo, pAllocator: *VmaAllocator) -> VkResult #foreign libvma;

/// Destroys allocator object.
vmaDestroyAllocator :: (allocator: VmaAllocator) -> void #foreign libvma;

/** \brief Returns information about existing #VmaAllocator object - handle to Vulkan device etc.

It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to
`VkPhysicalDevice`, `VkDevice` etc. every time using this function.
*/
vmaGetAllocatorInfo :: (allocator: VmaAllocator, pAllocatorInfo: *VmaAllocatorInfo) -> void #foreign libvma;

/**
PhysicalDeviceProperties are fetched from physicalDevice by the allocator.
You can access it here, without fetching it again on your own.
*/
vmaGetPhysicalDeviceProperties :: (allocator: VmaAllocator, ppPhysicalDeviceProperties: **VkPhysicalDeviceProperties) -> void #foreign libvma;

/**
PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.
You can access it here, without fetching it again on your own.
*/
vmaGetMemoryProperties :: (allocator: VmaAllocator, ppPhysicalDeviceMemoryProperties: **VkPhysicalDeviceMemoryProperties) -> void #foreign libvma;

/**
\brief Given Memory Type Index, returns Property Flags of this memory type.

This is just a convenience function. Same information can be obtained using
vmaGetMemoryProperties().
*/
vmaGetMemoryTypeProperties :: (allocator: VmaAllocator, memoryTypeIndex: u32, pFlags: *VkMemoryPropertyFlags) -> void #foreign libvma;

/** \brief Sets index of the current frame.
*/
vmaSetCurrentFrameIndex :: (allocator: VmaAllocator, frameIndex: u32) -> void #foreign libvma;

/** \brief Retrieves statistics from current state of the Allocator.

This function is called "calculate" not "get" because it has to traverse all
internal data structures, so it may be quite slow. Use it for debugging purposes.
For faster but more brief statistics suitable to be called every frame or every allocation,
use vmaGetHeapBudgets().

Note that when using allocator from multiple threads, returned information may immediately
become outdated.
*/
vmaCalculateStatistics :: (allocator: VmaAllocator, pStats: *VmaTotalStatistics) -> void #foreign libvma;

/** \brief Retrieves information about current memory usage and budget for all memory heaps.

\param allocator
\param[out] pBudgets Must point to array with number of elements at least equal to number of memory heaps in physical device used.

This function is called "get" not "calculate" because it is very fast, suitable to be called
every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().

Note that when using allocator from multiple threads, returned information may immediately
become outdated.
*/
vmaGetHeapBudgets :: (allocator: VmaAllocator, pBudgets: *VmaBudget) -> void #foreign libvma;

/**
\brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo.

This algorithm tries to find a memory type that:

- Is allowed by memoryTypeBits.
- Contains all the flags from pAllocationCreateInfo->requiredFlags.
- Matches intended usage.
- Has as many flags from pAllocationCreateInfo->preferredFlags as possible.

\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result
from this function or any other allocating function probably means that your
device doesn't support any memory type with requested features for the specific
type of resource you want to use it for. Please check parameters of your
resource, like image layout (OPTIMAL versus LINEAR) or mip level count.
*/
vmaFindMemoryTypeIndex :: (allocator: VmaAllocator, memoryTypeBits: u32, pAllocationCreateInfo: *VmaAllocationCreateInfo, pMemoryTypeIndex: *u32) -> VkResult #foreign libvma;

/**
\brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.

It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
It internally creates a temporary, dummy buffer that never has memory bound.
*/
vmaFindMemoryTypeIndexForBufferInfo :: (allocator: VmaAllocator, pBufferCreateInfo: *VkBufferCreateInfo, pAllocationCreateInfo: *VmaAllocationCreateInfo, pMemoryTypeIndex: *u32) -> VkResult #foreign libvma;

/**
\brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.

It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
It internally creates a temporary, dummy image that never has memory bound.
*/
vmaFindMemoryTypeIndexForImageInfo :: (allocator: VmaAllocator, pImageCreateInfo: *VkImageCreateInfo, pAllocationCreateInfo: *VmaAllocationCreateInfo, pMemoryTypeIndex: *u32) -> VkResult #foreign libvma;

/** \brief Allocates Vulkan device memory and creates #VmaPool object.

\param allocator Allocator object.
\param pCreateInfo Parameters of pool to create.
\param[out] pPool Handle to created pool.
*/
vmaCreatePool :: (allocator: VmaAllocator, pCreateInfo: *VmaPoolCreateInfo, pPool: *VmaPool) -> VkResult #foreign libvma;

/** \brief Destroys #VmaPool object and frees Vulkan device memory.
*/
vmaDestroyPool :: (allocator: VmaAllocator, pool: VmaPool) -> void #foreign libvma;

/** \brief Retrieves statistics of existing #VmaPool object.

\param allocator Allocator object.
\param pool Pool object.
\param[out] pPoolStats Statistics of specified pool.
*/
vmaGetPoolStatistics :: (allocator: VmaAllocator, pool: VmaPool, pPoolStats: *VmaStatistics) -> void #foreign libvma;

/** \brief Retrieves detailed statistics of existing #VmaPool object.

\param allocator Allocator object.
\param pool Pool object.
\param[out] pPoolStats Statistics of specified pool.
*/
vmaCalculatePoolStatistics :: (allocator: VmaAllocator, pool: VmaPool, pPoolStats: *VmaDetailedStatistics) -> void #foreign libvma;

/** \brief Checks magic number in margins around all allocations in given memory pool in search for corruptions.

Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,
`VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is
`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection).

Possible return values:

- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.
- `VK_SUCCESS` - corruption detection has been performed and succeeded.
- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.
`VMA_ASSERT` is also fired in that case.
- Other value: Error returned by Vulkan, e.g. memory mapping failure.
*/
vmaCheckPoolCorruption :: (allocator: VmaAllocator, pool: VmaPool) -> VkResult #foreign libvma;

/** \brief Retrieves name of a custom pool.

After the call `ppName` is either null or points to an internally-owned null-terminated string
containing name of the pool that was previously set. The pointer becomes invalid when the pool is
destroyed or its name is changed using vmaSetPoolName().
*/
vmaGetPoolName :: (allocator: VmaAllocator, pool: VmaPool, ppName: **u8) -> void #foreign libvma;

/** \brief Sets name of a custom pool.

`pName` can be either null or pointer to a null-terminated string with new name for the pool.
Function makes internal copy of the string, so it can be changed or freed immediately after this call.
*/
vmaSetPoolName :: (allocator: VmaAllocator, pool: VmaPool, pName: *u8) -> void #foreign libvma;

/** \brief General purpose memory allocation.

\param allocator
\param pVkMemoryRequirements
\param pCreateInfo
\param[out] pAllocation Handle to allocated memory.
\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().

You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().

It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),
vmaCreateBuffer(), vmaCreateImage() instead whenever possible.
*/
vmaAllocateMemory :: (allocator: VmaAllocator, pVkMemoryRequirements: *VkMemoryRequirements, pCreateInfo: *VmaAllocationCreateInfo, pAllocation: *VmaAllocation, pAllocationInfo: *VmaAllocationInfo) -> VkResult #foreign libvma;

/** \brief General purpose memory allocation for multiple allocation objects at once.

\param allocator Allocator object.
\param pVkMemoryRequirements Memory requirements for each allocation.
\param pCreateInfo Creation parameters for each allocation.
\param allocationCount Number of allocations to make.
\param[out] pAllocations Pointer to array that will be filled with handles to created allocations.
\param[out] pAllocationInfo Optional. Pointer to array that will be filled with parameters of created allocations.

You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().

Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.
It is just a general purpose allocation function able to make multiple allocations at once.
It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.

All allocations are made using same parameters. All of them are created out of the same memory pool and type.
If any allocation fails, all allocations already made within this function call are also freed, so that when
returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.
*/
vmaAllocateMemoryPages :: (allocator: VmaAllocator, pVkMemoryRequirements: *VkMemoryRequirements, pCreateInfo: *VmaAllocationCreateInfo, allocationCount: u64, pAllocations: *VmaAllocation, pAllocationInfo: *VmaAllocationInfo) -> VkResult #foreign libvma;

/** \brief Allocates memory suitable for given `VkBuffer`.

\param allocator
\param buffer
\param pCreateInfo
\param[out] pAllocation Handle to allocated memory.
\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().

It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().

This is a special-purpose function. In most cases you should use vmaCreateBuffer().

You must free the allocation using vmaFreeMemory() when no longer needed.
*/
vmaAllocateMemoryForBuffer :: (allocator: VmaAllocator, buffer: VkBuffer, pCreateInfo: *VmaAllocationCreateInfo, pAllocation: *VmaAllocation, pAllocationInfo: *VmaAllocationInfo) -> VkResult #foreign libvma;

/** \brief Allocates memory suitable for given `VkImage`.

\param allocator
\param image
\param pCreateInfo
\param[out] pAllocation Handle to allocated memory.
\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().

It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().

This is a special-purpose function. In most cases you should use vmaCreateImage().

You must free the allocation using vmaFreeMemory() when no longer needed.
*/
vmaAllocateMemoryForImage :: (allocator: VmaAllocator, image: VkImage, pCreateInfo: *VmaAllocationCreateInfo, pAllocation: *VmaAllocation, pAllocationInfo: *VmaAllocationInfo) -> VkResult #foreign libvma;

/** \brief Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage().

Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.
*/
vmaFreeMemory :: (allocator: VmaAllocator, allocation: VmaAllocation) -> void #foreign libvma;

/** \brief Frees memory and destroys multiple allocations.

Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.
It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),
vmaAllocateMemoryPages() and other functions.
It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.

Allocations in `pAllocations` array can come from any memory pools and types.
Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.
*/
vmaFreeMemoryPages :: (allocator: VmaAllocator, allocationCount: u64, pAllocations: *VmaAllocation) -> void #foreign libvma;

/** \brief Returns current information about specified allocation.

Current parameters of given allocation are returned in `pAllocationInfo`.

Although this function doesn't lock any mutex, so it should be quite efficient,
you should avoid calling it too often.
You can retrieve same VmaAllocationInfo structure while creating your resource, from function
vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change
(e.g. due to defragmentation).
*/
vmaGetAllocationInfo :: (allocator: VmaAllocator, allocation: VmaAllocation, pAllocationInfo: *VmaAllocationInfo) -> void #foreign libvma;

/** \brief Sets pUserData in given allocation to new value.

The value of pointer `pUserData` is copied to allocation's `pUserData`.
It is opaque, so you can use it however you want - e.g.
as a pointer, ordinal number or some handle to you own data.
*/
vmaSetAllocationUserData :: (allocator: VmaAllocator, allocation: VmaAllocation, pUserData: *void) -> void #foreign libvma;

/** \brief Sets pName in given allocation to new value.

`pName` must be either null, or pointer to a null-terminated string. The function
makes local copy of the string and sets it as allocation's `pName`. String
passed as pName doesn't need to be valid for whole lifetime of the allocation -
you can free it after this call. String previously pointed by allocation's
`pName` is freed from memory.
*/
vmaSetAllocationName :: (allocator: VmaAllocator, allocation: VmaAllocation, pName: *u8) -> void #foreign libvma;

/**
\brief Given an allocation, returns Property Flags of its memory type.

This is just a convenience function. Same information can be obtained using
vmaGetAllocationInfo() + vmaGetMemoryProperties().
*/
vmaGetAllocationMemoryProperties :: (allocator: VmaAllocator, allocation: VmaAllocation, pFlags: *VkMemoryPropertyFlags) -> void #foreign libvma;

/** \brief Maps memory represented by given allocation and returns pointer to it.

Maps memory represented by given allocation to make it accessible to CPU code.
When succeeded, `*ppData` contains pointer to first byte of this memory.

\warning
If the allocation is part of a bigger `VkDeviceMemory` block, returned pointer is
correctly offsetted to the beginning of region assigned to this particular allocation.
Unlike the result of `vkMapMemory`, it points to the allocation, not to the beginning of the whole block.
You should not add VmaAllocationInfo::offset to it!

Mapping is internally reference-counted and synchronized, so despite raw Vulkan
function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`
multiple times simultaneously, it is safe to call this function on allocations
assigned to the same memory block. Actual Vulkan memory will be mapped on first
mapping and unmapped on last unmapping.

If the function succeeded, you must call vmaUnmapMemory() to unmap the
allocation when mapping is no longer needed or before freeing the allocation, at
the latest.

It also safe to call this function multiple times on the same allocation. You
must call vmaUnmapMemory() same number of times as you called vmaMapMemory().

It is also safe to call this function on allocation created with
#VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.
You must still call vmaUnmapMemory() same number of times as you called
vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the
"0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.

This function fails when used on allocation made in memory type that is not
`HOST_VISIBLE`.

This function doesn't automatically flush or invalidate caches.
If the allocation is made from a memory types that is not `HOST_COHERENT`,
you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.
*/
vmaMapMemory :: (allocator: VmaAllocator, allocation: VmaAllocation, ppData: **void) -> VkResult #foreign libvma;

/** \brief Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().

For details, see description of vmaMapMemory().

This function doesn't automatically flush or invalidate caches.
If the allocation is made from a memory types that is not `HOST_COHERENT`,
you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.
*/
vmaUnmapMemory :: (allocator: VmaAllocator, allocation: VmaAllocation) -> void #foreign libvma;

/** \brief Flushes memory of given allocation.

Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.
It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.
Unmap operation doesn't do that automatically.

- `offset` must be relative to the beginning of allocation.
- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.
- `offset` and `size` don't have to be aligned.
They are internally rounded down/up to multiply of `nonCoherentAtomSize`.
- If `size` is 0, this call is ignored.
- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,
this call is ignored.

Warning! `offset` and `size` are relative to the contents of given `allocation`.
If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.
Do not pass allocation's offset as `offset`!!!

This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is
called, otherwise `VK_SUCCESS`.
*/
vmaFlushAllocation :: (allocator: VmaAllocator, allocation: VmaAllocation, offset: VkDeviceSize, size: VkDeviceSize) -> VkResult #foreign libvma;

/** \brief Invalidates memory of given allocation.

Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.
It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.
Map operation doesn't do that automatically.

- `offset` must be relative to the beginning of allocation.
- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.
- `offset` and `size` don't have to be aligned.
They are internally rounded down/up to multiply of `nonCoherentAtomSize`.
- If `size` is 0, this call is ignored.
- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,
this call is ignored.

Warning! `offset` and `size` are relative to the contents of given `allocation`.
If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.
Do not pass allocation's offset as `offset`!!!

This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if
it is called, otherwise `VK_SUCCESS`.
*/
vmaInvalidateAllocation :: (allocator: VmaAllocator, allocation: VmaAllocation, offset: VkDeviceSize, size: VkDeviceSize) -> VkResult #foreign libvma;

/** \brief Flushes memory of given set of allocations.

Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.
For more information, see documentation of vmaFlushAllocation().

\param allocator
\param allocationCount
\param allocations
\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero.
\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.

This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is
called, otherwise `VK_SUCCESS`.
*/
vmaFlushAllocations :: (allocator: VmaAllocator, allocationCount: u32, allocations: *VmaAllocation, offsets: *VkDeviceSize, sizes: *VkDeviceSize) -> VkResult #foreign libvma;

/** \brief Invalidates memory of given set of allocations.

Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.
For more information, see documentation of vmaInvalidateAllocation().

\param allocator
\param allocationCount
\param allocations
\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero.
\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.

This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is
called, otherwise `VK_SUCCESS`.
*/
vmaInvalidateAllocations :: (allocator: VmaAllocator, allocationCount: u32, allocations: *VmaAllocation, offsets: *VkDeviceSize, sizes: *VkDeviceSize) -> VkResult #foreign libvma;

/** \brief Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.

\param allocator
\param memoryTypeBits Bit mask, where each bit set means that a memory type with that index should be checked.

Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,
`VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are
`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection).

Possible return values:

- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.
- `VK_SUCCESS` - corruption detection has been performed and succeeded.
- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.
`VMA_ASSERT` is also fired in that case.
- Other value: Error returned by Vulkan, e.g. memory mapping failure.
*/
vmaCheckCorruption :: (allocator: VmaAllocator, memoryTypeBits: u32) -> VkResult #foreign libvma;

/** \brief Begins defragmentation process.

\param allocator Allocator object.
\param pInfo Structure filled with parameters of defragmentation.
\param[out] pContext Context object that must be passed to vmaEndDefragmentation() to finish defragmentation.
\returns
- `VK_SUCCESS` if defragmentation can begin.
- `VK_ERROR_FEATURE_NOT_PRESENT` if defragmentation is not supported.

For more information about defragmentation, see documentation chapter:
[Defragmentation](@ref defragmentation).
*/
vmaBeginDefragmentation :: (allocator: VmaAllocator, pInfo: *VmaDefragmentationInfo, pContext: *VmaDefragmentationContext) -> VkResult #foreign libvma;

/** \brief Ends defragmentation process.

\param allocator Allocator object.
\param context Context object that has been created by vmaBeginDefragmentation().
\param[out] pStats Optional stats for the defragmentation. Can be null.

Use this function to finish defragmentation started by vmaBeginDefragmentation().
*/
vmaEndDefragmentation :: (allocator: VmaAllocator, _context: VmaDefragmentationContext, pStats: *VmaDefragmentationStats) -> void #foreign libvma;

/** \brief Starts single defragmentation pass.

\param allocator Allocator object.
\param context Context object that has been created by vmaBeginDefragmentation().
\param[out] pPassInfo Computed information for current pass.
\returns
- `VK_SUCCESS` if no more moves are possible. Then you can omit call to vmaEndDefragmentationPass() and simply end whole defragmentation.
- `VK_INCOMPLETE` if there are pending moves returned in `pPassInfo`. You need to perform them, call vmaEndDefragmentationPass(),
and then preferably try another pass with vmaBeginDefragmentationPass().
*/
vmaBeginDefragmentationPass :: (allocator: VmaAllocator, _context: VmaDefragmentationContext, pPassInfo: *VmaDefragmentationPassMoveInfo) -> VkResult #foreign libvma;

/** \brief Ends single defragmentation pass.

\param allocator Allocator object.
\param context Context object that has been created by vmaBeginDefragmentation().
\param pPassInfo Computed information for current pass filled by vmaBeginDefragmentationPass() and possibly modified by you.

Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.

Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.
After this call:

- Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY
(which is the default) will be pointing to the new destination place.
- Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY
will be freed.

If no more moves are possible you can end whole defragmentation.
*/
vmaEndDefragmentationPass :: (allocator: VmaAllocator, _context: VmaDefragmentationContext, pPassInfo: *VmaDefragmentationPassMoveInfo) -> VkResult #foreign libvma;

/** \brief Binds buffer to allocation.

Binds specified buffer to region of memory represented by specified allocation.
Gets `VkDeviceMemory` handle and offset from the allocation.
If you want to create a buffer, allocate memory for it and bind them together separately,
you should use this function for binding instead of standard `vkBindBufferMemory()`,
because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple
allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously
(which is illegal in Vulkan).

It is recommended to use function vmaCreateBuffer() instead of this one.
*/
vmaBindBufferMemory :: (allocator: VmaAllocator, allocation: VmaAllocation, buffer: VkBuffer) -> VkResult #foreign libvma;

/** \brief Binds buffer to allocation with additional parameters.

\param allocator
\param allocation
\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0.
\param buffer
\param pNext A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null.

This function is similar to vmaBindBufferMemory(), but it provides additional parameters.

If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag
or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.
*/
vmaBindBufferMemory2 :: (allocator: VmaAllocator, allocation: VmaAllocation, allocationLocalOffset: VkDeviceSize, buffer: VkBuffer, pNext: *void) -> VkResult #foreign libvma;

/** \brief Binds image to allocation.

Binds specified image to region of memory represented by specified allocation.
Gets `VkDeviceMemory` handle and offset from the allocation.
If you want to create an image, allocate memory for it and bind them together separately,
you should use this function for binding instead of standard `vkBindImageMemory()`,
because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple
allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously
(which is illegal in Vulkan).

It is recommended to use function vmaCreateImage() instead of this one.
*/
vmaBindImageMemory :: (allocator: VmaAllocator, allocation: VmaAllocation, image: VkImage) -> VkResult #foreign libvma;

/** \brief Binds image to allocation with additional parameters.

\param allocator
\param allocation
\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0.
\param image
\param pNext A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null.

This function is similar to vmaBindImageMemory(), but it provides additional parameters.

If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag
or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.
*/
vmaBindImageMemory2 :: (allocator: VmaAllocator, allocation: VmaAllocation, allocationLocalOffset: VkDeviceSize, image: VkImage, pNext: *void) -> VkResult #foreign libvma;

/** \brief Creates a new `VkBuffer`, allocates and binds memory for it.

\param allocator
\param pBufferCreateInfo
\param pAllocationCreateInfo
\param[out] pBuffer Buffer that was created.
\param[out] pAllocation Allocation that was created.
\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().

This function automatically:

-# Creates buffer.
-# Allocates appropriate memory for it.
-# Binds the buffer with the memory.

If any of these operations fail, buffer and allocation are not created,
returned value is negative error code, `*pBuffer` and `*pAllocation` are null.

If the function succeeded, you must destroy both buffer and allocation when you
no longer need them using either convenience function vmaDestroyBuffer() or
separately, using `vkDestroyBuffer()` and vmaFreeMemory().

If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,
VK_KHR_dedicated_allocation extension is used internally to query driver whether
it requires or prefers the new buffer to have dedicated allocation. If yes,
and if dedicated allocation is possible
(#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated
allocation for this buffer, just like when using
#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.

\note This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer,
although recommended as a good practice, is out of scope of this library and could be implemented
by the user as a higher-level logic on top of VMA.
*/
vmaCreateBuffer :: (allocator: VmaAllocator, pBufferCreateInfo: *VkBufferCreateInfo, pAllocationCreateInfo: *VmaAllocationCreateInfo, pBuffer: *VkBuffer, pAllocation: *VmaAllocation, pAllocationInfo: *VmaAllocationInfo) -> VkResult #foreign libvma;

/** \brief Creates a buffer with additional minimum alignment.

Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,
minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.
for interop with OpenGL.
*/
vmaCreateBufferWithAlignment :: (allocator: VmaAllocator, pBufferCreateInfo: *VkBufferCreateInfo, pAllocationCreateInfo: *VmaAllocationCreateInfo, minAlignment: VkDeviceSize, pBuffer: *VkBuffer, pAllocation: *VmaAllocation, pAllocationInfo: *VmaAllocationInfo) -> VkResult #foreign libvma;

/** \brief Creates a new `VkBuffer`, binds already created memory for it.

\param allocator
\param allocation Allocation that provides memory to be used for binding new buffer to it.
\param pBufferCreateInfo
\param[out] pBuffer Buffer that was created.

This function automatically:

-# Creates buffer.
-# Binds the buffer with the supplied memory.

If any of these operations fail, buffer is not created,
returned value is negative error code and `*pBuffer` is null.

If the function succeeded, you must destroy the buffer when you
no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding
allocation you can use convenience function vmaDestroyBuffer().

\note There is a new version of this function augmented with parameter `allocationLocalOffset` - see vmaCreateAliasingBuffer2().
*/
vmaCreateAliasingBuffer :: (allocator: VmaAllocator, allocation: VmaAllocation, pBufferCreateInfo: *VkBufferCreateInfo, pBuffer: *VkBuffer) -> VkResult #foreign libvma;

/** \brief Creates a new `VkBuffer`, binds already created memory for it.

\param allocator
\param allocation Allocation that provides memory to be used for binding new buffer to it.
\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the allocation. Normally it should be 0.
\param pBufferCreateInfo
\param[out] pBuffer Buffer that was created.

This function automatically:

-# Creates buffer.
-# Binds the buffer with the supplied memory.

If any of these operations fail, buffer is not created,
returned value is negative error code and `*pBuffer` is null.

If the function succeeded, you must destroy the buffer when you
no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding
allocation you can use convenience function vmaDestroyBuffer().

\note This is a new version of the function augmented with parameter `allocationLocalOffset`.
*/
vmaCreateAliasingBuffer2 :: (allocator: VmaAllocator, allocation: VmaAllocation, allocationLocalOffset: VkDeviceSize, pBufferCreateInfo: *VkBufferCreateInfo, pBuffer: *VkBuffer) -> VkResult #foreign libvma;

/** \brief Destroys Vulkan buffer and frees allocated memory.

This is just a convenience function equivalent to:

\code
vkDestroyBuffer(device, buffer, allocationCallbacks);
vmaFreeMemory(allocator, allocation);
\endcode

It is safe to pass null as buffer and/or allocation.
*/
vmaDestroyBuffer :: (allocator: VmaAllocator, buffer: VkBuffer, allocation: VmaAllocation) -> void #foreign libvma;

/// Function similar to vmaCreateBuffer().
vmaCreateImage :: (allocator: VmaAllocator, pImageCreateInfo: *VkImageCreateInfo, pAllocationCreateInfo: *VmaAllocationCreateInfo, pImage: *VkImage, pAllocation: *VmaAllocation, pAllocationInfo: *VmaAllocationInfo) -> VkResult #foreign libvma;

/// Function similar to vmaCreateAliasingBuffer() but for images.
vmaCreateAliasingImage :: (allocator: VmaAllocator, allocation: VmaAllocation, pImageCreateInfo: *VkImageCreateInfo, pImage: *VkImage) -> VkResult #foreign libvma;

/// Function similar to vmaCreateAliasingBuffer2() but for images.
vmaCreateAliasingImage2 :: (allocator: VmaAllocator, allocation: VmaAllocation, allocationLocalOffset: VkDeviceSize, pImageCreateInfo: *VkImageCreateInfo, pImage: *VkImage) -> VkResult #foreign libvma;

/** \brief Destroys Vulkan image and frees allocated memory.

This is just a convenience function equivalent to:

\code
vkDestroyImage(device, image, allocationCallbacks);
vmaFreeMemory(allocator, allocation);
\endcode

It is safe to pass null as image and/or allocation.
*/
vmaDestroyImage :: (allocator: VmaAllocator, image: VkImage, allocation: VmaAllocation) -> void #foreign libvma;

/** \brief Creates new #VmaVirtualBlock object.

\param pCreateInfo Parameters for creation.
\param[out] pVirtualBlock Returned virtual block object or `VMA_NULL` if creation failed.
*/
vmaCreateVirtualBlock :: (pCreateInfo: *VmaVirtualBlockCreateInfo, pVirtualBlock: *VmaVirtualBlock) -> VkResult #foreign libvma;

/** \brief Destroys #VmaVirtualBlock object.

Please note that you should consciously handle virtual allocations that could remain unfreed in the block.
You should either free them individually using vmaVirtualFree() or call vmaClearVirtualBlock()
if you are sure this is what you want. If you do neither, an assert is called.

If you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`,
don't forget to free them.
*/
vmaDestroyVirtualBlock :: (virtualBlock: VmaVirtualBlock) -> void #foreign libvma;

/** \brief Returns true of the #VmaVirtualBlock is empty - contains 0 virtual allocations and has all its space available for new allocations.
*/
vmaIsVirtualBlockEmpty :: (virtualBlock: VmaVirtualBlock) -> VkBool32 #foreign libvma;

/** \brief Returns information about a specific virtual allocation within a virtual block, like its size and `pUserData` pointer.
*/
vmaGetVirtualAllocationInfo :: (virtualBlock: VmaVirtualBlock, allocation: VmaVirtualAllocation, pVirtualAllocInfo: *VmaVirtualAllocationInfo) -> void #foreign libvma;

/** \brief Allocates new virtual allocation inside given #VmaVirtualBlock.

If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned
(despite the function doesn't ever allocate actual GPU memory).
`pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.

\param virtualBlock Virtual block
\param pCreateInfo Parameters for the allocation
\param[out] pAllocation Returned handle of the new allocation
\param[out] pOffset Returned offset of the new allocation. Optional, can be null.
*/
vmaVirtualAllocate :: (virtualBlock: VmaVirtualBlock, pCreateInfo: *VmaVirtualAllocationCreateInfo, pAllocation: *VmaVirtualAllocation, pOffset: *VkDeviceSize) -> VkResult #foreign libvma;

/** \brief Frees virtual allocation inside given #VmaVirtualBlock.

It is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing.
*/
vmaVirtualFree :: (virtualBlock: VmaVirtualBlock, allocation: VmaVirtualAllocation) -> void #foreign libvma;

/** \brief Frees all virtual allocations inside given #VmaVirtualBlock.

You must either call this function or free each virtual allocation individually with vmaVirtualFree()
before destroying a virtual block. Otherwise, an assert is called.

If you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`,
don't forget to free it as well.
*/
vmaClearVirtualBlock :: (virtualBlock: VmaVirtualBlock) -> void #foreign libvma;

/** \brief Changes custom pointer associated with given virtual allocation.
*/
vmaSetVirtualAllocationUserData :: (virtualBlock: VmaVirtualBlock, allocation: VmaVirtualAllocation, pUserData: *void) -> void #foreign libvma;

/** \brief Calculates and returns statistics about virtual allocations and memory usage in given #VmaVirtualBlock.

This function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics().
*/
vmaGetVirtualBlockStatistics :: (virtualBlock: VmaVirtualBlock, pStats: *VmaStatistics) -> void #foreign libvma;

/** \brief Calculates and returns detailed statistics about virtual allocations and memory usage in given #VmaVirtualBlock.

This function is slow to call. Use for debugging purposes.
For less detailed statistics, see vmaGetVirtualBlockStatistics().
*/
vmaCalculateVirtualBlockStatistics :: (virtualBlock: VmaVirtualBlock, pStats: *VmaDetailedStatistics) -> void #foreign libvma;

/** \brief Builds and returns a null-terminated string in JSON format with information about given #VmaVirtualBlock.
\param virtualBlock Virtual block.
\param[out] ppStatsString Returned string.
\param detailedMap Pass `VK_FALSE` to only obtain statistics as returned by vmaCalculateVirtualBlockStatistics(). Pass `VK_TRUE` to also obtain full list of allocations and free spaces.

Returned string must be freed using vmaFreeVirtualBlockStatsString().
*/
vmaBuildVirtualBlockStatsString :: (virtualBlock: VmaVirtualBlock, ppStatsString: **u8, detailedMap: VkBool32) -> void #foreign libvma;

/// Frees a string returned by vmaBuildVirtualBlockStatsString().
vmaFreeVirtualBlockStatsString :: (virtualBlock: VmaVirtualBlock, pStatsString: *u8) -> void #foreign libvma;

/** \brief Builds and returns statistics as a null-terminated string in JSON format.
\param allocator
\param[out] ppStatsString Must be freed using vmaFreeStatsString() function.
\param detailedMap
*/
vmaBuildStatsString :: (allocator: VmaAllocator, ppStatsString: **u8, detailedMap: VkBool32) -> void #foreign libvma;

vmaFreeStatsString :: (allocator: VmaAllocator, pStatsString: *u8) -> void #foreign libvma;

#scope_file

#if OS == .WINDOWS {
    libvma :: #library "windows/libvma";
} else #if OS == .LINUX {
    libvma :: #library "linux/libvma";
} else #if OS == .MACOS {
    libvma :: #library "macos/libvma";
} else #if OS == .ANDROID {
    libvma :: #library "android/libvma";
} else {
    #assert false "Unsupported OS";
}
